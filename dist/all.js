(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("lodash"), require("objectpath"));
	else if(typeof define === 'function' && define.amd)
		define("cn-flex-form", ["lodash", "objectpath"], factory);
	else if(typeof exports === 'object')
		exports["cn-flex-form"] = factory(require("lodash"), require("objectpath"));
	else
		root["cn-flex-form"] = factory(root["lodash"], root["objectpath"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_7__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _cnFlexFormConfig = __webpack_require__(1);
	
	var _cnFlexFormConfig2 = _interopRequireDefault(_cnFlexFormConfig);
	
	var _cnFlexFormTypes = __webpack_require__(2);
	
	var _cnFlexFormTypes2 = _interopRequireDefault(_cnFlexFormTypes);
	
	var _cnFlexForm = __webpack_require__(3);
	
	var _schemaFormExtensions = __webpack_require__(4);
	
	var _cnFlexForm2 = __webpack_require__(5);
	
	var _cnFlexForm3 = _interopRequireDefault(_cnFlexForm2);
	
	var _cnFlexFormModalLoader = __webpack_require__(8);
	
	var _cnFlexFormModalLoader2 = _interopRequireDefault(_cnFlexFormModalLoader);
	
	var _cnFlexFormModalLoader3 = __webpack_require__(9);
	
	var _cnFlexForm4 = __webpack_require__(10);
	
	var _cnFlexForm5 = _interopRequireDefault(_cnFlexForm4);
	
	var _cnFlexFormHeader = __webpack_require__(12);
	
	var _cnFlexFormHeader2 = _interopRequireDefault(_cnFlexFormHeader);
	
	var _cnFlexFormValidate = __webpack_require__(13);
	
	var _cnFlexFormValidate2 = _interopRequireDefault(_cnFlexFormValidate);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = angular.module('cn.flex-form', ['ui.router', 'schemaForm', 'ui.bootstrap.datetimepicker', 'cnTagsInput', 'cn.util']).provider('cnFlexFormConfig', _cnFlexFormConfig2.default).provider('cnFlexFormTypes', _cnFlexFormTypes2.default).provider('cnFlexFormRoutes', _cnFlexForm.cnFlexFormRoutesProvider).config(_cnFlexForm.cnFlexFormRoutes).config(_schemaFormExtensions.schemaFormConfig).run(_schemaFormExtensions.addTemplates).provider('cnFlexFormService', _cnFlexForm3.default).provider('cnFlexFormModalLoaderService', _cnFlexFormModalLoader2.default).factory('FlexFormModal', _cnFlexFormModalLoader3.FlexFormModal).controller('FlexFormModalLoader', _cnFlexFormModalLoader3.FlexFormModalLoader).directive('cnFlexForm', _cnFlexForm5.default).directive('cnFlexFormHeader', _cnFlexFormHeader2.default).directive('ffValidate', _cnFlexFormValidate2.default).name;

/***/ },
/* 1 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function cnFlexFormConfigProvider() {
	
	  cnFlexFormConfig.$inject = ["$stateParams"];
	  var ignoreParams = ['page', 'debug', 'sandbox', 'modal', 'modalId'];
	
	  return {
	    addIgnoreParam: addIgnoreParam,
	    $get: cnFlexFormConfig
	  };
	
	  ////////
	
	  function addIgnoreParam(param) {
	    ignoreParams.push(param);
	  }
	
	  function cnFlexFormConfig($stateParams) {
	    'ngInject';
	
	    return {
	      getStateParams: getStateParams,
	      ignoreParams: ignoreParams
	    };
	
	    ////////
	
	    function getStateParams() {
	      var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	      return _(_extends({}, $stateParams, overrides)).omit(ignoreParams).omit(function (v) {
	        return _.isUndefined(v) || v === null;
	      }).value();
	    }
	  }
	}
	
	//angular
	//.module('cn.flex-form')
	//.provider('cnFlexFormConfig', cnFlexFormConfigProvider);
	
	exports.default = cnFlexFormConfigProvider;

/***/ },
/* 2 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	function cnFlexFormTypesProvider() {
	
	  var fieldTypeRegister = [{
	    condition: function condition(field) {
	      return field.type === 'hidden';
	    },
	    type: 'hidden'
	  }, {
	    condition: function condition(field) {
	      return field.type.includes('radios');
	    },
	    type: 'cn-radios'
	  }, {
	    condition: function condition(field) {
	      return field.type.includes('radiobuttons');
	    },
	    type: 'cn-radiobuttons'
	  }, {
	    condition: function condition(field) {
	      return field.type.includes('autocomplete') || field.titleMap || field.titleMapResolve || field.titleMapQuery;
	    },
	    type: 'cn-autocomplete'
	  }, {
	    condition: function condition(field) {
	      return field.type === 'cn-datetimepicker' || field.type === 'datetime-local' || field.type === 'time-minutes';
	    },
	    type: 'cn-datetimepicker'
	  }, {
	    condition: function condition(field) {
	      return field.type === 'help';
	    },
	    type: 'help'
	  }, {
	    condition: function condition(field) {
	      return field.type.includes('display');
	    },
	    type: 'cn-display'
	  }, {
	    condition: function condition(field) {
	      return field.schema && field.schema.format && field.schema.format.includes('currency');
	    },
	    type: 'cn-currency'
	  }, {
	    condition: function condition(field) {
	      return field.schema && field.schema.format === 'percentage';
	    },
	    type: 'cn-percentage'
	  }, {
	    condition: function condition(field) {
	      return field.schema && field.type === 'url';
	    },
	    type: 'cn-url'
	  }, {
	    condition: function condition(field) {
	      return field.type === 'toggle' || field.type === 'boolean';
	    },
	    type: 'cn-toggle'
	  }, {
	    condition: function condition(field) {
	      return field.type === 'creativeimage';
	    },
	    type: 'cn-creativeimage'
	  }, {
	    condition: function condition(field) {
	      return field.type === 'facebookvideo';
	    },
	    type: 'cn-facebookvideo'
	  }, {
	    condition: function condition(field) {
	      return field.type === 'mediaupload';
	    },
	    type: 'cn-mediaupload'
	  }, {
	    condition: function condition(field) {
	      return field.type === 'csvupload';
	    },
	    type: 'cn-csvupload'
	  }, {
	    condition: function condition(field) {
	      return field.type === 'reusable';
	    },
	    type: 'cn-reusable'
	  }, {
	    condition: function condition(field) {
	      return field.type === 'table';
	    },
	    type: 'cn-table'
	  }, {
	    condition: function condition(field) {
	      return field.type === 'array';
	    },
	    type: 'array'
	  }, {
	    condition: function condition(field) {
	      return field.type === 'schedule';
	    },
	    type: 'cn-schedule'
	  }, {
	    condition: function condition(field) {
	      return field.schema && field.schema.type === 'number';
	    },
	    type: 'cn-number'
	  }];
	
	  return {
	    registerFieldType: registerFieldType,
	    $get: cnFlexFormTypes
	  };
	
	  ////////
	
	  function registerFieldType(fieldType) {
	    fieldTypeRegister.unshift(fieldType);
	  }
	
	  function cnFlexFormTypes() {
	    return {
	      fieldTypeRegister: fieldTypeRegister,
	      getFieldType: getFieldType
	    };
	
	    /////////
	
	    function getFieldType(field) {
	      for (var i = 0, l = fieldTypeRegister.length; i < l; i++) {
	        if (fieldTypeRegister[i].condition(field)) {
	          return fieldTypeRegister[i].type;
	        }
	      }
	      return field.type || field.schema && field.schema.type;
	    }
	  }
	}
	
	exports.default = cnFlexFormTypesProvider;

/***/ },
/* 3 */
/***/ function(module, exports) {

	'use strict';
	
	cnFlexFormRoutesProvider.$inject = ["$stateProvider"];
	cnFlexFormRoutes.$inject = ["$stateProvider"];
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function cnFlexFormRoutesProvider($stateProvider) {
	  'ngInject';
	
	  return {
	    addStates: addStates,
	    $get: $get
	  };
	
	  ////////////
	
	  function $get() {
	    // nothing to do here, but required
	  }
	
	  function addStates(_ref) {
	    var permissions = _ref.permissions,
	        name = _ref.name;
	
	    var shared = {
	      controller: 'FlexFormModalLoader',
	      controllerAs: 'vm',
	      permissions: permissions
	    };
	    $stateProvider.state(name + '.page.modal', _extends({
	      url: '/~:modal/:modalId'
	    }, shared)).state(name + '.page.modalParams', _extends({
	      url: '/~:modal/:modalId/:restParams'
	    }, shared));
	  }
	}
	
	function cnFlexFormRoutes($stateProvider) {
	  'ngInject';
	
	  $stateProvider.state('flex-form-sandbox', {
	    url: '/flex-form/sandbox',
	    controller: 'FlexFormSandbox',
	    controllerAs: 'vm',
	    templateUrl: 'app/components/cn-flex-form/sandbox.html'
	  });
	}
	
	exports.cnFlexFormRoutes = cnFlexFormRoutes;
	exports.cnFlexFormRoutesProvider = cnFlexFormRoutesProvider;

/***/ },
/* 4 */
/***/ function(module, exports) {

	'use strict';
	
	schemaFormConfig.$inject = ["cnFlexFormServiceProvider"];
	addTemplates.$inject = ["$templateCache"];
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	function schemaFormConfig(cnFlexFormServiceProvider) {
	  'ngInject';
	
	  tv4.addFormat({
	    'url': function url(data) {
	      return _.isString(data) && !/^(https?:\/\/.{2}|$)/.test(data) && 'invalid url';
	    }
	  });
	
	  var extensions = ['cn-fieldset', 'cn-toggle', 'cn-datetimepicker', 'cn-autocomplete', 'cn-autocomplete-detailed', 'cn-number', 'cn-currency', 'cn-url', 'cn-radios', 'cn-radiobuttons', 'cn-percentage', 'cn-display', 'cn-mediaupload', 'cn-csvupload', 'cn-reusable', 'cn-table', 'cn-creativeimage', 'cn-schedule', 'cn-facebookvideo'];
	
	  _.each(extensions, function (extension) {
	    cnFlexFormServiceProvider.registerField({
	      type: extension,
	      templateUrl: 'app/components/cn-flex-form/forms/' + extension + '.html'
	    });
	  });
	}
	
	function addTemplates($templateCache) {
	  'ngInject';
	
	  $templateCache.put('app/components/cn-flex-form/forms/cn-toggle.html', '\n      <div class="form-group {{form.htmlClass}}"\n           ng-class="{\'has-error\': hasError(), \'has-success\': hasSuccess()}">\n        <label class="control-label" ng-show="showTitle()">{{form.title}}</label>\n        <div class="clearfix">\n          <cn-toggle-switch\n            name="{{form.key.join(\'.\')}}"\n            class="pull-left"\n            ng-show="form.key"\n            ng-model-options="form.ngModelOptions"\n            ng-model="$$value$$"\n            sf-changed="form"\n            schema-validate="form"\n            on-value="form.onValue"\n            off-value="form.offValue"\n            ng-required="form.required"\n            read-only="form.readonly"\n            undefined-class="form.undefinedClass"/>\n          <span ng-show="form.onText && form.offText">\n            {{$$value$$ === form.onValue ? form.onText : form.offText}}\n          </span>\n        </div>\n        <span class="help-block" sf-message="form.description"></span>\n      </div>');
	
	  $templateCache.put('app/components/cn-flex-form/forms/cn-datetimepicker.html', '\n      <div class="form-group {{form.htmlClass}}"\n           ng-class="{\'has-error\': hasError(), \'has-success\': hasSuccess()}">\n        <label class="control-label"\n               for="{{form.key.join(\'.\')}}"\n               ng-show="showTitle()">{{form.title}}</label>\n        <cn-datetimepicker\n          ng-show="form.key"\n          ng-model="$$value$$"\n          ng-model-options="form.ngModelOptions"\n          is-disabled="form.readonly"\n          sf-changed="form"\n          schema-validate="form"\n          input-id="{{form.key.join(\'.\')}}"\n          min-date="form.minDate"\n          max-date="form.maxDate"\n          max-view="{{form.maxView}}"\n          default-time="form.defaultTime"\n          cn-date-required="form.required"\n          placeholder="{{form.placeholder}}"\n          model-type="{{form.schema.type}}"\n          model-formatter="form.modelFormatter"\n          model-parser="form.modelParser"\n          view-formatter="form.viewFormatter"\n          view-parser="form.viewParser"\n          format-string={{form.dateFormat}}\n          icon-class={{form.iconClass}}>\n        </cn-datetimepicker>\n        <span class="help-block" sf-message="form.description"></span>\n      </div>');
	
	  var sharedAutocompleteTpl = '\n        <tags-input\n          ng-show="form.key"\n          ng-model="$$value$$"\n          ng-model-options="form.ngModelOptions"\n          ng-disabled="form.readonly"\n          sf-changed="form"\n          schema-validate="form"\n          input-id="{{form.key.join(\'.\')}}"\n          display-property="{{form.displayProperty || \'name\'}}"\n          value-property="{{form.valueProperty}}"\n          placeholder="{{form.placeholder || \' \'}}"\n          clear-on-blur="true"\n          add-on-comma="false"\n          add-from-autocomplete-only="{{!form.allowNew}}"\n          on-before-tag-added="form.onAdd({value: $tag}, form, $event, $prev)"\n          on-init="form.onInit($tag, form, $event, $setter)"\n          model-type="{{form.getSchemaType()}}"\n          array-value-type="{{form.schema.items.type}}"\n          hide-tags="{{form.detailedList}}"\n          tags-style="{{form.selectionStyle}}"\n          required="{{form.required}}"\n          min-length="{{form.minLength}}"\n          allowed-tags-pattern=".*"\n          dropdown-icon="true"\n          item-formatter="form.itemFormatter"\n          min-tags="{{form.minItems || form.schema.minItems}}"\n          max-tags="{{form.maxItems || form.schema.maxItems || (form.getSchemaType() !== \'array\' ? 1 : 0)}}"\n          allow-bulk="{{form.bulkAdd}}"\n          bulk-delimiter="{{form.bulkDelimiter}}"\n          bulk-placeholder="{{form.bulkPlaceholder}}"\n          bulk-single-request="{{form.bulkSingleRequest}}"\n          sort-filtered-results="{{(form.titleMapResolve || form.titleMap) && !form.titleMapQuery}}"\n          show-clear-all="{{form.showClearAll}}"\n          show-clear-cache="{{form.showClearCache}}"\n          show-button="true">\n          <auto-complete\n            source="form.getTitleMap && form.getTitleMap() || form.titleQuery($query, options)"\n            skip-filtering="{{form.skipFiltering}}"\n            single-query="{{form.singleQuery}}"\n            debounce-delay="{{form.debounceDelay}}"\n            min-length="{{form.minLookup}}">\n          </auto-complete>\n        </tags-input>';
	
	  $templateCache.put('app/components/cn-flex-form/forms/cn-autocomplete.html', '\n      <div class="form-group {{form.htmlClass}}"\n           ng-class="{\'has-error\': hasError(), \'has-success\': hasSuccess()}">\n        <label class="control-label"\n               for="{{form.key.join(\'.\')}}-input"\n               ng-show="showTitle()">{{form.title}}</label>\n        ' + sharedAutocompleteTpl + '\n        <span class="help-block" sf-message="form.description"></span>\n      </div>');
	
	  $templateCache.put('app/components/cn-flex-form/forms/cn-autocomplete-detailed.html', '\n      <div class="form-group {{form.htmlClass}}"\n           ng-class="{\'has-error\': hasError(), \'has-success\': hasSuccess()}">\n        <label class="control-label"\n               for="{{form.key.join(\'.\')}}-input"\n               ng-show="showTitle()">{{form.title}}</label>\n        <div sf-array="form">\n          <ol class="list-group cn-autocomplete-list"\n              ng-if="modelArray.length"\n              ng-model="modelArray">\n            <li class="list-group-item {{form.fieldHtmlClass}}"\n                ng-repeat="item in modelArray track by $index">\n              <button ng-hide="form.readonly || form.remove === null"\n                      ng-click="deleteFromArray($index)"\n                      type="button" class="close pull-right">\n                <span aria-hidden="true">&times;</span>\n              </button>\n              <sf-decorator form="copyWithIndex($index)"/>\n            </li>\n          </ol>\n        </div>\n        ' + sharedAutocompleteTpl + '\n        <span class="help-block" sf-message="form.description"></span>\n      </div>');
	
	  $templateCache.put('app/components/cn-flex-form/forms/cn-number.html', '\n      <div class="form-group {{form.htmlClass}}"\n           ng-class="{\'has-error\': hasError(), \'has-success\': hasSuccess()}">\n        <label class="control-label"\n               ng-show="showTitle()"\n               for="{{form.key.join(\'.\')}}">{{form.title}}</label>\n        <div class="{{form.fieldClass}}">\n          <input class="form-control"\n                 cn-number\n                 ng-show="form.key"\n                 ng-model-options="form.ngModelOptions"\n                 ng-disabled="form.readonly"\n                 sf-changed="form"\n                 schema-validate="form"\n                 type="text"\n                 step="any"\n                 min="{{form.min}}"\n                 max="{{form.max}}"\n                 id="{{form.key.join(\'.\')}}"\n                 name="{{form.key.join(\'.\')}}"\n                 ng-model="$$value$$">\n        </div>\n        <span class="help-block" sf-message="form.description"></span>\n      </div>');
	
	  $templateCache.put('app/components/cn-flex-form/forms/cn-currency.html', '\n      <div class="form-group {{form.htmlClass}}"\n           ng-class="{\'has-error\': hasError(), \'has-success\': hasSuccess()}">\n        <label class="control-label"\n               ng-show="showTitle()"\n               for="{{form.key.join(\'.\')}}">{{form.title}}</label>\n        <div class="{{form.fieldClass}} input-group">\n          <label class="input-group-addon"\n                 ng-disabled="form.readonly"\n                 for="{{form.key.join(\'.\')}}">$</label>\n          <input class="form-control"\n                 cn-currency-format="{{form.currencyFormat}}"\n                 cn-currency-placeholder="{{form.placeholder}}"\n                 ng-show="form.key"\n                 ng-model-options="form.ngModelOptions"\n                 ng-disabled="form.readonly"\n                 sf-changed="form"\n                 schema-validate="form"\n                 type="text"\n                 step="any"\n                 min="{{form.min}}"\n                 max="{{form.max}}"\n                 id="{{form.key.join(\'.\')}}"\n                 name="{{form.key.join(\'.\')}}"\n                 ng-model="$$value$$">\n        </div>\n        <span class="help-block" sf-message="form.description"></span>\n      </div>');
	
	  $templateCache.put('app/components/cn-flex-form/forms/cn-url.html', '\n      <div class="form-group {{form.htmlClass}}"\n           ng-class="{\'has-error\': hasError(), \'has-success\': hasSuccess()}">\n        <label class="control-label"\n               ng-show="showTitle()"\n               for="{{form.key.join(\'.\')}}">{{form.title}}</label>\n        <input class="form-control"\n               placeholder="https://"\n               cn-url-format\n               ng-show="form.key"\n               ng-model-options="form.ngModelOptions"\n               ng-disabled="form.readonly"\n               sf-changed="form"\n               schema-validate="form"\n               type="text"\n               id="{{form.key.join(\'.\')}}"\n               name="{{form.key.join(\'.\')}}"\n               ng-model="$$value$$">\n        <span class="help-block" sf-message="form.description"></span>\n      </div>');
	
	  $templateCache.put('app/components/cn-flex-form/forms/cn-radios.html', '<div class="form-group {{form.htmlClass}}"\n            ng-class="{\'has-error\': hasError(), \'has-success\': hasSuccess()}">\n         <label class="control-label" ng-show="showTitle()">{{form.title}}</label>\n         <div class="btn-group clearfix">\n           <label class="radio radio-block"\n                  ng-repeat="item in form.titleMap">\n             <input type="radio"\n                    sf-changed="form"\n                    ng-disabled="form.readonly"\n                    ng-model="$$value$$"\n                    ng-model-options="form.ngModelOptions"\n                    schema-validate="form"\n                    ff-validate="form"\n                    ng-value="item.value"\n                    name="{{form.key.join(\'.\')}}">\n             <span class="radio-block-icon" ng-if="item.iconClass || item.iconPath">\n               <i ng-if="item.iconClass" class="fa fa-{{item.iconClass}} fa-lg"></i>\n               <img ng-if="item.iconPath" class="custom" ng-src="{{item.iconPath}}"/>\n             </span>\n             <span ng-bind-html="item.name"></span>\n           </label>\n         </div>\n         <span class="help-block" sf-message="form.description"></span>\n       </div>');
	
	  $templateCache.put('app/components/cn-flex-form/forms/cn-radiobuttons.html', '\n      <div class="form-group schema-form-radiobuttons cn-radiobuttons {{form.htmlClass}}"\n           ng-class="{\'has-error\': hasError(), \'has-success\': hasSuccess()}">\n        <label class="control-label" ng-show="showTitle()">{{form.title}}</label>\n        <div class="btn-group clearfix">\n          <label class="btn btn-{{item.value}} {{form.btnClass}} {{item.value === $$value$$ ? \'active\' : \'\'}}"\n                 ng-repeat="item in form.titleMap">\n            <input type="radio"\n                   class="{{form.fieldHtmlClass}} hide"\n                   sf-changed="form"\n                   ng-disabled="form.readonly"\n                   ng-model="$$value$$"\n                   ng-model-options="form.ngModelOptions"\n                   schema-validate="form"\n                   ff-validate="form"\n                   ng-value="item.value"\n                   name="{{form.key.join(\'.\')}}">\n            <i class="fa fa-{{item.value}} fa-lg"></i>\n            <span ng-bind-html="item.name"></span>\n          </label>\n        </div>\n        <span class="help-block" sf-message="form.description"></span>\n      </div>');
	
	  $templateCache.put('app/components/cn-flex-form/forms/cn-percentage.html', '\n      <div class="form-group {{form.htmlClass}}"\n           ng-class="{\'has-error\': hasError(), \'has-success\': hasSuccess()}">\n        <label class="control-label"\n               ng-show="showTitle()"\n               for="{{form.key && form.key[0]}}">{{form.title}}</label>\n        <div class="{{form.fieldClass}} input-group">\n          <input class="form-control"\n                 cn-percentage-format\n                 ng-show="form.key"\n                 ng-model-options="form.ngModelOptions"\n                 ng-disabled="form.readonly"\n                 sf-changed="form"\n                 schema-validate="form"\n                 type="number"\n                 step="any"\n                 min="{{form.min}}"\n                 max="{{form.max}}"\n                 id="{{form.key && form.key[0]}}"\n                 name="{{form.key && form.key[0]}}"\n                 ng-model="$$value$$">\n           <div class="input-group-addon"\n                  ng-disabled="form.readonly"\n                  for="{{form.key && form.key[0]}}">%</div>\n        </div>\n        <span class="help-block" sf-message="form.description"></span>\n      </div>');
	
	  $templateCache.put('app/components/cn-flex-form/forms/cn-display.html', '\n      <div class="form-group cn-display{{form.htmlClass}}">\n        <input ng-show="form.key"\n               class="form-control"\n               id="{{form.key.join(\'.\')}}"\n               name="{{form.key.join(\'.\')}}"\n               ng-disabled="true"\n               value="{{form.getDisplay(form.key, form.arrayIndex)}}">\n      </div>');
	
	  $templateCache.put('app/components/cn-flex-form/forms/cn-fieldset.html', '\n      <fieldset\n        ng-disabled="form.readonly"\n        class="schema-form-fieldset {{form.htmlClass}}"\n        ng-class="{\'borderless\': form.pos === 0, \'notitle\': form.notitle || !form.title}">\n        <legend ng-hide="form.notitle"\n                ng-click="form.toggleCollapse(form)"\n                ng-class="{\'sr-only\': !showTitle(), collapsible: form.collapsible}"\n                ng-mouseenter="form.render = true">\n          <i ng-show="form.collapsible"\n             class="fa fa-caret-{{form.collapsed ? \'right\' : \'down\'}}"></i>\n          {{ form.title }}\n        </legend>\n        <div class="help-block" ng-show="form.description" ng-bind-html="form.description"></div>\n        <div uib-collapse="form.collapsed">\n          <div ng-if="form.render">\n            <sf-decorator ng-repeat="item in form.items" form="item"/>\n          </div>\n        </div>\n      </fieldset>');
	
	  $templateCache.put('app/components/cn-flex-form/forms/cn-mediaupload.html', '\n      <div class="form-group {{form.htmlClass}}"\n           ng-class="{\'has-error\': hasError(), \'has-success\': hasSuccess()}">\n        <label class="control-label"\n               ng-show="showTitle()"\n               for="{{form.key && form.key[0]}}">{{form.title}}</label>\n        <media-upload ng-model="$$value$$"\n                      cn-disabled="form.readonly"\n                      cn-file-type="form.fileType"\n                      cn-text-button="form.textButton"\n                      cn-upload-path="form.uploadPath"\n                      cn-data="form.data"\n                      cn-preview-path="form.previewPath"\n                      cn-model-value-key="form.modelValueKey"\n                      cn-existing-preview="form.existingPreview"\n                      cn-image-previews="form.data.imagePreviews"\n                      cn-key="form.key && form.key[0]"\n                      cn-form="form"\n                      ng-model-options="form.ngModelOptions"\n                      sf-changed="form"\n                      schema-validate="form"\n                      ff-form="form"\n                      class="clearfix">\n        </media-upload>\n        <span class="help-block" sf-message="form.description"></span>\n     </div>');
	
	  $templateCache.put('app/components/cn-flex-form/forms/cn-csvupload.html', '\n      <div class="form-group {{form.htmlClass}}"\n           ng-class="{\'has-error\': hasError(), \'has-success\': hasSuccess()}">\n        <label class="control-label"\n               ng-show="showTitle()"\n               for="{{form.key && form.key[0]}}">{{form.title}}</label>\n        <csv-upload ng-model="$$value$$"\n                      cn-upload-path="form.uploadPath"\n                      ng-model-options="form.ngModelOptions"\n                      sf-changed="form"\n                      schema-validate="form"\n                      ff-form="form"\n                      class="clearfix">\n        </csv-upload>\n        <span class="help-block" sf-message="form.description"></span>\n     </div>');
	
	  $templateCache.put('app/components/cn-flex-form/forms/cn-reusable.html', '\n      <div class="form-group cn-reusable {{form.htmlClass}}"\n           ng-class="{\'has-error\': hasError(), \'has-success\': hasSuccess()}">\n        <label class="control-label"\n               ng-show="showTitle()"\n               for="{{form.key.join(\'.\')}}">{{form.title}}</label>\n        <cn-select-or\n          ng-show="form.key"\n          select-from="form.library"\n          ng-model="$$value$$"\n          ng-model-options="form.ngModelOptions"\n          sf-changed="form"\n          schema-validate="form"\n          ff-form="form"\n          directiveId="form.directiveId"\n          item-template="form.itemTemplate"\n          toggle-text="form.toggleText"\n          ng-disabled="form.readonly"\n          view="form.view">\n          <sf-decorator ng-repeat="item in form.items" form="item"/>\n        </cn-select-or>\n        <p ng-if="form.loadMore && form.view === \'list\'">\n          <a ng-click="form.loadMore()"\n             class="btn btn-default btn-block">Load More</a>\n        </p>\n        <span class="help-block" sf-message="form.description"></span>\n      </div>');
	
	  $templateCache.put('app/components/cn-flex-form/forms/cn-table.html', '\n      <div class="form-group cn-ff-table {{form.htmlClass}}"\n           ng-class="{\'has-error\': hasError(), \'has-success\': hasSuccess()}">\n        <h6>{{form.title}}</h6>\n        <div class="row">\n          <div ng-repeat="col in form.columns" class="{{col.columnWidth}}">\n            <p class="column-header">{{col.columnHeader}}</p>\n          </div>\n        </div>\n        <div class="row" ng-repeat="row in form.items">\n          <div ng-repeat="col in row.items" class="{{col.columnWidth}}">\n            <sf-decorator form="col"></sf-decorator>\n          </div>\n        </div>\n        <span class="help-block" sf-message="form.description"></span>\n      </div>');
	
	  $templateCache.put('app/components/cn-flex-form/forms/cn-creativeimage.html', '\n      <div class="form-group {{form.htmlClass}}"\n           ng-class="{\'has-error\': hasError(), \'has-success\': hasSuccess()}">\n        <label class="control-label"\n               ng-show="showTitle()"\n               for="{{form.key && form.key[0]}}">{{form.title}}</label>\n        <cn-creative-image ng-model="$$value$$"\n                      cn-disabled="form.readonly"\n                      cn-upload-path="form.uploadPath"\n                      cn-data="form.data"\n                      cn-preview-path="form.previewPath"\n                      cn-model-value-key="form.modelValueKey"\n                      cn-existing-preview="form.existingPreview"\n                      ng-model-options="form.ngModelOptions"\n                      cn-ng-model-key="form.ngModelKey"\n                      sf-changed="form"\n                      schema-validate="form"\n                      ff-form="form"\n                      class="clearfix">\n        </cn-creative-image>\n        <span class="help-block" sf-message="form.description"></span>\n     </div>');
	
	  $templateCache.put('app/components/cn-flex-form/forms/cn-schedule.html', '\n      <div class="form-group {{ form.htmlClass }}"\n           ng-class="{ \'has-error\': hasError(), \'has-success\': hasSuccess() }">\n        <label class="control-label"\n               ng-show="showTitle()"\n               for="{{ form.key.join(\'.\') }}">\n          {{ form.title }}\n        </label>\n        <cn-schedule form="form"\n                     ng-model="$$value$$">\n        </cn-schedule>\n        <span class="help-block" sf-message="form.description"></span>\n      </div>\n    ');
	
	  $templateCache.put('app/components/cn-flex-form/forms/cn-facebookvideo.html', '\n      <div class="form-group {{form.htmlClass}}"\n           ng-class="{\'has-error\': hasError(), \'has-success\': hasSuccess()}">\n        <label class="control-label"\n               ng-show="showTitle()"\n               for="{{form.key && form.key[0]}}">{{form.title}}</label>\n        <cn-facebook-video ng-model="$$value$$"\n                      cn-disabled="form.readonly"\n                      cn-upload-path="form.uploadPath"\n                      cn-data="form.data"\n                      cn-preview-path="form.previewPath"\n                      cn-model-value-key="form.modelValueKey"\n                      cn-existing-preview="form.existingPreview"\n                      ng-model-options="form.ngModelOptions"\n                      cn-video-key="form.videoKey"\n                      cn-thumbnail-key="form.thumbnailKey"\n                      cn-image-id-key="form.imageIdKey"\n                      sf-changed="form"\n                      schema-validate="form"\n                      ff-form="form"\n                      class="clearfix">\n        </cn-facebook-video>\n        <span class="help-block" sf-message="form.description"></span>\n     </div>');
	}
	
	exports.schemaFormConfig = schemaFormConfig;
	exports.addTemplates = addTemplates;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	cnFlexFormServiceProvider.$inject = ["schemaFormDecoratorsProvider", "cnFlexFormTypesProvider"];
	CNFlexFormService.$inject = ["Api", "$parse", "cnFlexFormConfig", "cnFlexFormTypes", "sfPath", "$interpolate", "$timeout", "cnUtil", "$stateParams"];
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	// Need these modules for test bundle
	var _ = typeof window !== "undefined" && window._ || __webpack_require__(6);
	var ObjectPath = typeof window !== "undefined" && window.ObjectPath || __webpack_require__(7);
	
	var fieldTypeHandlers = {
	  fieldset: "processFieldset",
	  "cn-radios": "processRadios",
	  "cn-radiobuttons": "processRadiobuttons",
	  "cn-autocomplete": "processSelect",
	  "cn-datetimepicker": "processDate",
	  help: "processHelp",
	  "cn-display": "processDisplay",
	  "cn-number": "processNumber",
	  "cn-currency": "processCurrency",
	  "cn-percentage": "processPercentage",
	  "cn-url": "processUrl",
	  "cn-mediaupload": "processMediaUpload",
	  "cn-creativeimage": "processCreativeImage",
	  "cn-facebookvideo": "processFacebookVideo",
	  "cn-csvupload": "processCsvUpload",
	  "cn-reusable": "processReusable",
	  "cn-toggle": "processToggle",
	  "cn-table": "processTable",
	  component: "processComponent",
	  section: "processSection",
	  tabarray: "processSection",
	  array: "processArray",
	  "cn-schedule": "processSchedule"
	};
	
	// handlers that don't run on secondPass are ones that shouldn't ever change
	// and we want to avoid compounding their effects
	var fieldPropHandlers = [{
	  prop: "default",
	  handler: function handler(field, service) {
	    return service.processDefault(field);
	  }
	}, {
	  prop: "resolve",
	  handler: function handler(field, service, secondPass) {
	    return !secondPass && service.processResolve(field);
	  }
	}, {
	  prop: "selectDisplay",
	  handler: function handler(field, service) {
	    return service.processSelectDisplay(field);
	  }
	}, {
	  prop: "schema",
	  handler: function handler(field, service) {
	    return _.isUndefined(field.default) && !_.isUndefined(field.schema.default) && service.processDefault(field);
	  }
	}, {
	  prop: "watch",
	  handler: function handler(field, service, secondPass) {
	    return !secondPass && field.watch && service.processFieldWatch(field);
	  }
	}, {
	  prop: "type",
	  handler: function handler(field, service, secondPass) {
	    return service.processFieldType(field, secondPass);
	  }
	}, {
	  prop: "conditionals",
	  handler: function handler(field, service) {
	    return service.processConditional(field);
	  }
	}, {
	  prop: "updateSchema",
	  handler: function handler(field, service, secondPass) {
	    return !secondPass && service.processFieldUpdatedSchema(field);
	  }
	}];
	
	function cnFlexFormServiceProvider(schemaFormDecoratorsProvider, cnFlexFormTypesProvider) {
	  "ngInject";
	
	  return {
	    registerField: registerField,
	    $get: CNFlexFormService
	  };
	
	  //////////
	
	  function registerField(fieldType) {
	    if (fieldType.condition) {
	      cnFlexFormTypesProvider.registerFieldType({
	        condition: fieldType.condition,
	        type: fieldType.type
	      });
	    }
	
	    if (fieldType.handler) {
	      fieldTypeHandlers[fieldType.type] = fieldType.handler;
	    }
	
	    if (fieldType.templateUrl) {
	      schemaFormDecoratorsProvider.addMapping("bootstrapDecorator", fieldType.type, fieldType.templateUrl);
	      schemaFormDecoratorsProvider.createDirective(fieldType.type, fieldType.templateUrl);
	    }
	  }
	}
	
	function CNFlexFormService(Api, $parse, cnFlexFormConfig, cnFlexFormTypes, sfPath, $interpolate, $timeout, cnUtil, $stateParams) {
	  "ngInject";
	
	  var services = [];
	  var prototype = {
	    compile: compile,
	    addArrayCopy: addArrayCopy,
	    addToDataCache: addToDataCache,
	    addToFormCache: addToFormCache,
	    addToScopeCache: addToScopeCache,
	    broadcastErrors: broadcastErrors,
	    buildError: buildError,
	    cleanup: cleanup,
	    deleteArrayCopiesFor: deleteArrayCopiesFor,
	    deregisterHandlers: deregisterHandlers,
	    deregisterArrayHandlers: deregisterArrayHandlers,
	    getArrayCopy: getArrayCopy,
	    getArrayCopies: getArrayCopies,
	    getArrayCopiesFor: getArrayCopiesFor,
	    getArrayScopes: getArrayScopes,
	    getDefault: getDefault,
	    getFromDataCache: getFromDataCache,
	    getFromFormCache: getFromFormCache,
	    getFromScopeCache: getFromScopeCache,
	    getFormsToProcess: getFormsToProcess,
	    getKey: getKey,
	    getSchema: getSchema,
	    getWatchables: getWatchables,
	    handleResolve: handleResolve,
	    incrementUpdates: incrementUpdates,
	    initArrayCopyWatch: initArrayCopyWatch,
	    initModelWatch: initModelWatch,
	    initSchemaParams: initSchemaParams,
	    isCompiled: isCompiled,
	    onModelWatch: onModelWatch,
	    parseAll: parseAll,
	    parseAny: parseAny,
	    parseCondition: parseCondition,
	    parseExpression: parseExpression,
	    processArray: processArray,
	    processCreativeImage: processCreativeImage,
	    processDefault: processDefault,
	    processDisplay: processDisplay,
	    processFacebookVideo: processFacebookVideo,
	    processField: processField,
	    processFieldset: processFieldset,
	    processFieldProps: processFieldProps,
	    processFieldType: processFieldType,
	    processFieldUpdatedSchema: processFieldUpdatedSchema,
	    processFieldWatch: processFieldWatch,
	    processComponent: processComponent,
	    processConditional: processConditional,
	    processCurrency: processCurrency,
	    processNumber: processNumber,
	    processPercentage: processPercentage,
	    processUrl: processUrl,
	    processDate: processDate,
	    processHelp: processHelp,
	    processRadios: processRadios,
	    processRadiobuttons: processRadiobuttons,
	    processReusable: processReusable,
	    processSchema: processSchema,
	    processSelectDisplay: processSelectDisplay,
	    processResolve: processResolve,
	    processSection: processSection,
	    processSelect: processSelect,
	    processSchedule: processSchedule,
	    processTable: processTable,
	    processTemplate: processTemplate,
	    processToggle: processToggle,
	    processUpdatedSchema: processUpdatedSchema,
	    processMediaUpload: processMediaUpload,
	    processCsvUpload: processCsvUpload,
	    registerArrayHandlers: registerArrayHandlers,
	    registerHandler: registerHandler,
	    registerResolve: registerResolve,
	    replaceArrayIndex: replaceArrayIndex,
	    reprocessField: reprocessField,
	    resetUpdates: resetUpdates,
	    resolveNestedExpressions: resolveNestedExpressions,
	    setArrayIndex: setArrayIndex,
	    setupConfig: setupConfig,
	    setupSchemaRefresh: setupSchemaRefresh,
	    silenceListeners: silenceListeners,
	    skipDefaults: skipDefaults
	  };
	
	  function getService(fn) {
	    return _.find(services, fn);
	  }
	
	  function destroyService(fn) {
	    var service = getService(fn);
	    if (service) {
	      service.cleanup();
	      _.empty(service);
	      _.remove(services, function (s) {
	        return s === service;
	      });
	    }
	  }
	
	  function CNFlexFormConstructor() {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    if (args.length > 1) {
	      var schema = args[0],
	          model = args[1],
	          config = args[2];
	    } else {
	      var _args$ = args[0],
	          schema = _args$.schema,
	          model = _args$.model,
	          config = _args$.config;
	    }
	
	    var curService = getService(function (service) {
	      return service.model === model;
	    });
	    if (curService) {
	      if (schema) {
	        curService.compile(schema, model, config);
	      }
	      return curService;
	    }
	
	    var newService = new CNFlexForm(schema, model, config);
	    services.push(newService);
	    return newService;
	  }
	
	  function CNFlexForm(schema, model, config) {
	    if ($stateParams.debug) {
	      window.services = services;
	    }
	
	    this.arrayCopies = {};
	    this.arrayListeners = {};
	    this.dataCache = {};
	    this.defaults = {};
	    this.errors = [];
	    this.events = [];
	    this.formCache = {};
	    this.scopeCache = {};
	    this.listeners = {};
	    this.resolveRegister = {};
	    this.model = model;
	    this.updates = 0;
	    this.skipDefault = {};
	
	    var overrides = config.getParams ? config.getParams() : {};
	    this.params = cnFlexFormConfig.getStateParams(overrides);
	
	    this._ = _;
	
	    this.compile(schema, model, config);
	  }
	
	  _.extend(CNFlexForm.prototype, prototype);
	  _.extend(CNFlexFormConstructor, prototype, { getService: getService, destroyService: destroyService });
	
	  return CNFlexFormConstructor;
	
	  //////////////
	
	  function compile(schema, model, config) {
	    var service = this;
	
	    if (config && config.getScope) {
	      service.scope = config.getScope();
	    }
	    service.schema = schema;
	    service.model = model;
	
	    if (!service.isCompiled()) {
	      service.setupConfig(config);
	
	      if (schema.forms) {
	        _.each(schema.forms, function (form) {
	          _.each(form.form, service.processField.bind(service));
	        });
	      } else {
	        _.each(schema.form, service.processField.bind(service));
	      }
	
	      service.initModelWatch();
	      service.initArrayCopyWatch();
	      service.isCompiled(true);
	    }
	
	    service.broadcastErrors();
	  }
	
	  function isCompiled(setValue) {
	    var service = this;
	    if (setValue) {
	      service.schema.compiled = setValue;
	    }
	    return service.schema && service.schema.compiled;
	  }
	
	  function setupConfig(config) {
	    var service = this;
	    if (config) {
	      if (config.formCtrl) service.formCtrl = config.formCtrl;
	      if (config.updateSchema) service.updateSchema = config.updateSchema;
	      if (config.getSchema) service.getSchemaForm = service.setupSchemaRefresh(config.getSchema);
	    }
	    service.getParamOverrides = config.getParams || _.noop;
	  }
	
	  function processSchema(field) {
	    var service = this;
	    var schema = field.schema;
	
	
	    field.getSchemaType = function () {
	      return _.isArray(schema.type) ? _.first(schema.type) : schema.type;
	    };
	    if (!field.type) field.type = field.getSchemaType && field.getSchemaType();
	  }
	
	  function processDefault(field) {
	    var service = this;
	    var schema = field.schema;
	
	    var curDefault = field.default || schema.default;
	    var key = service.getKey(field.key);
	
	    if (service.skipDefault[key]) {
	      delete service.skipDefault[key];
	      return;
	    }
	
	    if (field.condition) {
	      var condition = replaceArrayIndex(field.condition, field.arrayIndex || key);
	      if (!service.parseCondition(condition)) return;
	    }
	
	    // if schemaUpdate hasn't been triggered, let schemaForm directive handle defaults
	    //if(service.updates || field.default) {
	    if (!_.isUndefined(curDefault)) {
	      if (key.includes && key.includes("[]")) return;
	      var model = service.parseExpression(field.key, service.model);
	      var modelValue = model.get();
	      // if there's an existing default and it's the same as the current value
	      // update the current value to the new default
	      if (_.isUndefined(modelValue) || (_.has(service.defaults, key) ? angular.equals(modelValue, service.defaults[key]) : _.isTrulyEmpty(modelValue)) && !angular.equals(modelValue, curDefault)) {
	        model.set(angular.copy(curDefault));
	      }
	    }
	    service.defaults[key] = angular.copy(curDefault);
	
	    if (schema.format === "url" && !field.validationMessage) {
	      if (!field.type) field.type = "cn-url";
	      field.validationMessage = "Must be a valid url (https://...)";
	    }
	  }
	
	  function processFieldset(fieldset) {
	    var service = this;
	
	    fieldset.type = "cn-fieldset";
	    fieldset.items.forEach(service.processField.bind(service));
	
	    if (_.has(fieldset, "pos") && fieldset.pos === 0) {
	      fieldset.htmlClass = (fieldset.htmlClass || "") + " borderless";
	    }
	    if (fieldset.collapsible) {
	      fieldset.toggleCollapse = function (fieldset) {
	        if (fieldset.collapsible) {
	          fieldset.collapsed = !fieldset.collapsed;
	        }
	      };
	
	      fieldset.render = !fieldset.collapsed;
	    } else {
	      fieldset.render = true;
	    }
	  }
	
	  function processFieldType(field, secondPass) {
	    var service = this;
	    var fieldType = cnFlexFormTypes.getFieldType(field);
	    var handler = fieldTypeHandlers[fieldType];
	    if (_.isString(handler)) {
	      service[handler](field, secondPass);
	    } else if (_.isFunction(handler)) {
	      handler.call(service, field, secondPass);
	    }
	  }
	
	  function getOgKeys(field) {
	    return _.reject(_.keys(field), function (key) {
	      return (/^key$|^htmlClass$|^_/.test(key)
	      );
	    });
	  }
	
	  function processField(field, pos) {
	    var service = this;
	
	    if (angular.isDefined(pos)) {
	      field.pos = pos;
	    }
	
	    if (!field._ogKeys) {
	      field._ogKeys = getOgKeys(field);
	    }
	
	    var key = service.getKey(field.key);
	
	    if (key) {
	      service.addToFormCache(field, key);
	      var schema = service.getSchema(key);
	
	      if (schema) {
	        field.schema = schema;
	        if (schema.description) field.description = schema.description;
	        if (schema.type === "array" && !("showClearAll" in field)) field.showClearAll = true;
	      }
	
	      service.processSchema(field);
	    }
	
	    service.processFieldProps(field);
	
	    if (key) {
	      (function (key) {
	        if (_.find(service.errors, { key: key })) {
	          service.errors = _.reject(service.errors, { key: key });
	          service.scope.$broadcast("schemaForm.error." + key, "serverValidation", true);
	          service.scope.$broadcast("schemaForm.error." + key, "schemaForm", true);
	        }
	      })(getDotKey(key));
	
	      if (field.error) {
	        service.errors.push(service.buildError(field));
	        if (_.isEmpty(field.ngModelOptions)) {
	          field.ngModelOptions = {
	            allowInvalid: true
	          };
	        } else {
	          field.ngModelOptions.allowInvalid = true;
	        }
	      }
	    }
	  }
	
	  function processFieldProps(field, secondPass) {
	    var service = this;
	    fieldPropHandlers.forEach(function (_ref) {
	      var prop = _ref.prop,
	          handler = _ref.handler;
	      return _.has(field, prop) && handler(field, service, secondPass);
	    });
	  }
	
	  function getKey(key) {
	    if (_.isArray(key)) {
	      key = _.reduce(key, function (total, next) {
	        return (/^(-?\d*)$/.test(next) ? total + "[" + next + "]" : total + "." + next
	        );
	      });
	    }
	    return key;
	  }
	
	  function getSchema(key, depth) {
	    var service = this;
	    if (!key) return;
	
	    key = ObjectPath.parse(service.getKey(key));
	    depth = depth || service.schema.schema.properties;
	    var first = void 0,
	        next = void 0;
	
	    while (key.length > 1) {
	      next = key[1];
	      if (/^-?\d*$/.test(next)) {
	        if (key.length === 2) {
	          depth = depth[key.shift()];
	        } else {
	          depth = depth[key.shift()].items.properties;
	          key.shift();
	        }
	      } else {
	        depth = depth[key.shift()].properties;
	      }
	    }
	
	    // if array item
	    first = key[0] || "items";
	
	    return depth[first];
	  }
	
	  function getDefault(field) {
	    var service = this;
	    field = field.key ? field : service.getFromFormCache(field);
	    return field && (angular.isDefined(field.default) ? field.default : field.schema && field.schema.default);
	  }
	
	  function getWatchables(exp) {
	    var watchables = [];
	    var nested = matchNestedExpression(exp);
	    var replaceStr = "";
	
	    while (nested) {
	      if (/^-?\d+$/.test(nested[1]) || /^("|').*("|')$/.test(nested[1])) {
	        replaceStr = nested[0];
	        exp = exp.replace(nested[0], "ff_replace_ff");
	      } else {
	        watchables.push(nested[1].replace(/ff_replace_ff/g, replaceStr));
	        replaceStr = "";
	        exp = exp.replace(nested[0], "");
	      }
	      nested = matchNestedExpression(exp);
	    }
	
	    return [].concat(watchables, [exp.replace(/ff_replace_ff/g, replaceStr)]);
	  }
	
	  function processResolve(field) {
	    var service = this;
	    var key = service.getKey(field.key);
	
	    _.each(field.resolve, function (dataProp, fieldProp) {
	      dataProp = replaceArrayIndex(dataProp, key || field.arrayIndex);
	      if (dataProp.includes("[arrayIndex]")) return;
	
	      service.handleResolve(field, fieldProp, dataProp, true);
	
	      getWatchables(dataProp).forEach(function (watchable) {
	        var _ref2 = watchable.match(/(schema\.data\.|model\.)(\S+)/) || [],
	            _ref3 = _slicedToArray(_ref2, 3),
	            base = _ref3[1],
	            exp = _ref3[2];
	
	        if (base) {
	          if (base === "schema.data.") {
	            service.registerResolve(field, fieldProp, exp, dataProp);
	          } else if (base === "model.") {
	            service.registerHandler(exp, function () {
	              service.handleResolve(field, fieldProp, dataProp);
	            });
	          }
	        }
	      });
	    });
	
	    return field;
	  }
	
	  function parseAny(exp, base) {
	    var service = this;
	    var result = void 0;
	    var eithers = exp.split(" || ");
	    var match = _.find(eithers, function (x) {
	      var v = service.parseExpression(x, base).get();
	      if (!_.isUndefined(v)) {
	        result = v;
	        return true;
	      }
	    });
	    return result;
	  }
	
	  function parseAll(exp, base) {
	    var service = this;
	    var all = exp.split(" && ");
	    var match = _.reduce(all, function (acc, x) {
	      var v = service.parseExpression(x, base).get();
	      if (!_.isUndefined(v)) {
	        acc.push(v);
	      }
	      return acc;
	    }, []);
	    return all.length === match.length ? _.last(match) : undefined;
	  }
	
	  function handleResolve(field, fieldProp, exp, skipPropHandlers) {
	    var service = this;
	    var data = exp.includes(" || ") ? service.parseAny(exp) : exp.includes(" && ") ? service.parseAll(exp) : service.parseExpression(exp).get();
	
	    if (data && data.cursor) {
	      field.loadMore = function () {
	        var dataProp = exp.match(/schema\.data\.(.+)/)[1];
	        service.refreshSchema("data:" + dataProp + ":" + data.cursor);
	      };
	    } else {
	      delete field.loadMore;
	    }
	
	    var val = data && data.data ? data.data : data;
	    var val1 = fieldProp === "condition" ? val + "" : val;
	    service.parseExpression(fieldProp, field).set(val1);
	
	    if (!skipPropHandlers) {
	      fieldPropHandlers.forEach(function (_ref4) {
	        var prop = _ref4.prop,
	            handler = _ref4.handler;
	        return prop === fieldProp && handler(field, service);
	      });
	    }
	  }
	
	  function registerResolve(field, fieldProp, dataProp, exp) {
	    var service = this;
	
	    var fieldKey = service.getKey(field.key);
	    service.resolveRegister[dataProp] = service.resolveRegister[dataProp] || {};
	
	    var register = service.resolveRegister[dataProp];
	    register[fieldKey] = register[fieldKey] || [];
	    register[fieldKey].push({ field: field, prop: fieldProp, exp: exp });
	  }
	
	  function processConditional(field) {
	    var service = this;
	    _.each(field.conditionals, function (condition, key) {
	      var handler = function handler(val, prev) {
	        field[key] = service.parseCondition(condition);
	        var scope = service.getFromScopeCache(service.getKey(field.key));
	        if (key === "required" && scope) {
	          service.scope.$broadcast("schemaFormValidate");
	        }
	      };
	      field.conditionals[key].match(/model\.([^\s]+)/g).map(function (path) {
	        return path.match(/model\.([^\s]+)/)[1];
	      }).forEach(function (key) {
	        service.registerHandler(key, handler);
	      });
	      handler();
	    });
	  }
	
	  function processFieldWatch(field) {
	    var service = this;
	    if (!field.watch) return;
	
	    var schema = field.schema;
	    field.watch = _.isArray(field.watch) ? field.watch : [field.watch];
	
	    _.each(field.watch, function (watch) {
	      if (watch.resolution) {
	        var condition = void 0;
	        if (_.isString(field.condition)) {
	          // if the condition isn't already wrapped in parens, wrap it
	          condition = /^\(.*\)$/.test(field.condition) ? field.condition : "(" + field.condition + ")";
	        }
	        if (_.isString(watch.condition)) {
	          condition = condition ? condition + " && " + watch.condition : watch.condition;
	        }
	        var resolution = watch.resolution;
	        var handler = void 0;
	
	        if (_.isFunction(resolution)) {
	          handler = function handler(cur, prev) {
	            if (!condition || service.parseCondition(condition)) {
	              resolution(cur, prev);
	            }
	          };
	        } else {
	          var adjustment = {};
	
	          adjustment.date = resolution.match(/\+ ?(\d+) (days|hours)/);
	
	          if (adjustment.date) {
	            adjustment.date = {
	              val: adjustment.date[1],
	              units: adjustment.date[2]
	            };
	            resolution = resolution.replace(adjustment.date.val, "").trim();
	          } else {
	            adjustment.math = resolution.match(/(\+|\-|\/|\*) ?(\S+)/);
	
	            if (adjustment.math) {
	              adjustment.operator = {
	                "+": "add",
	                "-": "subtract",
	                "*": "multiply",
	                "/": "divide"
	              }[adjustment.math[1]];
	
	              adjustment.adjuster = service.parseExpression(adjustment.math[2]);
	            }
	          }
	
	          resolution = resolution.match(/(\S+) ?= ?(\S+)/);
	
	          handler = function handler(val, prev, key, trigger) {
	            var curCondition = condition && replaceArrayIndex(condition, key);
	            if (_.isString(curCondition) && curCondition.includes("[arrayIndex]")) {
	              return console.error("arrayIndex could not be repalced from expression '" + curCondition + "'");
	            }
	            var updatePath = replaceArrayIndex(resolution[1], key);
	            var fromPath = replaceArrayIndex(resolution[2], key);
	
	            var update = service.parseExpression(updatePath);
	
	            // avoid loop where two watches keep triggering each other
	            if (trigger === update.path().key) return;
	            trigger = update.path().key;
	
	            var from = service.parseExpression(fromPath);
	
	            if (!condition || service.parseCondition(curCondition)) {
	              if (adjustment.date) {
	                update.set(moment(from.get()).add(adjustment.date.val, adjustment.date.units).toDate());
	              } else if (adjustment.math) {
	                //var result = _[adjustment.operator](from.get(), adjustment.adjuster.get());
	                //let result = eval(from.get() + adjustment.math[1] + adjustment.adjuster.get());
	                var result = $parse(from.get() + adjustment.math[1] + adjustment.adjuster.get())();
	                schema = schema || field.items && (field.items[0].schema || field.items[0].items && field.items[0].items[0].schema);
	                if (field.type === "cn-currency") {
	                  var p = schema && schema.format === "currency-dollars" ? 2 : 0;
	
	                  if (adjustment.math[1] === "*") {
	                    result = _.floor(result, p);
	                  } else if (adjustment.math[1] === "/") {
	                    result = _.ceil(result, p);
	                  } else {
	                    result = _.round(result, p);
	                  }
	                }
	                //service.listeners[update.path().key].prev = result;
	                if (service.listeners[trigger]) {
	                  service.listeners[trigger].trigger = key;
	                }
	                update.set(result || 0);
	              } else {
	                update.set(from.get());
	              }
	            }
	          };
	        }
	
	        service.registerHandler(field, handler, field.updateSchema, watch.initialize);
	      }
	    });
	  }
	
	  function parseCondition(condition) {
	    var service = this;
	    if (condition.startsWith("_")) {
	      var exp = /^_\.(.*?)\((.*?),[\s(]*(.*?)\)?\s*=>[{\s]*(?:return)?(.*?)\}?\)$/;
	
	      var _condition$match = condition.match(exp),
	          _condition$match2 = _slicedToArray(_condition$match, 5),
	          fn = _condition$match2[1],
	          list = _condition$match2[2],
	          predicateParams = _condition$match2[3],
	          predicateBody = _condition$match2[4];
	
	      return _[fn]($parse(list)(service), generatePredicate(predicateParams, predicateBody));
	    } else {
	      return $parse(condition)(service);
	    }
	  }
	
	  function generatePredicate(params, body) {
	    return function () {
	      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }
	
	      return $parse(body)(params.replace(/\s/g, "").split(",").reduce(function (acc, cur, i) {
	        acc[cur] = args[i];
	        return acc;
	      }, {}));
	    };
	  }
	
	  function processFieldUpdatedSchema(field) {
	    var service = this;
	    var key = service.getKey(field.key);
	    if (!service.updates && field.updateSchema && !service.schema.params[key]) {
	      // by this point defaults should be processed so we can get value directly from model
	      var curVal = service.parseExpression(key, service.model).get();
	      if (!_.isUndefined(curVal)) service.schema.params[key] = curVal;
	    }
	    service.registerHandler(field, null, field.updateSchema);
	  }
	
	  function registerHandler(key, handler, updateSchema, runHandler) {
	    var service = this;
	
	    // if field is passed instead of key
	    if (_.isObject(key) && !_.isArray(key)) {
	      if (!key.key && key.items) {
	        _.each(key.items, function (field) {
	          service.registerHandler(field, handler, field.updateSchema);
	        });
	        return;
	      } else {
	        key = key.key;
	      }
	    }
	
	    key = service.getKey(key);
	    var arrMatch = key.match(/(.*)\[]\.?(.*)/);
	
	    if (arrMatch) {
	      service.registerArrayHandlers(arrMatch[1], arrMatch[2], handler, updateSchema, runHandler);
	      return;
	    }
	
	    var cur = service.parseExpression(key, service.model).get();
	    var defaultValue = _.get(service.getSchema(key), "default");
	
	    if (!service.listeners[key]) {
	      var prev = angular.copy(cur);
	      service.listeners[key] = {
	        handlers: [],
	        updateSchema: updateSchema,
	        prev: prev
	      };
	    }
	
	    if (handler) {
	      service.listeners[key].handlers.push(handler);
	      if (runHandler) handler(cur, null, key);
	    }
	  }
	
	  function registerArrayHandlers(arrKey, fieldKey, handler, updateSchema, runHandler) {
	    var service = this;
	    var onArray = function onArray(cur, prev, reorder) {
	      if (!prev && prev !== 0 && (cur | 0) < 1) return;
	      var i, l, key;
	
	      if (prev > cur || reorder) {
	        var lastKey = fieldKey ? arrKey + "[" + (prev - 1) + "]." + fieldKey : arrKey + "[" + (prev - 1) + "]";
	
	        // only deregister handlers once each time an element is removed
	        if (service.listeners[lastKey]) {
	          for (i = 0, l = prev; i < l; i++) {
	            key = fieldKey ? arrKey + "[" + i + "]." + fieldKey : arrKey + "[" + i + "]";
	
	            service.deregisterHandlers(key);
	          }
	        }
	        for (i = 0, l = cur; i < l; i++) {
	          key = fieldKey ? arrKey + "[" + i + "]." + fieldKey : arrKey + "[" + i + "]";
	
	          service.registerHandler(key, handler, updateSchema);
	          //no need to call if just reregisering handlers
	          //if(runHandler) handler(null, null, key);
	        }
	      } else if (cur > (prev || 0)) {
	        for (i = prev | 0, l = cur; i < l; i++) {
	          key = fieldKey ? arrKey + "[" + i + "]." + fieldKey : arrKey + "[" + i + "]";
	
	          service.registerHandler(key, handler, updateSchema, runHandler);
	          //if(runHandler) handler(null, null, key);
	        }
	      }
	    };
	
	    var arrVal = service.parseExpression(arrKey, service.model).get();
	    _.each(arrVal, function (field, i) {
	      var key = fieldKey ? arrKey + "[" + i + "]." + fieldKey : arrKey + "[" + i + "]";
	
	      service.registerHandler(key, handler, updateSchema);
	      if (runHandler) handler(null, null, key);
	    });
	
	    var listenerKey = arrKey + ".length";
	    if (service.arrayListeners[listenerKey]) {
	      service.arrayListeners[listenerKey].handlers.push(onArray);
	    } else {
	      service.arrayListeners[listenerKey] = {
	        handlers: [onArray],
	        prev: arrVal ? arrVal.length : 0
	      };
	    }
	  }
	
	  function deregisterHandlers(key) {
	    var service = this;
	
	    key = service.getKey(key);
	
	    var arrMatch = key.match(/([^[\]]*)\[]\.?(.*)/);
	
	    if (arrMatch) {
	      service.deregisterArrayHandlers(arrMatch[1], arrMatch[2]);
	      return;
	    }
	
	    if (service.listeners[key]) service.listeners[key].handlers = [];
	    //if(service.listeners[key]) delete service.listeners[key];
	  }
	
	  function deregisterArrayHandlers(arrKey, fieldKey) {
	    var service = this;
	
	    service.parseExpression(arrKey, service.model).get().forEach(function (item, i) {
	      fieldKey ? service.deregisterHandlers(arrKey + "[" + i + "]." + fieldKey) : service.deregisterHandlers(arrKey + "[" + i + "]");
	    });
	  }
	
	  function initModelWatch() {
	    var service = this;
	    if (service.watching) return;
	    if (service.modelWatch) service.modelWatch();
	
	    service.modelWatch = service.scope.$watch(function () {
	      return service.model;
	    }, service.onModelWatch.bind(service), true);
	
	    service.initSchemaParams();
	    service.watching = true;
	    service.firstUpdate = true;
	  }
	
	  function onModelWatch(cur, prev) {
	    var service = this;
	    // we always run through the listeners on the first update because angular seems to mess up
	    // when the defaults are applied and uses the same object for both cur and prev
	    if (service.firstUpdate || !angular.equals(cur, prev)) {
	      service.firstUpdate = false;
	      cnUtil.cleanModel(service.model);
	
	      service.prevParams = angular.copy(service.params);
	
	      _.each(service.arrayListeners, function (listener, key) {
	        var val = service.parseExpression(key, service.model).get();
	        if (!angular.equals(val, listener.prev)) {
	          listener.handlers.forEach(function (handler) {
	            return handler(val, listener.prev);
	          });
	          listener.prev = angular.copy(val);
	        }
	      });
	
	      _.each(service.listeners, function (listener, key) {
	        if (listener) {
	          var val = service.parseExpression(key, service.model).get();
	          var isInitArray = angular.equals(val, []) && !listener.prev;
	          if (!angular.equals(val, listener.prev) && !isInitArray) {
	            listener.handlers.forEach(function (handler) {
	              handler(val, listener.prev, key, listener.trigger);
	            });
	            listener.trigger = null;
	            listener.prev = angular.copy(val);
	          }
	          if (listener.updateSchema && !angular.isUndefined(val) && !isInitArray && val !== null /* &&
	                                                                                                 !angular.equals(val, service.getDefault(key))*/
	          ) {
	              service.params[key] = val;
	            } else {
	            delete service.params[key];
	          }
	        }
	      });
	
	      if (!angular.equals(service.params, service.prevParams)) {
	        if (service.model.id && !service.updates && _.isEmpty(service.prevParams)) {
	          service.incrementUpdates();
	        } else {
	          if (_.isFunction(service.refreshSchema)) {
	            service.refreshSchema();
	          }
	        }
	      }
	    }
	  }
	
	  function initSchemaParams() {
	    var service = this;
	    _.each(service.listeners, function (listener, key) {
	      if (listener) {
	        var val = service.parseExpression(key, service.model).get();
	        if (listener.updateSchema && !angular.isUndefined(val) && val !== null) {
	          service.params[key] = val;
	        }
	      }
	    });
	  }
	
	  function stripIndexes(key) {
	    return key.replace(/\[\d+]/g, "[]");
	  }
	
	  function initArrayCopyWatch() {
	    var service = this;
	
	    service.events.push(service.scope.$on("schemaFormPropagateFormController", function (event, scope) {
	      var form = scope.form;
	
	      if (!form.key) {
	        form.cacheKey = form.type + "-" + _.uniqueId();
	      }
	      var key = form.cacheKey || service.getKey(form.key);
	
	      if (_.isNumber(scope.arrayIndex)) {
	        var genericKey = stripIndexes(key);
	        var index = scope.arrayIndex;
	        form.arrayIndex = index;
	
	        if (!service.getArrayCopy(genericKey, index)) {
	          service.processFieldProps(form, true);
	        }
	
	        if (!form.condition) form.condition = "true";
	        // else if (form.condition.includes("arrayIndex")) {
	        //   form.condition = service.replaceArrayIndex(form.condition, key);
	        // }
	
	        service.addArrayCopy(scope, genericKey, index);
	        scope.$emit("flexFormArrayCopyAdded", genericKey);
	      } else {
	        service.addToScopeCache(scope, key);
	      }
	    }));
	
	    service.events.push(service.scope.$on("schemaFormDeleteScope", function (event, scope, index) {
	      var key = service.getKey(scope.form.key);
	      var listener = service.listeners[key];
	      if (listener) listener.handlers = [];
	
	      service.deleteArrayCopiesFor(key, index);
	
	      if (scope.form.link) {
	        var list = service.parseExpression(scope.form.link, service.model).get();
	        list.splice(index, 1);
	        service.deleteArrayCopiesFor(scope.form.link, index);
	      }
	    }));
	  }
	
	  function addArrayCopy(form, key, index) {
	    var service = this;
	    if (!index || index < 0) index = 0;
	    if (!service.arrayCopies[key]) service.arrayCopies[key] = [];
	    service.arrayCopies[key][index] = form;
	    //service.arrayCopies[key].push(form);
	  }
	
	  function getArrayCopy(key, index) {
	    var service = this;
	    var copies = service.arrayCopies[key];
	    return copies && copies[index];
	  }
	
	  function getArrayCopies(key) {
	    var service = this;
	    return _.pluck(service.getArrayScopes(key), "form");
	  }
	
	  function getArrayCopiesFor(keyStart) {
	    var service = this;
	    keyStart += "[]";
	
	    return _.filter(service.arrayCopies, function (copy, key) {
	      return key.includes(keyStart);
	    });
	  }
	
	  function deleteArrayCopiesFor(key, index) {
	    var service = this;
	    var copies = service.getArrayCopiesFor(key);
	    _.each(copies, function (list) {
	      return list && list.splice(index, 1);
	    });
	  }
	
	  function getArrayScopes(key) {
	    var service = this;
	    return service.arrayCopies[key];
	  }
	
	  function addToScopeCache(scope, key) {
	    var service = this;
	    if (service.scopeCache[key]) {
	      console.warn("caching duplicate scope for", key);
	    }
	    return service.scopeCache[key] = scope;
	  }
	
	  function getFromScopeCache(key) {
	    var service = this;
	    return service.scopeCache[key];
	  }
	
	  function addToFormCache(field, key) {
	    var service = this;
	    key = key || service.getKey(field.key);
	    if (!service.getFromFormCache(key)) service.formCache[key] = field;
	  }
	
	  function getFromFormCache(key) {
	    var service = this;
	    return service.formCache[key];
	  }
	
	  function addToDataCache(key, modelValue) {
	    var service = this;
	
	    if (key) {
	      service.dataCache[key] = modelValue;
	    }
	  }
	
	  function getFromDataCache(key) {
	    var service = this;
	
	    return service.dataCache[key];
	  }
	
	  function matchIntStrIndex(exp) {
	    return exp.match(/\[(-?\d+|".*"|'.*')]/);
	  }
	
	  function matchNestedExpression(exp) {
	    var _ref5 = matchIntStrIndex(exp) || [],
	        _ref6 = _slicedToArray(_ref5, 1),
	        toReplace = _ref6[0];
	
	    var replaced = [];
	
	    while (toReplace) {
	      replaced.push(toReplace);
	      exp = exp.replace(toReplace, "ff_r" + (replaced.length - 1) + "_ff");
	
	      var _ref7 = matchIntStrIndex(exp) || [];
	
	      var _ref8 = _slicedToArray(_ref7, 1);
	
	      toReplace = _ref8[0];
	    }
	
	    var match = exp.match(/\[([^[\]]+)]([^[\]]*)/);
	
	    return match && replaced.length ? match.map(function (exp) {
	      var _ref9 = exp.match(/ff_r(\d+)_ff/) || [],
	          _ref10 = _slicedToArray(_ref9, 2),
	          toReplace = _ref10[0],
	          index = _ref10[1];
	
	      while (toReplace) {
	        exp = exp.replace(toReplace, replaced[index]);
	
	        var _ref11 = exp.match(/ff_r(\d+)_ff/) || [];
	
	        var _ref12 = _slicedToArray(_ref11, 2);
	
	        toReplace = _ref12[0];
	        index = _ref12[1];
	      }
	      return exp;
	    }) : match;
	  }
	
	  function resolveNestedExpressions(exp, depth) {
	    var service = this;
	
	    var _ref13 = matchNestedExpression(exp) || [],
	        _ref14 = _slicedToArray(_ref13, 2),
	        nested = _ref14[1];
	
	    while (nested) {
	      var parsed = service.parseExpression(nested, depth).get();
	      var keyVal = _.isUndefined(parsed) ? "" : _.isString(parsed) ? "\"" + parsed + "\"" : parsed;
	      exp = exp.replace("[" + nested + "]", "[" + keyVal + "]");
	
	      var _ref15 = matchNestedExpression(exp) || [];
	
	      var _ref16 = _slicedToArray(_ref15, 2);
	
	      nested = _ref16[1];
	    }
	
	    return exp;
	  }
	
	  function parseExpression(exp, depth) {
	    var service = this;
	
	    if (!_.isString(exp) && !_.isArray(exp)) {
	      return { get: function get() {
	          return exp;
	        } };
	    }
	
	    // if expression is specific value
	    if (/^(null|false|true|undefined|'[^\']*'|"[^\"]*"|-?[0-9.]+|\[]|\{})$/.test(exp)) {
	      return {
	        get: function get() {
	          if (!exp) return exp;
	          var isStr = exp.match(/"([^\"]*)"/) || exp.match(/'([^\']*)'/);
	          if (isStr) return isStr[1];
	          switch (exp) {
	            case "null":
	              return null;
	            case "false":
	              return false;
	            case "true":
	              return true;
	            case "undefined":
	              return;
	            case "[]":
	              return [];
	            case "{}":
	              return {};
	            default:
	              return parseFloat(exp);
	          }
	        }
	      };
	    }
	
	    exp = service.getKey(exp);
	
	    var match = exp.match(/^(model\.)?(\S+)$/);
	
	    var modelValue = {
	      get: function get() {
	        var resolved = service.resolveNestedExpressions(exp, depth);
	        var path = ObjectPath.parse(resolved);
	        var start = depth || service;
	
	        while (start && path.length > 1) {
	          start = start[path.shift()];
	        }
	
	        return start && start[path[0]];
	      },
	      getAssignable: function getAssignable() {
	        var _ref17 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	            noConstruction = _ref17.noConstruction;
	
	        var resolved = service.resolveNestedExpressions(exp, depth);
	        var path = ObjectPath.parse(resolved);
	        var progress = [];
	        var start = depth || service;
	
	        while (start && path.length > 1) {
	          var key = path.shift();
	          progress.push(key);
	          if (!start[key]) {
	            if (noConstruction) {
	              return null;
	            }
	            if (/^\d?$/.test(path[0])) {
	              start[key] = [];
	            } else {
	              start[key] = {};
	            }
	          }
	          start = start[key];
	        }
	
	        return {
	          obj: start,
	          key: path[0],
	          path: service.getKey(progress),
	          fullPath: service.getKey(progress.concat(path.slice(0, 1)))
	        };
	      },
	      set: function set(val) {
	        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	        var resolved = service.resolveNestedExpressions(exp, depth);
	        var path = ObjectPath.parse(resolved);
	        if (val === "remove") {
	          var _ref18 = this.getAssignable({ noConstruction: true }) || {},
	              obj = _ref18.obj,
	              key = _ref18.key;
	
	          delete service.defaults[resolved.replace("model.", "")];
	          if (obj) {
	            delete obj[key];
	          }
	        } else {
	          var _getAssignable = this.getAssignable(),
	              _obj = _getAssignable.obj,
	              _key3 = _getAssignable.key;
	
	          _obj[_key3] = val;
	        }
	        if (options.silent) {
	          service.silenceListeners(resolved, depth);
	          service.skipDefaults(resolved);
	        }
	        return val;
	      },
	      path: function path() {
	        return {
	          exp: exp,
	          depth: depth,
	          key: match[2]
	        };
	      }
	    };
	
	    return modelValue;
	  }
	
	  function silenceListeners(keyStart, depth) {
	    var service = this;
	    _.each(service.listeners, function (listener, key) {
	      if (key.indexOf(keyStart) === 0) {
	        listener.prev = angular.copy(service.parseExpression(key, depth).get());
	      }
	    });
	  }
	
	  function skipDefaults(keyStart) {
	    var service = this;
	    var index = keyStart.match(/\[\d*\]/) ? getArrayIndex(keyStart) : null;
	    var ks = stripIndexes(keyStart);
	    var keys = _.filter(_.keys(service.formCache), function (k) {
	      return k.startsWith(ks);
	    });
	    var skipKeys = [];
	    _.each(keys, function (key) {
	      var indexedKey = service.setArrayIndex(key, index);
	      var model = service.parseExpression(indexedKey, service.model).get();
	      if (_.isArray(model)) {
	        var childKeys = _.filter(_.keys(service.formCache), function (k) {
	          return k.startsWith(key);
	        });
	
	        var _loop = function _loop(i) {
	          _.each(childKeys, function (k) {
	            skipKeys.push(k);
	            var indexedChildKey = service.setArrayIndex(k, [index, i]);
	            service.skipDefault[indexedChildKey] = true;
	          });
	        };
	
	        for (var i = 0; i < model.length; i++) {
	          _loop(i);
	        }
	      } else if (!skipKeys.includes(key)) {
	        service.skipDefault[indexedKey] = true;
	      }
	    });
	  }
	
	  function processArray(array) {
	    var service = this;
	    var key = service.getKey(array.key);
	
	    array.sortOptions = {
	      update: function update(e, ui) {
	        var listener = service.arrayListeners[key + ".length"];
	        listener.handlers.forEach(function (handler) {
	          handler(listener.prev, listener.prev, true);
	        });
	      }
	    };
	
	    service.processSection(array);
	  }
	
	  function processSection(section, secondPass) {
	    var service = this;
	    // if we're here because a parent's scope was emitted,
	    // scope for this section will soon be emitted, so can skip
	    if (secondPass) return;
	    _.each(section.items, service.processField.bind(service));
	  }
	
	  function processComponent(component) {
	    var service = this;
	
	    component.type = "section";
	    component.htmlClass = "row";
	
	    var cols = 12 / _.reject(component.items, "hidden").length;
	
	    _.each(component.items, function (field, i) {
	      service.processField(field);
	      component.items[i] = {
	        type: "section",
	        htmlClass: "col-sm-" + cols,
	        items: [field]
	      };
	    });
	  }
	
	  function processCurrency(field) {
	    field.currencyFormat = {
	      "currency-dollars": "dollars",
	      "currency-microcents": "microcents",
	      currency: "cents"
	    }[field.schema.format];
	
	    field.type = "cn-currency";
	  }
	
	  function processNumber(field) {
	    field.type = "cn-number";
	  }
	
	  function processPercentage(field) {
	    field.type = "cn-percentage";
	  }
	
	  function processUrl(field) {
	    field.type = "cn-url";
	  }
	
	  function processReusable(field) {
	    var service = this;
	    field.type = "cn-reusable";
	    field.view = field.view || "new";
	    field.items.forEach(service.processField.bind(service));
	    field.items = [{
	      type: "section",
	      items: field.items,
	      condition: "!model." + service.getKey(field.key) + ".id"
	    }];
	  }
	
	  function processFacebookVideo(field) {
	    var service = this;
	    field.type = "cn-facebookvideo";
	    if (!field.resolve) {
	      field.resolve = {};
	      _.each(field.data, function (exp, prop) {
	        return field.resolve["data." + prop] = exp;
	      });
	    }
	    service.processResolve(field);
	  }
	
	  function processCreativeImage(field) {
	    var service = this;
	    field.type = "cn-creativeimage";
	    if (!field.resolve) {
	      field.resolve = {};
	      _.each(field.data, function (exp, prop) {
	        return field.resolve["data." + prop] = exp;
	      });
	    }
	    service.processResolve(field);
	  }
	
	  function processMediaUpload(field) {
	    var service = this;
	    field.type = "cn-mediaupload";
	    if (!field.resolve) {
	      field.resolve = {};
	      _.each(field.data, function (exp, prop) {
	        return field.resolve["data." + prop] = exp;
	      });
	    }
	    service.processResolve(field);
	  }
	
	  function processCsvUpload(field) {
	    var service = this;
	    field.type = "cn-csvupload";
	  }
	
	  function processRadios(field) {
	    field.type = "cn-radios";
	  }
	
	  function processRadiobuttons(radios) {
	    var service = this;
	    radios.type = "cn-radiobuttons";
	    if (radios.fullWidth) {
	      radios.btnClass = "col-sm-" + _.divide(12, radios.titleMap.length);
	    }
	  }
	
	  function processDate(date) {
	    var service = this;
	    date.type = "cn-datetimepicker";
	
	    if (date.schema.format === "time-minutes") {
	      date.maxView = "hour";
	      date.iconClass = "fa fa-clock-o";
	
	      date.modelFormatter = function (val) {
	        if (!val) return;
	
	        var m = moment(val);
	
	        return _.add(_.multiply(m.hours(), 60), m.minutes());
	      };
	
	      date.modelParser = function (val) {
	        if (!val) return;
	
	        var d = parseInt(val);
	        var hours = _.floor(d / 60);
	        var minutes = d % 60;
	
	        return moment().startOf("day").add("hours", hours).add("minutes", minutes);
	      };
	
	      date.viewFormatter = function (val) {
	        if (!val) return;
	
	        return date.modelParser(val).format(date.dateFormat);
	      };
	
	      date.viewParser = function (val) {
	        if (!val) return;
	
	        var match = val.match(/^(\d{1,2}):?(\d{1,2})? (a|p)/);
	        if (!match) return;
	
	        var hours = _.add(match[1] === "12" ? 0 : match[1], match[3] === "a" ? 0 : 12);
	        var minutes = match[2] || "00";
	
	        if (minutes.length === 1) minutes += "0";
	
	        return _.add(_.multiply(hours, 60), minutes);
	      };
	    }
	  }
	
	  function getSelectValProp(select) {
	    var isArray = select.getSchemaType() === "array";
	    return select.valueProperty || (isArray ? select.schema.items.type : select.schema.type) !== "object" && "value";
	  }
	
	  function getAllowedSelectValue(select, val, titleMap) {
	    titleMap = titleMap || select.getTitleMap();
	    var valProp = getSelectValProp(select);
	    var omitHashKey = valProp ? _.identity : _.partialRight(_.omit, "$$hashKey");
	    var findFn = valProp ? _.compose(_.partial(_.find, titleMap), _.partial(_.set, {}, valProp), omitHashKey) : _.compose(_.partial(_.find, titleMap), omitHashKey);
	    if (select.getSchemaType() === "array") {
	      if (!val || !_.isArray(val)) return;
	      return val.map(findFn).filter(function (x) {
	        return x !== undefined;
	      });
	    } else {
	      return findFn(val);
	    }
	  }
	
	  function processSchedule(field) {
	    field.startEmpty = true;
	    field.type = "cn-schedule";
	  }
	
	  function processSelect(select) {
	    var service = this;
	    var schema = select.schema;
	
	    if (select.titleMapResolve || select.titleMap) {
	      select.getTitleMap = function () {
	        return select.titleMap || service.schema.data[select.titleMapResolve];
	      };
	
	      select.onInit = function (val, form, event, setter) {
	        // make sure we use correct value
	        var modelValue = service.parseExpression(form.key, service.model);
	        if (event === "tag-init") {
	          var newVal = getAllowedSelectValue(select, modelValue.get());
	          if (newVal !== undefined) setter(newVal);
	        }
	      };
	    }
	
	    if (select.titleMapQuery) {
	      var queryParams = select.titleMapQuery.params;
	      var paramsKeys = _.keys(queryParams);
	      select.showClearAll = true;
	      select.showClearCache = !!select.titleMapQuery.params.refreshData;
	      select.singleQuery = select.minLookup === 0;
	      select.titleQuery = function (q, _ref19) {
	        var refreshData = _ref19.refreshData;
	
	        var params = _(paramsKeys).reduce(function (acc, key) {
	          if (key === "q") {
	            acc[queryParams[key]] = q;
	          } else if (key === "refreshData") {
	            if (refreshData) acc[queryParams[key]] = true;
	          } else {
	            var exp = service.replaceArrayIndex(queryParams[key], select.arrayIndex);
	            var val = null,
	                variables = exp.split("||");
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;
	
	            try {
	              for (var _iterator = variables[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                var _exp = _step.value;
	
	                val = service.parseExpression(_exp.trim()).get();
	                if (val) {
	                  break;
	                }
	              }
	            } catch (err) {
	              _didIteratorError = true;
	              _iteratorError = err;
	            } finally {
	              try {
	                if (!_iteratorNormalCompletion && _iterator.return) {
	                  _iterator.return();
	                }
	              } finally {
	                if (_didIteratorError) {
	                  throw _iteratorError;
	                }
	              }
	            }
	
	            acc[key] = val;
	          }
	          return acc;
	        }, {});
	        return Api.get({
	          url: select.titleMapQuery.url,
	          params: params
	        });
	      };
	
	      if (!_.isNumber(select.minLookup)) select.minLookup = paramsKeys.length ? 3 : 0;
	      if (!_.has(select, "skipFiltering")) select.skipFiltering = !!select.minLookup;
	
	      select.onInit = function (val, form, event, setter) {
	        if (event === "tag-init") {
	          setter(val);
	        }
	      };
	    }
	
	    if (!_.isNumber(select.minLookup)) select.minLookup = 0;
	
	    if (schema.items) {
	      var defaults = [];
	      _.each(schema.items.properties, function (schema, key) {
	        if (angular.isDefined(schema.default)) {
	          defaults.push({
	            key: key,
	            default: schema.default
	          });
	        }
	      });
	      if (defaults.length) {
	        select.onAdd = function (val, form, event) {
	          if (val.value && event === "tag-added") {
	            _.each(defaults, function (prop) {
	              if (!val.value[prop.key]) val.value[prop.key] = prop.default;
	            });
	          }
	        };
	      }
	    }
	
	    if (select.displayFormat) {
	      select.itemFormatter = service.processTemplate(select.displayFormat);
	    }
	
	    if (!select.type.includes("cn-autocomplete")) {
	      if (select.items) {
	        select.detailedList = true;
	
	        if (select.items[0].type !== "component") {
	          if (select.items.length > 1) {
	            _.each(select.items, function (i) {
	              return i.destroyStrategy = "retain";
	            });
	            select.items = [{
	              type: "component",
	              items: select.items
	            }];
	          }
	
	          service.processFieldset(select);
	        }
	
	        select.type = "cn-autocomplete-detailed";
	        select.destroyStrategy = "retain";
	      } else {
	        if (!select.selectionStyle) {
	          select.selectionStyle = select.key === "tags" ? "tags" : select.getSchemaType() === "array" && select.schema.maxItems !== 1 ? "list" : "select";
	        }
	        select.type = "cn-autocomplete";
	      }
	
	      if (select.titleMapResolve) {
	        service.scope.$on("cnFlexFormDiff:data", function (e, data) {
	          if (data[select.titleMapResolve]) {
	            var modelValue = service.parseExpression(select.key, service.model);
	            var val = modelValue.get();
	            if (val !== undefined) {
	              var valid = getAllowedSelectValue(select, val, data[select.titleMapResolve]);
	              if (valid === undefined || _.isArray(valid) && _.isEmpty(valid)) modelValue.set();
	            }
	          }
	        });
	      }
	
	      service.registerHandler(select.key, function (val) {
	        var form = service.formCtrl && service.formCtrl[service.getKey(select.key)];
	        if (form && form.$setDirty) form.$setDirty();
	      }, select.updateSchema);
	    }
	  }
	
	  function processToggle(toggle) {
	    toggle.type = "cn-toggle";
	  }
	
	  function processHelp(help) {
	    help.htmlClass = "help-block";
	  }
	
	  function processDisplay(display) {
	    var service = this;
	    display.type = "cn-display";
	    display.getDisplay = service.processTemplate(display.displayFormat, true);
	  }
	
	  function processTemplate(tpl, parseScope) {
	    var service = this;
	    //var processor = /<(\S+)[^>]*>.*<\/\1>/.test(tpl) ? $compile : $interpolate;
	    var processor = $interpolate;
	    return function (scope, arrayIndex) {
	      if (parseScope) {
	        if (angular.isDefined(arrayIndex)) {
	          scope = _.map(scope, function (key) {
	            return key === "arrayIndex" ? arrayIndex : key;
	          });
	        }
	        scope = service.parseExpression(scope, service.model).get();
	      }
	      return processor(tpl)(scope);
	    };
	  }
	
	  function processTable(table) {
	    var service = this;
	    table.type = "cn-table";
	    table.items.forEach(function (row) {
	      for (var i = 0; i < table.columns.length; i++) {
	        _.extend(row.items[i], table.columns[i]);
	        service.processField(row.items[i]);
	      }
	    });
	  }
	
	  function processSelectDisplay(selectDisplay) {
	    var service = this;
	    // Needed for batchform to check recursively
	    var selectField = null;
	    var _iteratorNormalCompletion2 = true;
	    var _didIteratorError2 = false;
	    var _iteratorError2 = undefined;
	
	    try {
	      for (var _iterator2 = selectDisplay.items[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	        var item = _step2.value;
	
	        if (item.selectField) {
	          selectField = item;
	        } else if (item.items) {
	          selectField = _.find(item.items, "selectField");
	        }
	        if (selectField) {
	          break;
	        }
	      }
	
	      // band-aid because this is being set as an object instead of array somwhere
	      // deep in the angular or angular-schema-form nether-regions
	    } catch (err) {
	      _didIteratorError2 = true;
	      _iteratorError2 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion2 && _iterator2.return) {
	          _iterator2.return();
	        }
	      } finally {
	        if (_didIteratorError2) {
	          throw _iteratorError2;
	        }
	      }
	    }
	
	    var linkModel = service.parseExpression(selectDisplay.link, service.model);
	    if (!linkModel.get()) linkModel.set([]);
	
	    _.each(selectDisplay.items, function (item) {
	      if (item.selectField === true) return;
	
	      var key = _.isArray(item.key) ? item.key : ObjectPath.parse(item.key);
	      var featureKey = _.last(key);
	
	      item.showFeature = function (index) {
	        var features = service.parseExpression("model." + selectDisplay.link + "[" + index + "].features").get();
	        var show = features && features.includes(featureKey);
	        return show;
	      };
	
	      var condition = "form.showFeature(arrayIndex)";
	      item.condition = item.condition ? "(" + item.condition + ") && " + condition : condition;
	    });
	    // handle legacy objects that don't have values set in the selectField
	    var model = service.parseExpression(service.getKey(selectDisplay.key), service.model).get();
	    var selectKey = service.getKey(selectField.key);
	    _.each(model, function (elem, i) {
	      var indexedSelectKey = service.setArrayIndex(selectKey, i);
	      var selectModel = service.parseExpression(indexedSelectKey, service.model);
	      if (!selectModel.get()) selectModel.set([]);
	    });
	  }
	
	  function setupSchemaRefresh(refresh) {
	    var service = this;
	    service.refreshSchema = _.debounce(function (updateSchema) {
	      var params = _extends({}, cnFlexFormConfig.getStateParams(service.getParamOverrides()), service.params);
	      var diff = _.omit(cnUtil.diff(service.schema.params, params, true), "updates");
	      var keys = void 0;
	
	      if (!_.isEmpty(diff) || updateSchema) {
	        if (updateSchema) params.updateSchema = updateSchema;else {
	          keys = _.keys(diff);
	
	          if (keys.length > 1) {
	            diff = _.omit(diff, _.isNull);
	            keys = _.keys(diff);
	          }
	
	          params.updateSchema = _.first(keys);
	        }
	
	        if (!params.updateSchema) {
	          diff = cnUtil.diff(params, _.omit(service.schema.params, ["updateSchema", "updates"]));
	          keys = _.keys(diff);
	
	          params.updateSchema = _.first(keys);
	        }
	
	        refresh(params).then(function (schema) {
	          service.processUpdatedSchema(schema);
	        });
	      }
	    }, 100);
	
	    service.refreshData = _.debounce(function () {
	      refresh(_.extend(service.schema.params, { updateSchema: "refreshData" })).then(function (schema) {
	        service.processUpdatedSchema(schema);
	      });
	    }, 100);
	
	    service.events.push(service.scope.$on("ffRefreshData", service.refreshData));
	  }
	
	  function processUpdatedSchema(schema) {
	    var service = this;
	    if (schema.diff) {
	      service.incrementUpdates();
	      service.schema.params = schema.params;
	      if (cnFlexFormConfig.onProcessDiff) {
	        cnFlexFormConfig.onProcessDiff(schema);
	      }
	
	      if (Object.keys(schema.diff.data).length > 0) {
	        service.scope.$broadcast("cnFlexFormDiff:data", schema.diff.data);
	        _.each(schema.diff.data, function (data, prop) {
	          if (data && data.data && !_.isEmpty(service.schema.data[prop].data) && !data.reset) {
	            data.data = service.schema.data[prop].data.concat(data.data);
	          }
	          service.schema.data[prop] = data;
	          if (service.resolveRegister[prop]) {
	            _.each(service.resolveRegister[prop], function (registers) {
	              registers.forEach(function (register) {
	                service.handleResolve(register.field, register.prop, register.exp);
	              });
	            });
	          }
	        });
	      }
	
	      var keys = [];
	
	      if (Object.keys(schema.diff.schema).length > 0) {
	        service.scope.$broadcast("cnFlexFormDiff:schema", schema.diff.schema);
	        _.each(schema.diff.schema, function (schema, key) {
	          reprocessSchema(schema, key, keys);
	          var curKeys = _.filter(keys, function (k) {
	            return _.startsWith(k, key);
	          });
	          _.each(curKeys, function (key) {
	            var forms = _.compact([service.getFromFormCache(key)].concat(_toConsumableArray(service.getArrayCopies(key) || [])));
	            _.each(forms, function (form) {
	              var prevSchema = form.schema;
	              var newSchema = service.getSchema(key, _defineProperty({}, schema.key, schema));
	              if (prevSchema.readonly && !newSchema.readonly) form.readonly = false;
	            });
	          });
	          service.schema.schema.properties[key] = schema;
	        });
	      }
	
	      if (Object.keys(schema.diff.form) > 0) {
	        service.scope.$broadcast("cnFlexFormDiff:form", schema.diff.form);
	        _.each(schema.diff.form, function (form, key) {
	          if (!keys.includes(key)) {
	            keys.push(key);
	          }
	
	          // don't want to override key when extending cached objects
	          //var key = form.key;
	          //delete form.key;
	
	          _.each(service.getFormsToProcess(key), function (copy) {
	            copy && service.reprocessField(copy, form);
	          });
	        });
	
	        var el = document.getElementsByClassName("cn-form")[0];
	        var oldScroll = el ? el.scrollTop : 0;
	
	        service.scope.$broadcast("schemaFormRedraw");
	
	        setTimeout(function () {
	          if (el) {
	            el.scrollTop = oldScroll;
	          }
	        }, 1000);
	      }
	
	      if (keys.length) {
	        _.each(keys, function (key) {
	          _.each(service.getFormsToProcess(key), function (copy) {
	            return copy && service.processField(copy);
	          });
	        });
	      }
	
	      service.broadcastErrors();
	    } else {
	      service.resetUpdates();
	      service.updateSchema(schema);
	    }
	  }
	
	  function getFormsToProcess(key) {
	    var service = this;
	
	    var _ref20 = key.match(/\[(\d)+]/) || [],
	        _ref21 = _slicedToArray(_ref20, 2),
	        arrayIndex = _ref21[1];
	
	    var copies = service.getArrayCopies(key.replace(/\[\d+]/g, "[]"));
	    if (_.isUndefined(arrayIndex)) {
	      var cached = service.getFromFormCache(key);
	      return [cached].concat(_toConsumableArray(copies));
	    }
	    return [copies[arrayIndex]];
	  }
	
	  function reprocessField(current, update, isChild) {
	    var service = this;
	    var key = service.getKey(current.key);
	
	    // other logic in the service will add conition = 'true' to force
	    // condition to eval true, so we set the update condition to 'true'
	    // before comparing
	    if (!update.condition && current.condition) update.condition = "true";
	    var redraw = !isChild && current.condition !== update.condition;
	
	    _.extend(current, _.omit(update, "items", "key"));
	
	    current._ogKeys.forEach(function (prop) {
	      if (!update[prop]) {
	        delete current[prop];
	      }
	    });
	    current._ogKeys = getOgKeys(update);
	
	    //service.deregisterHandlers(key);
	
	    service.scope.$broadcast("cnFlexFormReprocessField", key);
	
	    // why do we redraw? If we're doing it to show error message
	    // that has been addressed from the angular-schema-form library
	    // if there's another issue, try triggering the specific action required
	    // instead of redrawing the whole form
	    if (redraw && current.redraw) {
	      console.log("TODO: see if this can be removed");
	      current.redraw();
	    }
	  }
	
	  function reprocessSchema(schema, key, keys) {
	    keys.push(key);
	    if (schema.properties) {
	      _.each(schema.properties, function (schema, subKey) {
	        reprocessSchema(schema, key + "." + subKey, keys);
	      });
	    }
	    if (schema.items && schema.items.properties) {
	      _.each(schema.properties, function (schema, subKey) {
	        reprocessSchema(schema, key + "[]." + subKey, keys);
	      });
	    }
	  }
	
	  function getDotKey(key) {
	    return (_.isString(key) ? ObjectPath.parse(key) : key).join(".");
	  }
	
	  function buildError(field) {
	    return {
	      key: getDotKey(field.key),
	      message: field.error
	    };
	  }
	
	  function broadcastErrors() {
	    var service = this;
	    $timeout(function () {
	      if (_.get(service, "errors")) {
	        service.errors.forEach(function (error) {
	          service.scope.$broadcast("schemaForm.error." + error.key, "serverValidation", error.message);
	        });
	      }
	    }, 1);
	  }
	
	  function replaceArrayIndex(resolve, key) {
	    while (resolve.includes("arrayIndex")) {
	      if (_.isNumber(key)) return resolve.replace(/arrayIndex/g, key);
	      var arrayIndexKey = /([^.[]*)\[arrayIndex\]/.exec(resolve);
	      var re = new RegExp(arrayIndexKey[1] + "\\[(-?\\d+)\\]");
	      var index = re.exec(key);
	      if (!index) return resolve;
	      resolve = resolve.replace(new RegExp(arrayIndexKey[0].replace(/(\[|\])/g, "\\$1"), "g"), index[0]);
	    }
	    return resolve;
	  }
	
	  function getArrayIndex(key) {
	    if (_.isObject(key)) {
	      return _.find(key.key, function (key) {
	        return _.isNumber(key);
	      });
	    }
	    return (/\[(\d*)\]/.exec(key)[1]
	    );
	  }
	
	  function setArrayIndex(key, index, asArray) {
	    var service = this;
	    var keyCopy = void 0;
	    if (!_.isArray(index)) {
	      index = [index];
	    }
	    if (_.isString(key)) {
	      keyCopy = ObjectPath.parse(key);
	    } else {
	      keyCopy = _.clone(key);
	    }
	    while (index.length && keyCopy.indexOf("") > -1) {
	      var indexOfIndex = keyCopy.indexOf("");
	      keyCopy[indexOfIndex] = index.shift();
	    }
	    if (asArray) {
	      return keyCopy;
	    } else {
	      return service.getKey(keyCopy);
	    }
	  }
	
	  function cleanup() {
	    var service = this;
	    _.each(service.events, function (listener) {
	      listener();
	    });
	  }
	
	  function resetUpdates() {
	    var service = this;
	    service.updates = 0;
	    service.params.updates = service.updates;
	  }
	
	  function incrementUpdates() {
	    var service = this;
	    ++service.updates;
	    service.params.updates = service.updates;
	  }
	}
	
	//angular
	//.module('cn.flex-form')
	//.provider('cnFlexFormService', cnFlexFormServiceProvider);
	
	exports.default = cnFlexFormServiceProvider;

/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_6__;

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_7__;

/***/ },
/* 8 */
/***/ function(module, exports) {

	'use strict';
	
	cnFlexFormModalLoaderService.$inject = ["$stateParams", "$q"];
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var modalMap = {};
	var promiseMap = {};
	
	function getPromises(state) {
	  if (promiseMap[state]) return promiseMap[state];
	
	  var promise = {};
	  promiseMap[state] = promise;
	  return promise;
	}
	
	function getPromise(state, id, $q) {
	  var promises = getPromises(state);
	  if (promises[id]) return promises[id];
	
	  var promise = $q.defer();
	  promises[id] = promise;
	  return promise;
	}
	
	function cnFlexFormModalLoaderServiceProvider() {
	
	  parent.$inject = ["$stateParams", "$q"];
	  return {
	    addMapping: addMapping,
	    $get: cnFlexFormModalLoaderService
	  };
	
	  ////////////
	
	  function addMapping(state, def) {
	    def.resolve = { parent: parent };
	    modalMap[state] = def;
	  }
	
	  function parent($stateParams, $q) {
	    'ngInject';
	
	    return getPromise($stateParams.modal, $stateParams.modalId, $q).promise.then(function (_ref) {
	      var parent = _ref.parent;
	      return parent;
	    });
	  }
	}
	
	function cnFlexFormModalLoaderService($stateParams, $q) {
	  'ngInject';
	
	  return {
	    getMapping: getMapping,
	    resolveMapping: resolveMapping,
	    removeMapping: removeMapping
	  };
	
	  /////////////
	
	  function resolveMapping(state, id, parent) {
	    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
	    var scope = options.scope;
	
	    if (scope) {
	      scope.options = scope.options || {};
	      scope.options.destroyStrategy = 'retain';
	      modalMap[state].scope = scope;
	    }
	    var d = getPromise(state, id, $q);
	    d.resolve({ parent: parent, options: options });
	    return d.promise;
	  }
	
	  function getMapping(state) {
	    var d = $q.defer();
	    getPromise($stateParams.modal, $stateParams.modalId, $q).promise.then(function (_ref2) {
	      var parent = _ref2.parent,
	          options = _ref2.options;
	
	      d.resolve({ state: modalMap[state], options: options });
	      return parent;
	    });
	    return d.promise;
	  }
	
	  // Holding on to scope references creates memory leaks
	  function removeMapping(state) {
	    modalMap[state] = null;
	    promiseMap[state] = null;
	  }
	}
	
	exports.default = cnFlexFormModalLoaderServiceProvider;

/***/ },
/* 9 */
/***/ function(module, exports) {

	'use strict';
	
	FlexFormModalLoader.$inject = ["FlexFormModal", "$state", "$rootScope", "$stateParams", "$scope"];
	FlexFormModal.$inject = ["cnFlexFormModalLoaderService", "$uibModal", "$stateParams"];
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	function FlexFormModalLoader(FlexFormModal, $state, $rootScope, $stateParams, $scope) {
	  'ngInject';
	
	  function FFModalLoaderTag() {}
	  $scope.__tag = FFModalLoaderTag();
	
	  var vm = this;
	
	  activate();
	
	  //////////
	
	  function activate() {
	    FlexFormModal.open(vm).then(function (_ref) {
	      var modal = _ref.modal,
	          _ref$options = _ref.options,
	          onDismiss = _ref$options.onDismiss,
	          onAfterDismiss = _ref$options.onAfterDismiss;
	
	      vm.modal = modal;
	      vm.modal.result.finally(goBack);
	
	      if (onDismiss) vm.modal.result.catch(function () {
	        return onDismiss($stateParams.restParams);
	      });
	      vm.dismissEvent = $rootScope.$on('$stateChangeStart', dismissModal);
	    });
	  }
	
	  function goBack() {
	    if (!$state.transition) {
	      $state.go('^');
	    }
	  }
	
	  function dismissModal() {
	    // unbind event
	    vm.dismissEvent();
	    vm.modal.opened.then(function () {
	      return vm.modal.dismiss();
	    });
	  }
	}
	
	function FlexFormModal(cnFlexFormModalLoaderService, $uibModal, $stateParams) {
	  'ngInject';
	
	  return { open: open };
	
	  ////////////
	
	  function open() {
	    return cnFlexFormModalLoaderService.getMapping($stateParams.modal).then(function (_ref2) {
	      var state = _ref2.state,
	          options = _ref2.options;
	      return {
	        modal: $uibModal.open(state),
	        options: options
	      };
	    });
	  }
	}
	
	exports.FlexFormModalLoader = FlexFormModalLoader;
	exports.FlexFormModal = FlexFormModal;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	FlexForm.$inject = ["cnFlexFormService", "$scope", "$location"];
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	function cnFlexForm() {
	  return {
	    restrict: 'E',
	    template: '\n      <div ng-if="vm.showForm()">\n        <!-- we process defaults ourselves, hence setSchemaDefaults: false -->\n        <ng-form\n          class="clearfix"\n          name="{{vm.formName}}"\n          sf-options="{ setSchemaDefaults: false }"\n          sf-schema="vm.config.schema.schema"\n          sf-form="vm.form"\n          sf-model="vm.model">\n        </ng-form>\n        <!-- debug panel to display model -->\n        <section ng-if="vm.debug">\n          <json-explorer json-data="vm.model || \'...model not loaded yet\'"/>\n        </section>\n      </div>\n    ',
	    scope: {
	      config: '=ffConfig',
	      model: '=ffModel',
	      formIndex: '=ffFormIndex',
	      formName: '=ffFormName',
	      delayForm: '=ffDelayForm',
	      cleanupEvent: '=ffCleanupEvent'
	    },
	    controller: FlexForm,
	    controllerAs: 'vm',
	    bindToController: true
	  };
	}
	
	function FlexForm(cnFlexFormService, $scope, $location) {
	  'ngInject';
	
	  function cnFlexFormTag() {}
	  $scope.__tag = new cnFlexFormTag();
	
	  var vm = this;
	  vm.service = undefined;
	  vm.events = [];
	
	  vm.activate = activate;
	  vm.cleanup = cleanup;
	  vm.process = process;
	  vm.showForm = showForm;
	
	  vm.events.push($scope.$watch(function () {
	    return vm.config.schema;
	  }, vm.process));
	
	  vm.activate();
	
	  $scope.$on(vm.cleanupEvent || '$destroy', vm.cleanup);
	
	  //////////
	
	  function activate() {
	    if (angular.isNumber(vm.formIndex)) {
	      vm.form = vm.config.schema.forms[vm.formIndex].form;
	    } else {
	      vm.form = vm.config.schema.form;
	    }
	
	    // debug
	    if ($location.search().debug) {
	      vm.debug = true;
	    }
	  }
	
	  function process(cur, prev) {
	    if (vm.form) {
	      if (!vm.service) {
	        vm.service = cnFlexFormService(vm.config.schema, vm.model, {
	          getScope: vm.config.getScope || function () {
	            return $scope;
	          },
	          formCtrl: vm.config.formCtrl,
	          getSchema: vm.config.getSchema,
	          updateSchema: updateSchema
	        });
	      } else {
	        vm.service.compile(vm.config.schema, vm.model, vm.config);
	      }
	    }
	  }
	
	  function showForm() {
	    return !vm.delayForm && vm.service && vm.service.isCompiled();
	  }
	
	  function updateSchema(schema) {
	    vm.config.schema = schema;
	    vm.activate();
	  }
	
	  function cleanup() {
	    _.each(vm.events, function (listener) {
	      listener();
	    });
	
	    cnFlexFormService.destroyService(vm.service);
	  }
	}
	
	exports.default = cnFlexForm;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 11 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 12 */
/***/ function(module, exports) {

	'use strict';
	
	FlexFormHeader.$inject = ["$scope"];
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	function cnFlexFormHeader() {
	  return {
	    restrict: 'E',
	    scope: {
	      config: '=ffHeaderConfig',
	      submit: '&ffSubmit',
	      loadOffscreen: '&ffLoadOffscreen'
	    },
	    controller: FlexFormHeader,
	    bindToController: true,
	    controllerAs: 'vm',
	    template: '\n        <div class="col-md-6">\n          <h5 ng-if="vm.title.lead">{{::vm.title.lead}}</h5>\n          <h1>\n            <i ng-show="vm.title.icon" class="{{vm.title.icon}}"/>\n            {{vm.title.main}}\n          </h1>\n          <h5 ng-if="vm.title.sub">{{::vm.title.sub}}</h5>\n        </div>\n        <div class="{{vm.buttonContainerClass || \'page-action-btns\'}}">\n          <div class="btn-options"\n               ng-mouseover="vm.loadOffscreen()">\n            <a class="btn btn-{{vm.returnStyle ? vm.returnStyle : \'default-dark\'"\n               ng-if="vm.returnState"\n               ui-sref="{{vm.returnState}}">\n              {{vm.returnText || \'Cancel\'}}\n            </a>\n            <a class="btn btn-{{vm.closeButton.style ? vm.closeButton.style : \'default-dark\'}}"\n               ng-if="vm.closeButton"\n               ng-click="vm.closeButton.handler()">\n               Cancel\n            </a>\n            <span ng-repeat="button in vm.actions">\n              <span ng-class="{\'btn-group\': button.options}">\n                <a class="btn {{button.style ? \'btn-\'+button.style : ($index === vm.actions.length - 1 ? \'btn-primary\' : \'btn-default-dark\')}}"\n                   ng-disabled="vm.isDisabled(button)"\n                   ng-click="vm.isDisabled(button) || vm.submit({handler: button.handler})"\n                   uib-tooltip="{{button.helptext}}"\n                   uib-tooltip-placement="bottom"\n                   ng-bind-html="button.text || \'Save\'">\n                </a>\n                <a class="btn {{button.style ? \'btn-\'+button.style : ($index === vm.actions.length - 1 ? \'btn-primary\' : \'btn-default-dark\')}} dropdown-toggle"\n                        ng-disabled="vm.isDisabled(button)"\n                        ng-show="button.options"\n                        data-toggle="dropdown">\n                  <span class="caret"></span>\n                </a>\n                <ul class="dropdown-menu" ng-if="button.options">\n                  <li ng-repeat="option in button.options"\n                      ng-disabled="vm.isDisabled(option)">\n                    <a ng-click="vm.isDisabled(option) || vm.submit({handler: option.handler})"\n                       ng-bind-html="option.text">\n                    </a>\n                  </li>\n                </ul>\n              </span>\n            </span>\n          </div>\n          <p class="data-updated-at text-right"\n             id="data-updated-at"\n             ng-hide="vm.config.noData">\n            <a ng-click="vm.updateData()">Update Data</a>\n          </p>\n        </div>'
	  };
	}
	
	function FlexFormHeader($scope) {
	  'ngInject';
	
	  function ffHeaderTag() {}
	  $scope.__tag = new ffHeaderTag();
	
	  var vm = this;
	
	  vm.updateData = updateData;
	  vm.isDisabled = isDisabled;
	
	  //activate();
	  //$scope.$on('$destroy', cleanup);
	  $scope.$watch('vm.config.title', initTitle, true);
	  $scope.$watch('vm.config.actionConfig', initActionConfig, true);
	
	  ///////////
	
	  function initTitle() {
	    vm.title = vm.config.title;
	  }
	
	  function initActionConfig() {
	    var _ref = vm.config.actionConfig || {};
	
	    vm.returnState = _ref.returnState;
	    vm.returnStyle = _ref.returnStyle;
	    vm.returnText = _ref.returnText;
	    vm.closeButton = _ref.closeButton;
	    vm.actions = _ref.actions;
	  }
	
	  function updateData() {
	    // $scope.$emit('ffRefreshData');
	    // this component will often be siblings to the flex forms one,
	    // so need to broadcast from shared parent...yes it's ugly
	    $scope.$parent.$parent.$broadcast('ffRefreshData');
	  }
	
	  function isDisabled(btnConfig) {
	    if (vm.config.isDisabled) return vm.config.isDisabled(btnConfig);
	    return false;
	  }
	}
	
	exports.default = cnFlexFormHeader;

/***/ },
/* 13 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	function ffValidate() {
	  return {
	    restrict: 'A',
	    scope: { form: '=ffValidate' },
	    require: 'ngModel',
	    link: link
	  };
	}
	
	function link($scope, elem, attrs, ngModel) {
	  function ffValidateTag() {}
	  $scope.__tag = new ffValidateTag();
	
	  if ($scope.form && $scope.form.required) {
	    $scope.$watch(function () {
	      return ngModel.$viewValue;
	    }, function (value) {
	      // override schemaForm validation
	      ngModel.$setValidity('schemaForm', true);
	      ngModel.$setValidity('tv4-302', value);
	    });
	  }
	}
	
	exports.default = ffValidate;

/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBlYWZmN2FmNzViZjE3ZGZiZTI4ZSIsIndlYnBhY2s6Ly8vLi9zcmMvX2NuLWZsZXgtZm9ybS5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NuLWZsZXgtZm9ybS1jb25maWcuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY24tZmxleC1mb3JtLXR5cGVzLnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NuLWZsZXgtZm9ybS5yb3V0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjaGVtYS1mb3JtLWV4dGVuc2lvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NuLWZsZXgtZm9ybS5zZXJ2aWNlLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcImxvZGFzaFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcIm9iamVjdHBhdGhcIiIsIndlYnBhY2s6Ly8vLi9zcmMvY24tZmxleC1mb3JtLW1vZGFsLWxvYWRlci5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NyYy9jbi1mbGV4LWZvcm0tbW9kYWwtbG9hZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9jbi1mbGV4LWZvcm0uZGlyZWN0aXZlLmpzIiwid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9jbi1mbGV4LWZvcm0taGVhZGVyLmRpcmVjdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY24tZmxleC1mb3JtLXZhbGlkYXRlLmRpcmVjdGl2ZS5qcyJdLCJuYW1lcyI6WyJhbmd1bGFyIiwibW9kdWxlIiwicHJvdmlkZXIiLCJjb25maWciLCJydW4iLCJmYWN0b3J5IiwiY29udHJvbGxlciIsImRpcmVjdGl2ZSIsIm5hbWUiLCJjbkZsZXhGb3JtQ29uZmlnUHJvdmlkZXIiLCJpZ25vcmVQYXJhbXMiLCJhZGRJZ25vcmVQYXJhbSIsIiRnZXQiLCJjbkZsZXhGb3JtQ29uZmlnIiwicGFyYW0iLCJwdXNoIiwiJHN0YXRlUGFyYW1zIiwiZ2V0U3RhdGVQYXJhbXMiLCJvdmVycmlkZXMiLCJfIiwib21pdCIsImlzVW5kZWZpbmVkIiwidiIsInZhbHVlIiwiY25GbGV4Rm9ybVR5cGVzUHJvdmlkZXIiLCJmaWVsZFR5cGVSZWdpc3RlciIsImNvbmRpdGlvbiIsImZpZWxkIiwidHlwZSIsImluY2x1ZGVzIiwidGl0bGVNYXAiLCJ0aXRsZU1hcFJlc29sdmUiLCJ0aXRsZU1hcFF1ZXJ5Iiwic2NoZW1hIiwiZm9ybWF0IiwicmVnaXN0ZXJGaWVsZFR5cGUiLCJjbkZsZXhGb3JtVHlwZXMiLCJmaWVsZFR5cGUiLCJ1bnNoaWZ0IiwiZ2V0RmllbGRUeXBlIiwiaSIsImwiLCJsZW5ndGgiLCJjbkZsZXhGb3JtUm91dGVzUHJvdmlkZXIiLCIkc3RhdGVQcm92aWRlciIsImFkZFN0YXRlcyIsInBlcm1pc3Npb25zIiwic2hhcmVkIiwiY29udHJvbGxlckFzIiwic3RhdGUiLCJ1cmwiLCJjbkZsZXhGb3JtUm91dGVzIiwidGVtcGxhdGVVcmwiLCJzY2hlbWFGb3JtQ29uZmlnIiwiY25GbGV4Rm9ybVNlcnZpY2VQcm92aWRlciIsInR2NCIsImFkZEZvcm1hdCIsImlzU3RyaW5nIiwiZGF0YSIsInRlc3QiLCJleHRlbnNpb25zIiwiZWFjaCIsImV4dGVuc2lvbiIsInJlZ2lzdGVyRmllbGQiLCJhZGRUZW1wbGF0ZXMiLCIkdGVtcGxhdGVDYWNoZSIsInB1dCIsInNoYXJlZEF1dG9jb21wbGV0ZVRwbCIsIndpbmRvdyIsInJlcXVpcmUiLCJPYmplY3RQYXRoIiwiZmllbGRUeXBlSGFuZGxlcnMiLCJmaWVsZHNldCIsImhlbHAiLCJjb21wb25lbnQiLCJzZWN0aW9uIiwidGFiYXJyYXkiLCJhcnJheSIsImZpZWxkUHJvcEhhbmRsZXJzIiwicHJvcCIsImhhbmRsZXIiLCJzZXJ2aWNlIiwicHJvY2Vzc0RlZmF1bHQiLCJzZWNvbmRQYXNzIiwicHJvY2Vzc1Jlc29sdmUiLCJwcm9jZXNzU2VsZWN0RGlzcGxheSIsImRlZmF1bHQiLCJ3YXRjaCIsInByb2Nlc3NGaWVsZFdhdGNoIiwicHJvY2Vzc0ZpZWxkVHlwZSIsInByb2Nlc3NDb25kaXRpb25hbCIsInByb2Nlc3NGaWVsZFVwZGF0ZWRTY2hlbWEiLCJzY2hlbWFGb3JtRGVjb3JhdG9yc1Byb3ZpZGVyIiwiQ05GbGV4Rm9ybVNlcnZpY2UiLCJhZGRNYXBwaW5nIiwiY3JlYXRlRGlyZWN0aXZlIiwiQXBpIiwiJHBhcnNlIiwic2ZQYXRoIiwiJGludGVycG9sYXRlIiwiJHRpbWVvdXQiLCJjblV0aWwiLCJzZXJ2aWNlcyIsInByb3RvdHlwZSIsImNvbXBpbGUiLCJhZGRBcnJheUNvcHkiLCJhZGRUb0RhdGFDYWNoZSIsImFkZFRvRm9ybUNhY2hlIiwiYWRkVG9TY29wZUNhY2hlIiwiYnJvYWRjYXN0RXJyb3JzIiwiYnVpbGRFcnJvciIsImNsZWFudXAiLCJkZWxldGVBcnJheUNvcGllc0ZvciIsImRlcmVnaXN0ZXJIYW5kbGVycyIsImRlcmVnaXN0ZXJBcnJheUhhbmRsZXJzIiwiZ2V0QXJyYXlDb3B5IiwiZ2V0QXJyYXlDb3BpZXMiLCJnZXRBcnJheUNvcGllc0ZvciIsImdldEFycmF5U2NvcGVzIiwiZ2V0RGVmYXVsdCIsImdldEZyb21EYXRhQ2FjaGUiLCJnZXRGcm9tRm9ybUNhY2hlIiwiZ2V0RnJvbVNjb3BlQ2FjaGUiLCJnZXRGb3Jtc1RvUHJvY2VzcyIsImdldEtleSIsImdldFNjaGVtYSIsImdldFdhdGNoYWJsZXMiLCJoYW5kbGVSZXNvbHZlIiwiaW5jcmVtZW50VXBkYXRlcyIsImluaXRBcnJheUNvcHlXYXRjaCIsImluaXRNb2RlbFdhdGNoIiwiaW5pdFNjaGVtYVBhcmFtcyIsImlzQ29tcGlsZWQiLCJvbk1vZGVsV2F0Y2giLCJwYXJzZUFsbCIsInBhcnNlQW55IiwicGFyc2VDb25kaXRpb24iLCJwYXJzZUV4cHJlc3Npb24iLCJwcm9jZXNzQXJyYXkiLCJwcm9jZXNzQ3JlYXRpdmVJbWFnZSIsInByb2Nlc3NEaXNwbGF5IiwicHJvY2Vzc0ZhY2Vib29rVmlkZW8iLCJwcm9jZXNzRmllbGQiLCJwcm9jZXNzRmllbGRzZXQiLCJwcm9jZXNzRmllbGRQcm9wcyIsInByb2Nlc3NDb21wb25lbnQiLCJwcm9jZXNzQ3VycmVuY3kiLCJwcm9jZXNzTnVtYmVyIiwicHJvY2Vzc1BlcmNlbnRhZ2UiLCJwcm9jZXNzVXJsIiwicHJvY2Vzc0RhdGUiLCJwcm9jZXNzSGVscCIsInByb2Nlc3NSYWRpb3MiLCJwcm9jZXNzUmFkaW9idXR0b25zIiwicHJvY2Vzc1JldXNhYmxlIiwicHJvY2Vzc1NjaGVtYSIsInByb2Nlc3NTZWN0aW9uIiwicHJvY2Vzc1NlbGVjdCIsInByb2Nlc3NTY2hlZHVsZSIsInByb2Nlc3NUYWJsZSIsInByb2Nlc3NUZW1wbGF0ZSIsInByb2Nlc3NUb2dnbGUiLCJwcm9jZXNzVXBkYXRlZFNjaGVtYSIsInByb2Nlc3NNZWRpYVVwbG9hZCIsInByb2Nlc3NDc3ZVcGxvYWQiLCJyZWdpc3RlckFycmF5SGFuZGxlcnMiLCJyZWdpc3RlckhhbmRsZXIiLCJyZWdpc3RlclJlc29sdmUiLCJyZXBsYWNlQXJyYXlJbmRleCIsInJlcHJvY2Vzc0ZpZWxkIiwicmVzZXRVcGRhdGVzIiwicmVzb2x2ZU5lc3RlZEV4cHJlc3Npb25zIiwic2V0QXJyYXlJbmRleCIsInNldHVwQ29uZmlnIiwic2V0dXBTY2hlbWFSZWZyZXNoIiwic2lsZW5jZUxpc3RlbmVycyIsInNraXBEZWZhdWx0cyIsImdldFNlcnZpY2UiLCJmbiIsImZpbmQiLCJkZXN0cm95U2VydmljZSIsImVtcHR5IiwicmVtb3ZlIiwicyIsIkNORmxleEZvcm1Db25zdHJ1Y3RvciIsImFyZ3MiLCJtb2RlbCIsImN1clNlcnZpY2UiLCJuZXdTZXJ2aWNlIiwiQ05GbGV4Rm9ybSIsImRlYnVnIiwiYXJyYXlDb3BpZXMiLCJhcnJheUxpc3RlbmVycyIsImRhdGFDYWNoZSIsImRlZmF1bHRzIiwiZXJyb3JzIiwiZXZlbnRzIiwiZm9ybUNhY2hlIiwic2NvcGVDYWNoZSIsImxpc3RlbmVycyIsInJlc29sdmVSZWdpc3RlciIsInVwZGF0ZXMiLCJza2lwRGVmYXVsdCIsImdldFBhcmFtcyIsInBhcmFtcyIsImV4dGVuZCIsImdldFNjb3BlIiwic2NvcGUiLCJmb3JtcyIsImZvcm0iLCJiaW5kIiwic2V0VmFsdWUiLCJjb21waWxlZCIsImZvcm1DdHJsIiwidXBkYXRlU2NoZW1hIiwiZ2V0U2NoZW1hRm9ybSIsImdldFBhcmFtT3ZlcnJpZGVzIiwibm9vcCIsImdldFNjaGVtYVR5cGUiLCJpc0FycmF5IiwiZmlyc3QiLCJjdXJEZWZhdWx0Iiwia2V5IiwiYXJyYXlJbmRleCIsIm1vZGVsVmFsdWUiLCJnZXQiLCJoYXMiLCJlcXVhbHMiLCJpc1RydWx5RW1wdHkiLCJzZXQiLCJjb3B5IiwidmFsaWRhdGlvbk1lc3NhZ2UiLCJpdGVtcyIsImZvckVhY2giLCJwb3MiLCJodG1sQ2xhc3MiLCJjb2xsYXBzaWJsZSIsInRvZ2dsZUNvbGxhcHNlIiwiY29sbGFwc2VkIiwicmVuZGVyIiwiaXNGdW5jdGlvbiIsImNhbGwiLCJnZXRPZ0tleXMiLCJyZWplY3QiLCJrZXlzIiwiaXNEZWZpbmVkIiwiX29nS2V5cyIsImRlc2NyaXB0aW9uIiwic2hvd0NsZWFyQWxsIiwiJGJyb2FkY2FzdCIsImdldERvdEtleSIsImVycm9yIiwiaXNFbXB0eSIsIm5nTW9kZWxPcHRpb25zIiwiYWxsb3dJbnZhbGlkIiwicmVkdWNlIiwidG90YWwiLCJuZXh0IiwiZGVwdGgiLCJwYXJzZSIsInByb3BlcnRpZXMiLCJzaGlmdCIsImV4cCIsIndhdGNoYWJsZXMiLCJuZXN0ZWQiLCJtYXRjaE5lc3RlZEV4cHJlc3Npb24iLCJyZXBsYWNlU3RyIiwicmVwbGFjZSIsInJlc29sdmUiLCJkYXRhUHJvcCIsImZpZWxkUHJvcCIsIndhdGNoYWJsZSIsIm1hdGNoIiwiYmFzZSIsInJlc3VsdCIsImVpdGhlcnMiLCJzcGxpdCIsIngiLCJhbGwiLCJhY2MiLCJsYXN0IiwidW5kZWZpbmVkIiwic2tpcFByb3BIYW5kbGVycyIsImN1cnNvciIsImxvYWRNb3JlIiwicmVmcmVzaFNjaGVtYSIsInZhbCIsInZhbDEiLCJmaWVsZEtleSIsInJlZ2lzdGVyIiwiY29uZGl0aW9uYWxzIiwicHJldiIsIm1hcCIsInBhdGgiLCJyZXNvbHV0aW9uIiwiY3VyIiwiYWRqdXN0bWVudCIsImRhdGUiLCJ1bml0cyIsInRyaW0iLCJtYXRoIiwib3BlcmF0b3IiLCJhZGp1c3RlciIsInRyaWdnZXIiLCJjdXJDb25kaXRpb24iLCJjb25zb2xlIiwidXBkYXRlUGF0aCIsImZyb21QYXRoIiwidXBkYXRlIiwiZnJvbSIsIm1vbWVudCIsImFkZCIsInRvRGF0ZSIsInAiLCJmbG9vciIsImNlaWwiLCJyb3VuZCIsImluaXRpYWxpemUiLCJzdGFydHNXaXRoIiwibGlzdCIsInByZWRpY2F0ZVBhcmFtcyIsInByZWRpY2F0ZUJvZHkiLCJnZW5lcmF0ZVByZWRpY2F0ZSIsImJvZHkiLCJjdXJWYWwiLCJydW5IYW5kbGVyIiwiaXNPYmplY3QiLCJhcnJNYXRjaCIsImRlZmF1bHRWYWx1ZSIsImhhbmRsZXJzIiwiYXJyS2V5Iiwib25BcnJheSIsInJlb3JkZXIiLCJsYXN0S2V5IiwiYXJyVmFsIiwibGlzdGVuZXJLZXkiLCJpdGVtIiwid2F0Y2hpbmciLCJtb2RlbFdhdGNoIiwiJHdhdGNoIiwiZmlyc3RVcGRhdGUiLCJjbGVhbk1vZGVsIiwicHJldlBhcmFtcyIsImxpc3RlbmVyIiwiaXNJbml0QXJyYXkiLCJpZCIsInN0cmlwSW5kZXhlcyIsIiRvbiIsImV2ZW50IiwiY2FjaGVLZXkiLCJ1bmlxdWVJZCIsImlzTnVtYmVyIiwiZ2VuZXJpY0tleSIsImluZGV4IiwiJGVtaXQiLCJsaW5rIiwic3BsaWNlIiwiY29waWVzIiwicGx1Y2siLCJrZXlTdGFydCIsImZpbHRlciIsIndhcm4iLCJtYXRjaEludFN0ckluZGV4IiwidG9SZXBsYWNlIiwicmVwbGFjZWQiLCJwYXJzZWQiLCJrZXlWYWwiLCJpc1N0ciIsInBhcnNlRmxvYXQiLCJyZXNvbHZlZCIsInN0YXJ0IiwiZ2V0QXNzaWduYWJsZSIsIm5vQ29uc3RydWN0aW9uIiwicHJvZ3Jlc3MiLCJvYmoiLCJmdWxsUGF0aCIsImNvbmNhdCIsInNsaWNlIiwib3B0aW9ucyIsInNpbGVudCIsImluZGV4T2YiLCJnZXRBcnJheUluZGV4Iiwia3MiLCJrIiwic2tpcEtleXMiLCJpbmRleGVkS2V5IiwiY2hpbGRLZXlzIiwiaW5kZXhlZENoaWxkS2V5Iiwic29ydE9wdGlvbnMiLCJlIiwidWkiLCJjb2xzIiwiY3VycmVuY3lGb3JtYXQiLCJjdXJyZW5jeSIsInZpZXciLCJyYWRpb3MiLCJmdWxsV2lkdGgiLCJidG5DbGFzcyIsImRpdmlkZSIsIm1heFZpZXciLCJpY29uQ2xhc3MiLCJtb2RlbEZvcm1hdHRlciIsIm0iLCJtdWx0aXBseSIsImhvdXJzIiwibWludXRlcyIsIm1vZGVsUGFyc2VyIiwiZCIsInBhcnNlSW50Iiwic3RhcnRPZiIsInZpZXdGb3JtYXR0ZXIiLCJkYXRlRm9ybWF0Iiwidmlld1BhcnNlciIsImdldFNlbGVjdFZhbFByb3AiLCJzZWxlY3QiLCJ2YWx1ZVByb3BlcnR5IiwiZ2V0QWxsb3dlZFNlbGVjdFZhbHVlIiwiZ2V0VGl0bGVNYXAiLCJ2YWxQcm9wIiwib21pdEhhc2hLZXkiLCJpZGVudGl0eSIsInBhcnRpYWxSaWdodCIsImZpbmRGbiIsImNvbXBvc2UiLCJwYXJ0aWFsIiwic3RhcnRFbXB0eSIsIm9uSW5pdCIsInNldHRlciIsIm5ld1ZhbCIsInF1ZXJ5UGFyYW1zIiwicGFyYW1zS2V5cyIsInNob3dDbGVhckNhY2hlIiwicmVmcmVzaERhdGEiLCJzaW5nbGVRdWVyeSIsIm1pbkxvb2t1cCIsInRpdGxlUXVlcnkiLCJxIiwidmFyaWFibGVzIiwic2tpcEZpbHRlcmluZyIsIm9uQWRkIiwiZGlzcGxheUZvcm1hdCIsIml0ZW1Gb3JtYXR0ZXIiLCJkZXRhaWxlZExpc3QiLCJkZXN0cm95U3RyYXRlZ3kiLCJzZWxlY3Rpb25TdHlsZSIsIm1heEl0ZW1zIiwidmFsaWQiLCIkc2V0RGlydHkiLCJ0b2dnbGUiLCJkaXNwbGF5IiwiZ2V0RGlzcGxheSIsInRwbCIsInBhcnNlU2NvcGUiLCJwcm9jZXNzb3IiLCJ0YWJsZSIsInJvdyIsImNvbHVtbnMiLCJzZWxlY3REaXNwbGF5Iiwic2VsZWN0RmllbGQiLCJsaW5rTW9kZWwiLCJmZWF0dXJlS2V5Iiwic2hvd0ZlYXR1cmUiLCJmZWF0dXJlcyIsInNob3ciLCJzZWxlY3RLZXkiLCJlbGVtIiwiaW5kZXhlZFNlbGVjdEtleSIsInNlbGVjdE1vZGVsIiwicmVmcmVzaCIsImRlYm91bmNlIiwiZGlmZiIsImlzTnVsbCIsInRoZW4iLCJvblByb2Nlc3NEaWZmIiwiT2JqZWN0IiwicmVzZXQiLCJyZWdpc3RlcnMiLCJyZXByb2Nlc3NTY2hlbWEiLCJjdXJLZXlzIiwiY29tcGFjdCIsInByZXZTY2hlbWEiLCJuZXdTY2hlbWEiLCJyZWFkb25seSIsImVsIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwib2xkU2Nyb2xsIiwic2Nyb2xsVG9wIiwic2V0VGltZW91dCIsImNhY2hlZCIsImN1cnJlbnQiLCJpc0NoaWxkIiwicmVkcmF3IiwibG9nIiwic3ViS2V5Iiwiam9pbiIsIm1lc3NhZ2UiLCJhcnJheUluZGV4S2V5IiwiZXhlYyIsInJlIiwiUmVnRXhwIiwiYXNBcnJheSIsImtleUNvcHkiLCJjbG9uZSIsImluZGV4T2ZJbmRleCIsIm1vZGFsTWFwIiwicHJvbWlzZU1hcCIsImdldFByb21pc2VzIiwicHJvbWlzZSIsImdldFByb21pc2UiLCIkcSIsInByb21pc2VzIiwiZGVmZXIiLCJjbkZsZXhGb3JtTW9kYWxMb2FkZXJTZXJ2aWNlUHJvdmlkZXIiLCJjbkZsZXhGb3JtTW9kYWxMb2FkZXJTZXJ2aWNlIiwiZGVmIiwicGFyZW50IiwibW9kYWwiLCJtb2RhbElkIiwiZ2V0TWFwcGluZyIsInJlc29sdmVNYXBwaW5nIiwicmVtb3ZlTWFwcGluZyIsIkZsZXhGb3JtTW9kYWxMb2FkZXIiLCJGbGV4Rm9ybU1vZGFsIiwiJHN0YXRlIiwiJHJvb3RTY29wZSIsIiRzY29wZSIsIkZGTW9kYWxMb2FkZXJUYWciLCJfX3RhZyIsInZtIiwiYWN0aXZhdGUiLCJvcGVuIiwib25EaXNtaXNzIiwib25BZnRlckRpc21pc3MiLCJmaW5hbGx5IiwiZ29CYWNrIiwiY2F0Y2giLCJyZXN0UGFyYW1zIiwiZGlzbWlzc0V2ZW50IiwiZGlzbWlzc01vZGFsIiwidHJhbnNpdGlvbiIsImdvIiwib3BlbmVkIiwiZGlzbWlzcyIsIiR1aWJNb2RhbCIsImNuRmxleEZvcm0iLCJyZXN0cmljdCIsInRlbXBsYXRlIiwiZm9ybUluZGV4IiwiZm9ybU5hbWUiLCJkZWxheUZvcm0iLCJjbGVhbnVwRXZlbnQiLCJGbGV4Rm9ybSIsImJpbmRUb0NvbnRyb2xsZXIiLCJjbkZsZXhGb3JtU2VydmljZSIsIiRsb2NhdGlvbiIsImNuRmxleEZvcm1UYWciLCJwcm9jZXNzIiwic2hvd0Zvcm0iLCJzZWFyY2giLCJjbkZsZXhGb3JtSGVhZGVyIiwic3VibWl0IiwibG9hZE9mZnNjcmVlbiIsIkZsZXhGb3JtSGVhZGVyIiwiZmZIZWFkZXJUYWciLCJ1cGRhdGVEYXRhIiwiaXNEaXNhYmxlZCIsImluaXRUaXRsZSIsImluaXRBY3Rpb25Db25maWciLCJ0aXRsZSIsImFjdGlvbkNvbmZpZyIsInJldHVyblN0YXRlIiwicmV0dXJuU3R5bGUiLCJyZXR1cm5UZXh0IiwiY2xvc2VCdXR0b24iLCJhY3Rpb25zIiwiJHBhcmVudCIsImJ0bkNvbmZpZyIsImZmVmFsaWRhdGUiLCJhdHRycyIsIm5nTW9kZWwiLCJmZlZhbGlkYXRlVGFnIiwicmVxdWlyZWQiLCIkdmlld1ZhbHVlIiwiJHNldFZhbGlkaXR5Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztBQ1ZBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OzttQkFFZUEsUUFDWkMsTUFEWSxDQUNMLGNBREssRUFDVyxDQUN0QixXQURzQixFQUV0QixZQUZzQixFQUd0Qiw2QkFIc0IsRUFJdEIsYUFKc0IsRUFLdEIsU0FMc0IsQ0FEWCxFQVFaQyxRQVJZLENBUUgsa0JBUkcsOEJBU1pBLFFBVFksQ0FTSCxpQkFURyw2QkFVWkEsUUFWWSxDQVVILGtCQVZHLHdDQVdaQyxNQVhZLCtCQVlaQSxNQVpZLHlDQWFaQyxHQWJZLHFDQWNaRixRQWRZLENBY0gsbUJBZEcsd0JBZVpBLFFBZlksQ0FlSCw4QkFmRyxtQ0FnQlpHLE9BaEJZLENBZ0JKLGVBaEJJLHlDQWlCWkMsVUFqQlksQ0FpQkQscUJBakJDLCtDQWtCWkMsU0FsQlksQ0FrQkYsWUFsQkUsd0JBbUJaQSxTQW5CWSxDQW1CRixrQkFuQkUsOEJBb0JaQSxTQXBCWSxDQW9CRixZQXBCRSxnQ0FxQlpDLEk7Ozs7OztBQ2hDSDs7QUFFQSxRQUFPLGVBQWUsU0FBUyxjQUFjO0dBQzNDLE9BQU87OztBQUdULEtBQUksV0FBVyxPQUFPLFVBQVUsVUFBVSxRQUFRLEVBQUUsS0FBSyxJQUFJLElBQUksR0FBRyxJQUFJLFVBQVUsUUFBUSxLQUFLLEVBQUUsSUFBSSxTQUFTLFVBQVUsSUFBSSxLQUFLLElBQUksT0FBTyxRQUFRLEVBQUUsSUFBSSxPQUFPLFVBQVUsZUFBZSxLQUFLLFFBQVEsTUFBTSxFQUFFLE9BQU8sT0FBTyxPQUFPLFlBQVksT0FBTzs7QUFOdlAsVUFBU0MsMkJBQTJCOzs7R0FFbEMsSUFBTUMsZUFBZSxDQUFDLFFBQVEsU0FBUyxXQUFXLFNBQVM7O0dBRTNELE9BQU87S0FDTEM7S0FDQUMsTUFBTUM7Ozs7O0dBS1IsU0FBU0YsZUFBZUcsT0FBTztLQUM3QkosYUFBYUssS0FBS0Q7OztHQUdwQixTQUFTRCxpQkFBaUJHLGNBQWM7S0FDdEM7O0tBRUEsT0FBTztPQUNMQztPQUNBUDs7Ozs7S0FLRixTQUFTTyxpQkFBK0I7T0FBQSxJQUFoQkMsWUFBZ0Isb0VBQUo7O09BQ2xDLE9BQ0VDLGVBQU9ILGNBQWlCRSxZQUN2QkUsS0FBS1YsY0FDTFUsS0FBSztTQUFBLE9BQU1ELEVBQUVFLFlBQVlDLE1BQU1BLE1BQU07VUFDckNDOzs7Ozs7Ozs7QUFpQlQsU0FBUSxVQU5PZCx5Qjs7Ozs7Ozs7Ozs7QUN6Q2YsVUFBU2UsdUJBQVQsR0FBbUM7O0FBRWpDLE9BQUlDLG9CQUFvQixDQUFDO0FBQ3ZCQyxnQkFBVztBQUFBLGNBQVNDLE1BQU1DLElBQU4sS0FBZSxRQUF4QjtBQUFBLE1BRFk7QUFFdkJBLFdBQU07QUFGaUIsSUFBRCxFQUdyQjtBQUNERixnQkFBVztBQUFBLGNBQVNDLE1BQU1DLElBQU4sQ0FBV0MsUUFBWCxDQUFvQixRQUFwQixDQUFUO0FBQUEsTUFEVjtBQUVERCxXQUFNO0FBRkwsSUFIcUIsRUFNckI7QUFDREYsZ0JBQVc7QUFBQSxjQUFTQyxNQUFNQyxJQUFOLENBQVdDLFFBQVgsQ0FBb0IsY0FBcEIsQ0FBVDtBQUFBLE1BRFY7QUFFREQsV0FBTTtBQUZMLElBTnFCLEVBU3JCO0FBQ0RGLGdCQUFXO0FBQUEsY0FBU0MsTUFBTUMsSUFBTixDQUFXQyxRQUFYLENBQW9CLGNBQXBCLEtBQXVDRixNQUFNRyxRQUE3QyxJQUF5REgsTUFBTUksZUFBL0QsSUFBa0ZKLE1BQU1LLGFBQWpHO0FBQUEsTUFEVjtBQUVESixXQUFNO0FBRkwsSUFUcUIsRUFZckI7QUFDREYsZ0JBQVc7QUFBQSxjQUFTQyxNQUFNQyxJQUFOLEtBQWUsbUJBQWYsSUFBc0NELE1BQU1DLElBQU4sS0FBZSxnQkFBckQsSUFBeUVELE1BQU1DLElBQU4sS0FBZSxjQUFqRztBQUFBLE1BRFY7QUFFREEsV0FBTTtBQUZMLElBWnFCLEVBZXJCO0FBQ0RGLGdCQUFXO0FBQUEsY0FBU0MsTUFBTUMsSUFBTixLQUFlLE1BQXhCO0FBQUEsTUFEVjtBQUVEQSxXQUFNO0FBRkwsSUFmcUIsRUFrQnJCO0FBQ0RGLGdCQUFXO0FBQUEsY0FBU0MsTUFBTUMsSUFBTixDQUFXQyxRQUFYLENBQW9CLFNBQXBCLENBQVQ7QUFBQSxNQURWO0FBRURELFdBQU07QUFGTCxJQWxCcUIsRUFxQnJCO0FBQ0RGLGdCQUFXO0FBQUEsY0FBU0MsTUFBTU0sTUFBTixJQUFnQk4sTUFBTU0sTUFBTixDQUFhQyxNQUE3QixJQUF1Q1AsTUFBTU0sTUFBTixDQUFhQyxNQUFiLENBQW9CTCxRQUFwQixDQUE2QixVQUE3QixDQUFoRDtBQUFBLE1BRFY7QUFFREQsV0FBTTtBQUZMLElBckJxQixFQXdCckI7QUFDREYsZ0JBQVc7QUFBQSxjQUFTQyxNQUFNTSxNQUFOLElBQWdCTixNQUFNTSxNQUFOLENBQWFDLE1BQWIsS0FBd0IsWUFBakQ7QUFBQSxNQURWO0FBRUROLFdBQU07QUFGTCxJQXhCcUIsRUEyQnJCO0FBQ0RGLGdCQUFXO0FBQUEsY0FBU0MsTUFBTU0sTUFBTixJQUFnQk4sTUFBTUMsSUFBTixLQUFlLEtBQXhDO0FBQUEsTUFEVjtBQUVEQSxXQUFNO0FBRkwsSUEzQnFCLEVBOEJyQjtBQUNERixnQkFBVztBQUFBLGNBQVNDLE1BQU1DLElBQU4sS0FBZSxRQUFmLElBQTJCRCxNQUFNQyxJQUFOLEtBQWUsU0FBbkQ7QUFBQSxNQURWO0FBRURBLFdBQU07QUFGTCxJQTlCcUIsRUFpQ3JCO0FBQ0RGLGdCQUFXO0FBQUEsY0FBU0MsTUFBTUMsSUFBTixLQUFlLGVBQXhCO0FBQUEsTUFEVjtBQUVEQSxXQUFNO0FBRkwsSUFqQ3FCLEVBb0NyQjtBQUNERixnQkFBVztBQUFBLGNBQVNDLE1BQU1DLElBQU4sS0FBZSxlQUF4QjtBQUFBLE1BRFY7QUFFREEsV0FBTTtBQUZMLElBcENxQixFQXVDckI7QUFDREYsZ0JBQVc7QUFBQSxjQUFTQyxNQUFNQyxJQUFOLEtBQWUsYUFBeEI7QUFBQSxNQURWO0FBRURBLFdBQU07QUFGTCxJQXZDcUIsRUEwQ3JCO0FBQ0RGLGdCQUFXO0FBQUEsY0FBU0MsTUFBTUMsSUFBTixLQUFlLFdBQXhCO0FBQUEsTUFEVjtBQUVEQSxXQUFNO0FBRkwsSUExQ3FCLEVBNkNyQjtBQUNERixnQkFBVztBQUFBLGNBQVNDLE1BQU1DLElBQU4sS0FBZSxVQUF4QjtBQUFBLE1BRFY7QUFFREEsV0FBTTtBQUZMLElBN0NxQixFQWdEckI7QUFDREYsZ0JBQVc7QUFBQSxjQUFTQyxNQUFNQyxJQUFOLEtBQWUsT0FBeEI7QUFBQSxNQURWO0FBRURBLFdBQU07QUFGTCxJQWhEcUIsRUFtRHJCO0FBQ0RGLGdCQUFXO0FBQUEsY0FBU0MsTUFBTUMsSUFBTixLQUFlLE9BQXhCO0FBQUEsTUFEVjtBQUVEQSxXQUFNO0FBRkwsSUFuRHFCLEVBc0RyQjtBQUNERixnQkFBVztBQUFBLGNBQVNDLE1BQU1DLElBQU4sS0FBZSxVQUF4QjtBQUFBLE1BRFY7QUFFREEsV0FBTTtBQUZMLElBdERxQixFQXlEckI7QUFDREYsZ0JBQVc7QUFBQSxjQUFTQyxNQUFNTSxNQUFOLElBQWdCTixNQUFNTSxNQUFOLENBQWFMLElBQWIsS0FBc0IsUUFBL0M7QUFBQSxNQURWO0FBRURBLFdBQU07QUFGTCxJQXpEcUIsQ0FBeEI7O0FBOERBLFVBQU87QUFDTE8sd0JBQW1CQSxpQkFEZDtBQUVMdkIsV0FBTXdCO0FBRkQsSUFBUDs7QUFLQTs7QUFFQSxZQUFTRCxpQkFBVCxDQUEyQkUsU0FBM0IsRUFBc0M7QUFDcENaLHVCQUFrQmEsT0FBbEIsQ0FBMEJELFNBQTFCO0FBQ0Q7O0FBRUQsWUFBU0QsZUFBVCxHQUEyQjtBQUN6QixZQUFPO0FBQ0xYLDBCQUFtQkEsaUJBRGQ7QUFFTGMscUJBQWNBO0FBRlQsTUFBUDs7QUFLQTs7QUFFQSxjQUFTQSxZQUFULENBQXNCWixLQUF0QixFQUE2QjtBQUMzQixZQUFJLElBQUlhLElBQUksQ0FBUixFQUFXQyxJQUFJaEIsa0JBQWtCaUIsTUFBckMsRUFBNkNGLElBQUlDLENBQWpELEVBQW9ERCxHQUFwRCxFQUF5RDtBQUN2RCxhQUFHZixrQkFBa0JlLENBQWxCLEVBQXFCZCxTQUFyQixDQUErQkMsS0FBL0IsQ0FBSCxFQUEwQztBQUN4QyxrQkFBT0Ysa0JBQWtCZSxDQUFsQixFQUFxQlosSUFBNUI7QUFDRDtBQUNGO0FBQ0QsY0FBT0QsTUFBTUMsSUFBTixJQUFjRCxNQUFNTSxNQUFOLElBQWdCTixNQUFNTSxNQUFOLENBQWFMLElBQWxEO0FBQ0Q7QUFDRjtBQUVGOzttQkFFY0osdUI7Ozs7OztBQy9GZjs7OztBQUVBLFFBQU8sZUFBZSxTQUFTLGNBQWM7R0FDM0MsT0FBTzs7O0FBR1QsS0FBSSxXQUFXLE9BQU8sVUFBVSxVQUFVLFFBQVEsRUFBRSxLQUFLLElBQUksSUFBSSxHQUFHLElBQUksVUFBVSxRQUFRLEtBQUssRUFBRSxJQUFJLFNBQVMsVUFBVSxJQUFJLEtBQUssSUFBSSxPQUFPLFFBQVEsRUFBRSxJQUFJLE9BQU8sVUFBVSxlQUFlLEtBQUssUUFBUSxNQUFNLEVBQUUsT0FBTyxPQUFPLE9BQU8sWUFBWSxPQUFPOztBQU52UCxVQUFTbUIseUJBQXlCQyxnQkFBZ0I7R0FDaEQ7O0dBRUEsT0FBTztLQUNMQztLQUNBakM7Ozs7O0dBS0YsU0FBU0EsT0FBTzs7OztHQUloQixTQUFTaUMsVUFBVCxNQUEwQztLQUFBLElBQXJCQyxjQUFxQixLQUFyQkE7U0FBYXRDLE9BQVEsS0FBUkE7O0tBQ2hDLElBQU11QyxTQUFTO09BQ2J6QyxZQUFZO09BQ1owQyxjQUFjO09BQ2RGOztLQUVGRixlQUNLSyxNQUFTekMsT0FEZDtPQUVNMEMsS0FBSztRQUNGSCxTQUVKRSxNQUFTekMsT0FMZDtPQU1NMEMsS0FBSztRQUNGSDs7OztBQUtiLFVBQVNJLGlCQUFpQlAsZ0JBQWdCO0dBQ3hDOztHQUVBQSxlQUNLSyxNQUFNLHFCQUFxQjtLQUMxQkMsS0FBSztLQUNMNUMsWUFBWTtLQUNaMEMsY0FBYztLQUNkSSxhQUFhOzs7O0FBVXJCLFNBTlNEO0FBT1QsU0FQMkJSLG9EOzs7Ozs7QUM1QzNCOzs7O0FBRUEsUUFBTyxlQUFlLFNBQVMsY0FBYztHQUMzQyxPQUFPOztBQUhULFVBQVNVLGlCQUFpQkMsMkJBQTJCO0dBQ25EOztHQUVBQyxJQUFJQyxVQUFVO0tBQ1osT0FBTztPQUFBLE9BQVFyQyxFQUFFc0MsU0FBU0MsU0FBUyxDQUFDLHVCQUF1QkMsS0FBS0QsU0FBUzs7OztHQUczRSxJQUFJRSxhQUFhLENBQ2YsZUFDQSxhQUNBLHFCQUNBLG1CQUNBLDRCQUNBLGFBQ0EsZUFDQSxVQUNBLGFBQ0EsbUJBQ0EsaUJBQ0EsY0FDQSxrQkFDQSxnQkFDQSxlQUNBLFlBQ0Esb0JBQ0EsZUFDQTs7R0FHRnpDLEVBQUUwQyxLQUFLRCxZQUFZLFVBQVNFLFdBQVc7S0FDckNSLDBCQUEwQlMsY0FBYztPQUN0Q25DLE1BQU1rQztPQUNOVixvREFBa0RVLFlBQWxEOzs7OztBQUtOLFVBQVNFLGFBQWFDLGdCQUFnQjtHQUNwQzs7R0FFQUEsZUFBZUMsSUFDWCxvREFESjs7R0E0QkFELGVBQWVDLElBQ1gsNERBREo7O0dBa0NBLElBQUlDOztHQTZDSkYsZUFBZUMsSUFDWCwwREFESiw0U0FRUUMsd0JBUlI7O0dBYUFGLGVBQWVDLElBQ1gsbUVBREoscTlCQXVCUUMsd0JBdkJSOztHQTRCQUYsZUFBZUMsSUFDWCxvREFESjs7R0E2QkFELGVBQWVDLElBQ1gsc0RBREo7O0dBZ0NBRCxlQUFlQyxJQUNYLGlEQURKOztHQXdCQUQsZUFBZUMsSUFDWCxvREFESjs7R0E0QkFELGVBQWVDLElBQ1gsMERBREo7O0dBMkJBRCxlQUFlQyxJQUNYLHdEQURKOztHQStCQUQsZUFBZUMsSUFDWCxxREFESjs7R0FhQUQsZUFBZUMsSUFDWCxzREFESjs7R0F3QkFELGVBQWVDLElBQ1gseURBREo7O0dBOEJBRCxlQUFlQyxJQUNYLHVEQURKOztHQW9CQUQsZUFBZUMsSUFDWCxzREFESjs7R0ErQkFELGVBQWVDLElBQ1gsbURBREo7O0dBb0JBRCxlQUFlQyxJQUNYLDJEQURKOztHQTBCQUQsZUFBZUMsSUFDYixzREFERjs7R0FrQkFELGVBQWVDLElBQ1gsMkRBREo7OztBQXpkRixTQXNmU2I7QUFyZlQsU0FxZjJCVyw0Qjs7Ozs7O0FDMWpCM0I7Ozs7QUFFQSxRQUFPLGVBQWUsU0FBUyxjQUFjO0dBQzNDLE9BQU87OztBQUdULEtBQUksV0FBVyxPQUFPLFVBQVUsVUFBVSxRQUFRLEVBQUUsS0FBSyxJQUFJLElBQUksR0FBRyxJQUFJLFVBQVUsUUFBUSxLQUFLLEVBQUUsSUFBSSxTQUFTLFVBQVUsSUFBSSxLQUFLLElBQUksT0FBTyxRQUFRLEVBQUUsSUFBSSxPQUFPLFVBQVUsZUFBZSxLQUFLLFFBQVEsTUFBTSxFQUFFLE9BQU8sT0FBTyxPQUFPLFlBQVksT0FBTzs7QUFFdlAsS0FBSSxpQkFBaUIsWUFBWSxFQUFFLFNBQVMsY0FBYyxLQUFLLEdBQUcsRUFBRSxJQUFJLE9BQU8sSUFBSSxJQUFJLEtBQUssTUFBTSxJQUFJLEtBQUssT0FBTyxJQUFJLEtBQUssV0FBVyxJQUFJLEVBQUUsS0FBSyxJQUFJLEtBQUssSUFBSSxPQUFPLGFBQWEsSUFBSSxFQUFFLEtBQUssQ0FBQyxLQUFLLEdBQUcsUUFBUSxPQUFPLEtBQUssTUFBTSxFQUFFLEtBQUssS0FBSyxHQUFHLFFBQVEsSUFBSSxLQUFLLEtBQUssV0FBVyxHQUFHLFdBQVcsT0FBTyxLQUFLLEVBQUUsS0FBSyxNQUFNLEtBQUssZUFBZSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsTUFBTSxHQUFHLFdBQVcsR0FBRyx1QkFBdUIsRUFBRSxJQUFJLElBQUksTUFBTSxRQUFRLE9BQU8sUUFBUSxPQUFPLFVBQVUsS0FBSyxHQUFHLEVBQUUsSUFBSSxNQUFNLFFBQVEsTUFBTSxFQUFFLE9BQU8sWUFBWSxJQUFJLE9BQU8sWUFBWSxPQUFPLE1BQU0sRUFBRSxPQUFPLGNBQWMsS0FBSyxXQUFXLEVBQUUsTUFBTSxJQUFJLFVBQVU7O0FBRXRsQixVQUFTLGdCQUFnQixLQUFLLEtBQUssT0FBTyxFQUFFLElBQUksT0FBTyxLQUFLLEVBQUUsT0FBTyxlQUFlLEtBQUssS0FBSyxFQUFFLE9BQU8sT0FBTyxZQUFZLE1BQU0sY0FBYyxNQUFNLFVBQVUsZ0JBQWdCLEVBQUUsSUFBSSxPQUFPLFNBQVMsT0FBTzs7QUFFM00sVUFBUyxtQkFBbUIsS0FBSyxFQUFFLElBQUksTUFBTSxRQUFRLE1BQU0sRUFBRSxLQUFLLElBQUksSUFBSSxHQUFHLE9BQU8sTUFBTSxJQUFJLFNBQVMsSUFBSSxJQUFJLFFBQVEsS0FBSyxFQUFFLEtBQUssS0FBSyxJQUFJLE1BQU0sT0FBTyxhQUFhLEVBQUUsT0FBTyxNQUFNLEtBQUs7OztBQVgxTCxLQUFJN0MsSUFBSyxPQUFPaUQsV0FBVyxlQUFlQSxPQUFPakQsS0FBTSxtQkFBQWtELENBQVE7QUFDL0QsS0FBSUMsYUFDRCxPQUFPRixXQUFXLGVBQWVBLE9BQU9FLGNBQWUsbUJBQUFELENBQVE7O0FBRWxFLEtBQU1FLG9CQUFvQjtHQUN4QkMsVUFBVTtHQUNWLGFBQWE7R0FDYixtQkFBbUI7R0FDbkIsbUJBQW1CO0dBQ25CLHFCQUFxQjtHQUNyQkMsTUFBTTtHQUNOLGNBQWM7R0FDZCxhQUFhO0dBQ2IsZUFBZTtHQUNmLGlCQUFpQjtHQUNqQixVQUFVO0dBQ1Ysa0JBQWtCO0dBQ2xCLG9CQUFvQjtHQUNwQixvQkFBb0I7R0FDcEIsZ0JBQWdCO0dBQ2hCLGVBQWU7R0FDZixhQUFhO0dBQ2IsWUFBWTtHQUNaQyxXQUFXO0dBQ1hDLFNBQVM7R0FDVEMsVUFBVTtHQUNWQyxPQUFPO0dBQ1AsZUFBZTs7Ozs7QUFLakIsS0FBTUMsb0JBQW9CLENBQ3hCO0dBQ0VDLE1BQU07R0FDTkMsU0FBUyxpQkFBQ3JELE9BQU9zRCxTQUFSO0tBQUEsT0FBb0JBLFFBQVFDLGVBQWV2RDs7SUFFdEQ7R0FDRW9ELE1BQU07R0FDTkMsU0FBUyxpQkFBQ3JELE9BQU9zRCxTQUFTRSxZQUFqQjtLQUFBLE9BQ1AsQ0FBQ0EsY0FBY0YsUUFBUUcsZUFBZXpEOztJQUUxQztHQUNFb0QsTUFBTTtHQUNOQyxTQUFTLGlCQUFDckQsT0FBT3NELFNBQVI7S0FBQSxPQUFvQkEsUUFBUUkscUJBQXFCMUQ7O0lBRTVEO0dBQ0VvRCxNQUFNO0dBQ05DLFNBQVMsaUJBQUNyRCxPQUFPc0QsU0FBUjtLQUFBLE9BQ1A5RCxFQUFFRSxZQUFZTSxNQUFNMkQsWUFDcEIsQ0FBQ25FLEVBQUVFLFlBQVlNLE1BQU1NLE9BQU9xRCxZQUM1QkwsUUFBUUMsZUFBZXZEOztJQUUzQjtHQUNFb0QsTUFBTTtHQUNOQyxTQUFTLGlCQUFDckQsT0FBT3NELFNBQVNFLFlBQWpCO0tBQUEsT0FDUCxDQUFDQSxjQUFjeEQsTUFBTTRELFNBQVNOLFFBQVFPLGtCQUFrQjdEOztJQUU1RDtHQUNFb0QsTUFBTTtHQUNOQyxTQUFTLGlCQUFDckQsT0FBT3NELFNBQVNFLFlBQWpCO0tBQUEsT0FDUEYsUUFBUVEsaUJBQWlCOUQsT0FBT3dEOztJQUVwQztHQUNFSixNQUFNO0dBQ05DLFNBQVMsaUJBQUNyRCxPQUFPc0QsU0FBUjtLQUFBLE9BQW9CQSxRQUFRUyxtQkFBbUIvRDs7SUFFMUQ7R0FDRW9ELE1BQU07R0FDTkMsU0FBUyxpQkFBQ3JELE9BQU9zRCxTQUFTRSxZQUFqQjtLQUFBLE9BQ1AsQ0FBQ0EsY0FBY0YsUUFBUVUsMEJBQTBCaEU7Ozs7QUFJdkQsVUFBUzJCLDBCQUNQc0MsOEJBQ0FwRSx5QkFDQTtHQUNBOztHQUVBLE9BQU87S0FDTHVDO0tBQ0FuRCxNQUFNaUY7Ozs7O0dBS1IsU0FBUzlCLGNBQWMxQixXQUFXO0tBQ2hDLElBQUlBLFVBQVVYLFdBQVc7T0FDdkJGLHdCQUF3Qlcsa0JBQWtCO1NBQ3hDVCxXQUFXVyxVQUFVWDtTQUNyQkUsTUFBTVMsVUFBVVQ7Ozs7S0FJcEIsSUFBSVMsVUFBVTJDLFNBQVM7T0FDckJULGtCQUFrQmxDLFVBQVVULFFBQVFTLFVBQVUyQzs7O0tBR2hELElBQUkzQyxVQUFVZSxhQUFhO09BQ3pCd0MsNkJBQTZCRSxXQUMzQixzQkFDQXpELFVBQVVULE1BQ1ZTLFVBQVVlO09BRVp3Qyw2QkFBNkJHLGdCQUMzQjFELFVBQVVULE1BQ1ZTLFVBQVVlOzs7OztBQU1sQixVQUFTeUMsa0JBQ1BHLEtBQ0FDLFFBQ0FwRixrQkFDQXVCLGlCQUNBOEQsUUFDQUMsY0FDQUMsVUFDQUMsUUFDQXJGLGNBQ0E7R0FDQTs7R0FFQSxJQUFNc0YsV0FBVztHQUNqQixJQUFNQyxZQUFZO0tBQ2hCQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBekQ7S0FDQTBEO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0F2RDtLQUNBRTtLQUNBSDtLQUNBeUQ7S0FDQXZEO0tBQ0F3RDtLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBdEU7S0FDQUQ7S0FDQXdFO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDO0tBQ0FDOzs7R0FHRixTQUFTQyxXQUFXQyxJQUFJO0tBQ3RCLE9BQU8vSixFQUFFZ0ssS0FBSzdFLFVBQVU0RTs7O0dBRzFCLFNBQVNFLGVBQWVGLElBQUk7S0FDMUIsSUFBTWpHLFVBQVVnRyxXQUFXQztLQUMzQixJQUFJakcsU0FBUztPQUNYQSxRQUFROEI7T0FDUjVGLEVBQUVrSyxNQUFNcEc7T0FDUjlELEVBQUVtSyxPQUFPaEYsVUFBVSxVQUFDaUYsR0FBRDtTQUFBLE9BQU9BLE1BQU10Rzs7Ozs7R0FJcEMsU0FBU3VHLHdCQUErQjtLQUFBLGtDQUFOQyxPQUFNO09BQU5BLEtBQU07OztLQUN0QyxJQUFJQSxLQUFLL0ksU0FBUyxHQUFHO09BQUEsSUFDZFQsU0FBeUJ3SixLQURYO1dBQ05DLFFBQWlCRCxLQURYO1dBQ0N0TCxTQUFVc0wsS0FEWDtZQUVkO09BQUEsYUFDMkJBLEtBQUs7V0FBL0J4SixTQURELE9BQ0NBO1dBQVF5SixRQURULE9BQ1NBO1dBQU92TCxTQURoQixPQUNnQkE7OztLQUd2QixJQUFNd0wsYUFBYVYsV0FBVyxVQUFDaEcsU0FBRDtPQUFBLE9BQWFBLFFBQVF5RyxVQUFVQTs7S0FDN0QsSUFBSUMsWUFBWTtPQUNkLElBQUkxSixRQUFRO1NBQ1YwSixXQUFXbkYsUUFBUXZFLFFBQVF5SixPQUFPdkw7O09BRXBDLE9BQU93TDs7O0tBR1QsSUFBTUMsYUFBYSxJQUFJQyxXQUFXNUosUUFBUXlKLE9BQU92TDtLQUNqRG1HLFNBQVN2RixLQUFLNks7S0FDZCxPQUFPQTs7O0dBR1QsU0FBU0MsV0FBVzVKLFFBQVF5SixPQUFPdkwsUUFBUTtLQUN6QyxJQUFJYSxhQUFhOEssT0FBTztPQUN0QjFILE9BQU9rQyxXQUFXQTs7O0tBR3BCLEtBQUt5RixjQUFjO0tBQ25CLEtBQUtDLGlCQUFpQjtLQUN0QixLQUFLQyxZQUFZO0tBQ2pCLEtBQUtDLFdBQVc7S0FDaEIsS0FBS0MsU0FBUztLQUNkLEtBQUtDLFNBQVM7S0FDZCxLQUFLQyxZQUFZO0tBQ2pCLEtBQUtDLGFBQWE7S0FDbEIsS0FBS0MsWUFBWTtLQUNqQixLQUFLQyxrQkFBa0I7S0FDdkIsS0FBS2QsUUFBUUE7S0FDYixLQUFLZSxVQUFVO0tBQ2YsS0FBS0MsY0FBYzs7S0FFbkIsSUFBTXhMLFlBQVlmLE9BQU93TSxZQUFZeE0sT0FBT3dNLGNBQWM7S0FDMUQsS0FBS0MsU0FBUy9MLGlCQUFpQkksZUFBZUM7O0tBRTlDLEtBQUtDLElBQUlBOztLQUVULEtBQUtxRixRQUFRdkUsUUFBUXlKLE9BQU92TDs7O0dBRzlCZ0IsRUFBRTBMLE9BQU9oQixXQUFXdEYsV0FBV0E7R0FDL0JwRixFQUFFMEwsT0FBT3JCLHVCQUF1QmpGLFdBQVcsRUFBRTBFLHdCQUFZRzs7R0FFekQsT0FBT0k7Ozs7R0FJUCxTQUFTaEYsUUFBUXZFLFFBQVF5SixPQUFPdkwsUUFBUTtLQUN0QyxJQUFJOEUsVUFBVTs7S0FFZCxJQUFJOUUsVUFBVUEsT0FBTzJNLFVBQVU7T0FDN0I3SCxRQUFROEgsUUFBUTVNLE9BQU8yTTs7S0FFekI3SCxRQUFRaEQsU0FBU0E7S0FDakJnRCxRQUFReUcsUUFBUUE7O0tBRWhCLElBQUksQ0FBQ3pHLFFBQVFtRCxjQUFjO09BQ3pCbkQsUUFBUTRGLFlBQVkxSzs7T0FFcEIsSUFBSThCLE9BQU8rSyxPQUFPO1NBQ2hCN0wsRUFBRTBDLEtBQUs1QixPQUFPK0ssT0FBTyxVQUFVQyxNQUFNO1dBQ25DOUwsRUFBRTBDLEtBQUtvSixLQUFLQSxNQUFNaEksUUFBUTZELGFBQWFvRSxLQUFLakk7O2NBRXpDO1NBQ0w5RCxFQUFFMEMsS0FBSzVCLE9BQU9nTCxNQUFNaEksUUFBUTZELGFBQWFvRSxLQUFLakk7OztPQUdoREEsUUFBUWlEO09BQ1JqRCxRQUFRZ0Q7T0FDUmhELFFBQVFtRCxXQUFXOzs7S0FHckJuRCxRQUFRNEI7OztHQUdWLFNBQVN1QixXQUFXK0UsVUFBVTtLQUM1QixJQUFJbEksVUFBVTtLQUNkLElBQUlrSSxVQUFVO09BQ1psSSxRQUFRaEQsT0FBT21MLFdBQVdEOztLQUU1QixPQUFPbEksUUFBUWhELFVBQVVnRCxRQUFRaEQsT0FBT21MOzs7R0FHMUMsU0FBU3ZDLFlBQVkxSyxRQUFRO0tBQzNCLElBQUk4RSxVQUFVO0tBQ2QsSUFBSTlFLFFBQVE7T0FDVixJQUFJQSxPQUFPa04sVUFBVXBJLFFBQVFvSSxXQUFXbE4sT0FBT2tOO09BQy9DLElBQUlsTixPQUFPbU4sY0FBY3JJLFFBQVFxSSxlQUFlbk4sT0FBT21OO09BQ3ZELElBQUluTixPQUFPMEgsV0FDVDVDLFFBQVFzSSxnQkFBZ0J0SSxRQUFRNkYsbUJBQW1CM0ssT0FBTzBIOztLQUU5RDVDLFFBQVF1SSxvQkFBb0JyTixPQUFPd00sYUFBYXhMLEVBQUVzTTs7O0dBR3BELFNBQVM5RCxjQUFjaEksT0FBTztLQUM1QixJQUFNc0QsVUFBVTtLQURZLElBRXBCaEQsU0FBV04sTUFBWE07OztLQUVSTixNQUFNK0wsZ0JBQWdCO09BQUEsT0FDcEJ2TSxFQUFFd00sUUFBUTFMLE9BQU9MLFFBQVFULEVBQUV5TSxNQUFNM0wsT0FBT0wsUUFBUUssT0FBT0w7O0tBQ3pELElBQUksQ0FBQ0QsTUFBTUMsTUFBTUQsTUFBTUMsT0FBT0QsTUFBTStMLGlCQUFpQi9MLE1BQU0rTDs7O0dBRzdELFNBQVN4SSxlQUFldkQsT0FBTztLQUM3QixJQUFNc0QsVUFBVTtLQURhLElBRXJCaEQsU0FBV04sTUFBWE07O0tBQ1IsSUFBTTRMLGFBQWFsTSxNQUFNMkQsV0FBV3JELE9BQU9xRDtLQUMzQyxJQUFNd0ksTUFBTTdJLFFBQVEyQyxPQUFPakcsTUFBTW1NOztLQUVqQyxJQUFJN0ksUUFBUXlILFlBQVlvQixNQUFNO09BQzVCLE9BQU83SSxRQUFReUgsWUFBWW9CO09BQzNCOzs7S0FHRixJQUFJbk0sTUFBTUQsV0FBVztPQUNuQixJQUFNQSxZQUFZOEksa0JBQ2hCN0ksTUFBTUQsV0FDTkMsTUFBTW9NLGNBQWNEO09BRXRCLElBQUksQ0FBQzdJLFFBQVF1RCxlQUFlOUcsWUFBWTs7Ozs7S0FLMUMsSUFBSSxDQUFDUCxFQUFFRSxZQUFZd00sYUFBYTtPQUM5QixJQUFJQyxJQUFJak0sWUFBWWlNLElBQUlqTSxTQUFTLE9BQU87T0FDeEMsSUFBTTZKLFFBQVF6RyxRQUFRd0QsZ0JBQWdCOUcsTUFBTW1NLEtBQUs3SSxRQUFReUc7T0FDekQsSUFBTXNDLGFBQWF0QyxNQUFNdUM7OztPQUd6QixJQUNFOU0sRUFBRUUsWUFBWTJNLGVBQ2IsQ0FBQzdNLEVBQUUrTSxJQUFJakosUUFBUWlILFVBQVU0QixPQUN0QjlOLFFBQVFtTyxPQUFPSCxZQUFZL0ksUUFBUWlILFNBQVM0QixRQUM1QzNNLEVBQUVpTixhQUFhSixnQkFDakIsQ0FBQ2hPLFFBQVFtTyxPQUFPSCxZQUFZSCxhQUM5QjtTQUNBbkMsTUFBTTJDLElBQUlyTyxRQUFRc08sS0FBS1Q7OztLQUczQjVJLFFBQVFpSCxTQUFTNEIsT0FBTzlOLFFBQVFzTyxLQUFLVDs7S0FFckMsSUFBSTVMLE9BQU9DLFdBQVcsU0FBUyxDQUFDUCxNQUFNNE0sbUJBQW1CO09BQ3ZELElBQUksQ0FBQzVNLE1BQU1DLE1BQU1ELE1BQU1DLE9BQU87T0FDOUJELE1BQU00TSxvQkFBb0I7Ozs7R0FJOUIsU0FBU3hGLGdCQUFnQnZFLFVBQVU7S0FDakMsSUFBSVMsVUFBVTs7S0FFZFQsU0FBUzVDLE9BQU87S0FDaEI0QyxTQUFTZ0ssTUFBTUMsUUFBUXhKLFFBQVE2RCxhQUFhb0UsS0FBS2pJOztLQUVqRCxJQUFJOUQsRUFBRStNLElBQUkxSixVQUFVLFVBQVVBLFNBQVNrSyxRQUFRLEdBQUc7T0FDaERsSyxTQUFTbUssWUFBWSxDQUFDbkssU0FBU21LLGFBQWEsTUFBTTs7S0FFcEQsSUFBSW5LLFNBQVNvSyxhQUFhO09BQ3hCcEssU0FBU3FLLGlCQUFpQixVQUFDckssVUFBYTtTQUN0QyxJQUFJQSxTQUFTb0ssYUFBYTtXQUN4QnBLLFNBQVNzSyxZQUFZLENBQUN0SyxTQUFTc0s7Ozs7T0FJbkN0SyxTQUFTdUssU0FBUyxDQUFDdkssU0FBU3NLO1lBQ3ZCO09BQ0x0SyxTQUFTdUssU0FBUzs7OztHQUl0QixTQUFTdEosaUJBQWlCOUQsT0FBT3dELFlBQVk7S0FDM0MsSUFBTUYsVUFBVTtLQUNoQixJQUFNNUMsWUFBWUQsZ0JBQWdCRyxhQUFhWjtLQUMvQyxJQUFNcUQsVUFBVVQsa0JBQWtCbEM7S0FDbEMsSUFBSWxCLEVBQUVzQyxTQUFTdUIsVUFBVTtPQUN2QkMsUUFBUUQsU0FBU3JELE9BQU93RDtZQUNuQixJQUFJaEUsRUFBRTZOLFdBQVdoSyxVQUFVO09BQ2hDQSxRQUFRaUssS0FBS2hLLFNBQVN0RCxPQUFPd0Q7Ozs7R0FJakMsU0FBUytKLFVBQVV2TixPQUFPO0tBQ3hCLE9BQU9SLEVBQUVnTyxPQUFPaE8sRUFBRWlPLEtBQUt6TixRQUFRLFVBQUNtTSxLQUFEO09BQUEsUUFBUyx1QkFBdUJuSyxLQUFLbUs7Ozs7O0dBR3RFLFNBQVNoRixhQUFhbkgsT0FBTytNLEtBQUs7S0FDaEMsSUFBTXpKLFVBQVU7O0tBRWhCLElBQUlqRixRQUFRcVAsVUFBVVgsTUFBTTtPQUMxQi9NLE1BQU0rTSxNQUFNQTs7O0tBR2QsSUFBSSxDQUFDL00sTUFBTTJOLFNBQVM7T0FDbEIzTixNQUFNMk4sVUFBVUosVUFBVXZOOzs7S0FHNUIsSUFBTW1NLE1BQU03SSxRQUFRMkMsT0FBT2pHLE1BQU1tTTs7S0FFakMsSUFBSUEsS0FBSztPQUNQN0ksUUFBUTBCLGVBQWVoRixPQUFPbU07T0FDOUIsSUFBTTdMLFNBQVNnRCxRQUFRNEMsVUFBVWlHOztPQUVqQyxJQUFJN0wsUUFBUTtTQUNWTixNQUFNTSxTQUFTQTtTQUNmLElBQUlBLE9BQU9zTixhQUFhNU4sTUFBTTROLGNBQWN0TixPQUFPc047U0FDbkQsSUFBSXROLE9BQU9MLFNBQVMsV0FBVyxFQUFFLGtCQUFrQkQsUUFDakRBLE1BQU02TixlQUFlOzs7T0FHekJ2SyxRQUFRMEUsY0FBY2hJOzs7S0FHeEJzRCxRQUFRK0Qsa0JBQWtCckg7O0tBRTFCLElBQUltTSxLQUFLO09BQ1AsQ0FBQyxVQUFDQSxLQUFRO1NBQ1IsSUFBSTNNLEVBQUVnSyxLQUFLbEcsUUFBUWtILFFBQVEsRUFBRTJCLGFBQVE7V0FDbkM3SSxRQUFRa0gsU0FBU2hMLEVBQUVnTyxPQUFPbEssUUFBUWtILFFBQVEsRUFBRTJCO1dBQzVDN0ksUUFBUThILE1BQU0wQyxXQUNaLHNCQUFzQjNCLEtBQ3RCLG9CQUNBO1dBRUY3SSxRQUFROEgsTUFBTTBDLFdBQ1osc0JBQXNCM0IsS0FDdEIsY0FDQTs7VUFHSDRCLFVBQVU1Qjs7T0FFYixJQUFJbk0sTUFBTWdPLE9BQU87U0FDZjFLLFFBQVFrSCxPQUFPcEwsS0FBS2tFLFFBQVE2QixXQUFXbkY7U0FDdkMsSUFBSVIsRUFBRXlPLFFBQVFqTyxNQUFNa08saUJBQWlCO1dBQ25DbE8sTUFBTWtPLGlCQUFpQjthQUNyQkMsY0FBYzs7Z0JBRVg7V0FDTG5PLE1BQU1rTyxlQUFlQyxlQUFlOzs7Ozs7R0FNNUMsU0FBUzlHLGtCQUFrQnJILE9BQU93RCxZQUFZO0tBQzVDLElBQU1GLFVBQVU7S0FDaEJILGtCQUFrQjJKLFFBQ2hCO09BQUEsSUFBRzFKLE9BQUgsS0FBR0E7V0FBTUMsVUFBVCxLQUFTQTtPQUFULE9BQ0U3RCxFQUFFK00sSUFBSXZNLE9BQU9vRCxTQUFTQyxRQUFRckQsT0FBT3NELFNBQVNFOzs7O0dBSXBELFNBQVN5QyxPQUFPa0csS0FBSztLQUNuQixJQUFJM00sRUFBRXdNLFFBQVFHLE1BQU07T0FDbEJBLE1BQU0zTSxFQUFFNE8sT0FBT2pDLEtBQUssVUFBQ2tDLE9BQU9DLE1BQVI7U0FBQSxRQUNsQixZQUFZdE0sS0FBS3NNLFFBQVFELFFBQVEsTUFBTUMsT0FBTyxNQUFNRCxRQUFRLE1BQU1DOzs7O0tBR3RFLE9BQU9uQzs7O0dBR1QsU0FBU2pHLFVBQVVpRyxLQUFLb0MsT0FBTztLQUM3QixJQUFJakwsVUFBVTtLQUNkLElBQUksQ0FBQzZJLEtBQUs7O0tBRVZBLE1BQU14SixXQUFXNkwsTUFBTWxMLFFBQVEyQyxPQUFPa0c7S0FDdENvQyxRQUFRQSxTQUFTakwsUUFBUWhELE9BQU9BLE9BQU9tTztLQUN2QyxJQUFJeEM7U0FBT3FDOztLQUVYLE9BQU9uQyxJQUFJcEwsU0FBUyxHQUFHO09BQ3JCdU4sT0FBT25DLElBQUk7T0FDWCxJQUFJLFVBQVVuSyxLQUFLc00sT0FBTztTQUN4QixJQUFJbkMsSUFBSXBMLFdBQVcsR0FBRztXQUNwQndOLFFBQVFBLE1BQU1wQyxJQUFJdUM7Z0JBQ2I7V0FDTEgsUUFBUUEsTUFBTXBDLElBQUl1QyxTQUFTN0IsTUFBTTRCO1dBQ2pDdEMsSUFBSXVDOztjQUVEO1NBQ0xILFFBQVFBLE1BQU1wQyxJQUFJdUMsU0FBU0Q7Ozs7O0tBSy9CeEMsUUFBUUUsSUFBSSxNQUFNOztLQUVsQixPQUFPb0MsTUFBTXRDOzs7R0FHZixTQUFTckcsV0FBVzVGLE9BQU87S0FDekIsSUFBTXNELFVBQVU7S0FDaEJ0RCxRQUFRQSxNQUFNbU0sTUFBTW5NLFFBQVFzRCxRQUFRd0MsaUJBQWlCOUY7S0FDckQsT0FDRUEsVUFDQzNCLFFBQVFxUCxVQUFVMU4sTUFBTTJELFdBQ3JCM0QsTUFBTTJELFVBQ04zRCxNQUFNTSxVQUFVTixNQUFNTSxPQUFPcUQ7OztHQUlyQyxTQUFTd0MsY0FBY3dJLEtBQUs7S0FDMUIsSUFBTUMsYUFBYTtLQUNuQixJQUFJQyxTQUFTQyxzQkFBc0JIO0tBQ25DLElBQUlJLGFBQWE7O0tBRWpCLE9BQU9GLFFBQVE7T0FDYixJQUFJLFVBQVU3TSxLQUFLNk0sT0FBTyxPQUFPLGlCQUFpQjdNLEtBQUs2TSxPQUFPLEtBQUs7U0FDakVFLGFBQWFGLE9BQU87U0FDcEJGLE1BQU1BLElBQUlLLFFBQVFILE9BQU8sSUFBSTtjQUN4QjtTQUNMRCxXQUFXeFAsS0FBS3lQLE9BQU8sR0FBR0csUUFBUSxrQkFBa0JEO1NBQ3BEQSxhQUFhO1NBQ2JKLE1BQU1BLElBQUlLLFFBQVFILE9BQU8sSUFBSTs7T0FFL0JBLFNBQVNDLHNCQUFzQkg7OztLQUdqQyxpQkFBV0MsWUFBWCxDQUF1QkQsSUFBSUssUUFBUSxrQkFBa0JEOzs7R0FHdkQsU0FBU3RMLGVBQWV6RCxPQUFPO0tBQzdCLElBQU1zRCxVQUFVO0tBQ2hCLElBQU02SSxNQUFNN0ksUUFBUTJDLE9BQU9qRyxNQUFNbU07O0tBRWpDM00sRUFBRTBDLEtBQUtsQyxNQUFNaVAsU0FBUyxVQUFVQyxVQUFVQyxXQUFXO09BQ25ERCxXQUFXckcsa0JBQWtCcUcsVUFBVS9DLE9BQU9uTSxNQUFNb007T0FDcEQsSUFBSThDLFNBQVNoUCxTQUFTLGlCQUFpQjs7T0FFdkNvRCxRQUFROEMsY0FBY3BHLE9BQU9tUCxXQUFXRCxVQUFVOztPQUVsRC9JLGNBQWMrSSxVQUFVcEMsUUFBUSxVQUFDc0MsV0FBYztTQUFBLFlBRTNDQSxVQUFVQyxNQUFNLG9DQUFvQzthQUZUO2FBQ3BDQyxPQURvQzthQUM5QlgsTUFEOEI7O1NBSTdDLElBQUlXLE1BQU07V0FDUixJQUFJQSxTQUFTLGdCQUFnQjthQUMzQmhNLFFBQVFzRixnQkFBZ0I1SSxPQUFPbVAsV0FBV1IsS0FBS087a0JBQzFDLElBQUlJLFNBQVMsVUFBVTthQUM1QmhNLFFBQVFxRixnQkFBZ0JnRyxLQUFLLFlBQU07ZUFDakNyTCxRQUFROEMsY0FBY3BHLE9BQU9tUCxXQUFXRDs7Ozs7OztLQU9sRCxPQUFPbFA7OztHQUdULFNBQVM0RyxTQUFTK0gsS0FBS1csTUFBTTtLQUMzQixJQUFNaE0sVUFBVTtLQUNoQixJQUFJaU07S0FDSixJQUFNQyxVQUFVYixJQUFJYyxNQUFNO0tBQzFCLElBQU1KLFFBQVE3UCxFQUFFZ0ssS0FBS2dHLFNBQVMsVUFBQ0UsR0FBTTtPQUNuQyxJQUFNL1AsSUFBSTJELFFBQVF3RCxnQkFBZ0I0SSxHQUFHSixNQUFNaEQ7T0FDM0MsSUFBSSxDQUFDOU0sRUFBRUUsWUFBWUMsSUFBSTtTQUNyQjRQLFNBQVM1UDtTQUNULE9BQU87OztLQUdYLE9BQU80UDs7O0dBR1QsU0FBUzVJLFNBQVNnSSxLQUFLVyxNQUFNO0tBQzNCLElBQU1oTSxVQUFVO0tBQ2hCLElBQU1xTSxNQUFNaEIsSUFBSWMsTUFBTTtLQUN0QixJQUFNSixRQUFRN1AsRUFBRTRPLE9BQ2R1QixLQUNBLFVBQUNDLEtBQUtGLEdBQU07T0FDVixJQUFNL1AsSUFBSTJELFFBQVF3RCxnQkFBZ0I0SSxHQUFHSixNQUFNaEQ7T0FDM0MsSUFBSSxDQUFDOU0sRUFBRUUsWUFBWUMsSUFBSTtTQUNyQmlRLElBQUl4USxLQUFLTzs7T0FFWCxPQUFPaVE7UUFFVDtLQUVGLE9BQU9ELElBQUk1TyxXQUFXc08sTUFBTXRPLFNBQVN2QixFQUFFcVEsS0FBS1IsU0FBU1M7OztHQUd2RCxTQUFTMUosY0FBY3BHLE9BQU9tUCxXQUFXUixLQUFLb0Isa0JBQWtCO0tBQzlELElBQU16TSxVQUFVO0tBQ2hCLElBQU12QixPQUFPNE0sSUFBSXpPLFNBQVMsVUFDdEJvRCxRQUFRc0QsU0FBUytILE9BQ2pCQSxJQUFJek8sU0FBUyxVQUNib0QsUUFBUXFELFNBQVNnSSxPQUNqQnJMLFFBQVF3RCxnQkFBZ0I2SCxLQUFLckM7O0tBRWpDLElBQUl2SyxRQUFRQSxLQUFLaU8sUUFBUTtPQUN2QmhRLE1BQU1pUSxXQUFXLFlBQVk7U0FDM0IsSUFBTWYsV0FBV1AsSUFBSVUsTUFBTSxzQkFBc0I7U0FDakQvTCxRQUFRNE0sY0FBUixVQUE4QmhCLFdBQTlCLE1BQTBDbk4sS0FBS2lPOztZQUU1QztPQUNMLE9BQU9oUSxNQUFNaVE7OztLQUdmLElBQU1FLE1BQU1wTyxRQUFRQSxLQUFLQSxPQUFPQSxLQUFLQSxPQUFPQTtLQUM1QyxJQUFNcU8sT0FBT2pCLGNBQWMsY0FBY2dCLE1BQU0sS0FBS0E7S0FDcEQ3TSxRQUFRd0QsZ0JBQWdCcUksV0FBV25QLE9BQU8wTSxJQUFJMEQ7O0tBRTlDLElBQUksQ0FBQ0wsa0JBQWtCO09BQ3JCNU0sa0JBQWtCMkosUUFDaEI7U0FBQSxJQUFHMUosT0FBSCxNQUFHQTthQUFNQyxVQUFULE1BQVNBO1NBQVQsT0FBdUJELFNBQVMrTCxhQUFhOUwsUUFBUXJELE9BQU9zRDs7Ozs7R0FLbEUsU0FBU3NGLGdCQUFnQjVJLE9BQU9tUCxXQUFXRCxVQUFVUCxLQUFLO0tBQ3hELElBQUlyTCxVQUFVOztLQUVkLElBQUkrTSxXQUFXL00sUUFBUTJDLE9BQU9qRyxNQUFNbU07S0FDcEM3SSxRQUFRdUgsZ0JBQWdCcUUsWUFBWTVMLFFBQVF1SCxnQkFBZ0JxRSxhQUFhOztLQUV6RSxJQUFJb0IsV0FBV2hOLFFBQVF1SCxnQkFBZ0JxRTtLQUN2Q29CLFNBQVNELFlBQVlDLFNBQVNELGFBQWE7S0FDM0NDLFNBQVNELFVBQVVqUixLQUFLLEVBQUVZLGNBQU9vRCxNQUFNK0wsV0FBV1I7OztHQUdwRCxTQUFTNUssbUJBQW1CL0QsT0FBTztLQUNqQyxJQUFNc0QsVUFBVTtLQUNoQjlELEVBQUUwQyxLQUFLbEMsTUFBTXVRLGNBQWMsVUFBQ3hRLFdBQVdvTSxLQUFRO09BQzdDLElBQU05SSxVQUFVLFNBQVZBLFFBQVc4TSxLQUFLSyxNQUFTO1NBQzdCeFEsTUFBTW1NLE9BQU83SSxRQUFRdUQsZUFBZTlHO1NBQ3BDLElBQU1xTCxRQUFROUgsUUFBUXlDLGtCQUFrQnpDLFFBQVEyQyxPQUFPakcsTUFBTW1NO1NBQzdELElBQUlBLFFBQVEsY0FBY2YsT0FBTztXQUMvQjlILFFBQVE4SCxNQUFNMEMsV0FBVzs7O09BRzdCOU4sTUFBTXVRLGFBQWFwRSxLQUNoQmtELE1BQU0sb0JBQ05vQixJQUFJLFVBQUNDLE1BQUQ7U0FBQSxPQUFVQSxLQUFLckIsTUFBTSxtQkFBbUI7VUFDNUN2QyxRQUFRLFVBQUNYLEtBQVE7U0FDaEI3SSxRQUFRcUYsZ0JBQWdCd0QsS0FBSzlJOztPQUVqQ0E7Ozs7R0FJSixTQUFTUSxrQkFBa0I3RCxPQUFPO0tBQ2hDLElBQU1zRCxVQUFVO0tBQ2hCLElBQUksQ0FBQ3RELE1BQU00RCxPQUFPOztLQUVsQixJQUFJdEQsU0FBU04sTUFBTU07S0FDbkJOLE1BQU00RCxRQUFRcEUsRUFBRXdNLFFBQVFoTSxNQUFNNEQsU0FBUzVELE1BQU00RCxRQUFRLENBQUM1RCxNQUFNNEQ7O0tBRTVEcEUsRUFBRTBDLEtBQUtsQyxNQUFNNEQsT0FBTyxVQUFVQSxPQUFPO09BQ25DLElBQUlBLE1BQU0rTSxZQUFZO1NBQ3BCLElBQUk1UTtTQUNKLElBQUlQLEVBQUVzQyxTQUFTOUIsTUFBTUQsWUFBWTs7V0FFL0JBLFlBQVksV0FBV2lDLEtBQUtoQyxNQUFNRCxhQUM5QkMsTUFBTUQsWUFERSxNQUVKQyxNQUFNRCxZQUZGOztTQUlkLElBQUlQLEVBQUVzQyxTQUFTOEIsTUFBTTdELFlBQVk7V0FDL0JBLFlBQVlBLFlBQ0xBLFlBREssU0FDVzZELE1BQU03RCxZQUN6QjZELE1BQU03RDs7U0FFWixJQUFJNFEsYUFBYS9NLE1BQU0rTTtTQUN2QixJQUFJdE47O1NBRUosSUFBSTdELEVBQUU2TixXQUFXc0QsYUFBYTtXQUM1QnROLFVBQVUsaUJBQVV1TixLQUFLSixNQUFNO2FBQzdCLElBQUksQ0FBQ3pRLGFBQWF1RCxRQUFRdUQsZUFBZTlHLFlBQVk7ZUFDbkQ0USxXQUFXQyxLQUFLSjs7O2dCQUdmO1dBQ0wsSUFBSUssYUFBYTs7V0FFakJBLFdBQVdDLE9BQU9ILFdBQVd0QixNQUFNOztXQUVuQyxJQUFJd0IsV0FBV0MsTUFBTTthQUNuQkQsV0FBV0MsT0FBTztlQUNoQlgsS0FBS1UsV0FBV0MsS0FBSztlQUNyQkMsT0FBT0YsV0FBV0MsS0FBSzs7YUFFekJILGFBQWFBLFdBQVczQixRQUFRNkIsV0FBV0MsS0FBS1gsS0FBSyxJQUFJYTtrQkFDcEQ7YUFDTEgsV0FBV0ksT0FBT04sV0FBV3RCLE1BQU07O2FBRW5DLElBQUl3QixXQUFXSSxNQUFNO2VBQ25CSixXQUFXSyxXQUFXO2lCQUNwQixLQUFLO2lCQUNMLEtBQUs7aUJBQ0wsS0FBSztpQkFDTCxLQUFLO2lCQUNMTCxXQUFXSSxLQUFLOztlQUVsQkosV0FBV00sV0FBVzdOLFFBQVF3RCxnQkFBZ0IrSixXQUFXSSxLQUFLOzs7O1dBSWxFTixhQUFhQSxXQUFXdEIsTUFBTTs7V0FFOUJoTSxVQUFVLGlCQUFDOE0sS0FBS0ssTUFBTXJFLEtBQUtpRixTQUFZO2FBQ3JDLElBQUlDLGVBQWV0UixhQUFhOEksa0JBQWtCOUksV0FBV29NO2FBQzdELElBQ0UzTSxFQUFFc0MsU0FBU3VQLGlCQUNYQSxhQUFhblIsU0FBUyxpQkFDdEI7ZUFDQSxPQUFPb1IsUUFBUXRELE1BQVIsdURBQ2dEcUQsZUFEaEQ7O2FBSVQsSUFBSUUsYUFBYTFJLGtCQUFrQjhILFdBQVcsSUFBSXhFO2FBQ2xELElBQUlxRixXQUFXM0ksa0JBQWtCOEgsV0FBVyxJQUFJeEU7O2FBRWhELElBQUlzRixTQUFTbk8sUUFBUXdELGdCQUFnQnlLOzs7YUFHckMsSUFBSUgsWUFBWUssT0FBT2YsT0FBT3ZFLEtBQUs7YUFDbkNpRixVQUFVSyxPQUFPZixPQUFPdkU7O2FBRXhCLElBQUl1RixPQUFPcE8sUUFBUXdELGdCQUFnQjBLOzthQUVuQyxJQUFJLENBQUN6UixhQUFhdUQsUUFBUXVELGVBQWV3SyxlQUFlO2VBQ3RELElBQUlSLFdBQVdDLE1BQU07aUJBQ25CVyxPQUFPL0UsSUFDTGlGLE9BQU9ELEtBQUtwRixPQUNUc0YsSUFBSWYsV0FBV0MsS0FBS1gsS0FBS1UsV0FBV0MsS0FBS0MsT0FDekNjO3NCQUVBLElBQUloQixXQUFXSSxNQUFNOzs7aUJBRzFCLElBQUkxQixTQUFTakwsT0FDWG9OLEtBQUtwRixRQUFRdUUsV0FBV0ksS0FBSyxLQUFLSixXQUFXTSxTQUFTN0U7aUJBRXhEaE0sU0FDRUEsVUFDQ04sTUFBTTZNLFVBQ0o3TSxNQUFNNk0sTUFBTSxHQUFHdk0sVUFDYk4sTUFBTTZNLE1BQU0sR0FBR0EsU0FDZDdNLE1BQU02TSxNQUFNLEdBQUdBLE1BQU0sR0FBR3ZNO2lCQUNoQyxJQUFJTixNQUFNQyxTQUFTLGVBQWU7bUJBQ2hDLElBQUk2UixJQUNGeFIsVUFBVUEsT0FBT0MsV0FBVyxxQkFBcUIsSUFBSTs7bUJBRXZELElBQUlzUSxXQUFXSSxLQUFLLE9BQU8sS0FBSztxQkFDOUIxQixTQUFTL1AsRUFBRXVTLE1BQU14QyxRQUFRdUM7MEJBQ3BCLElBQUlqQixXQUFXSSxLQUFLLE9BQU8sS0FBSztxQkFDckMxQixTQUFTL1AsRUFBRXdTLEtBQUt6QyxRQUFRdUM7MEJBQ25CO3FCQUNMdkMsU0FBUy9QLEVBQUV5UyxNQUFNMUMsUUFBUXVDOzs7O2lCQUk3QixJQUFJeE8sUUFBUXNILFVBQVV3RyxVQUFVO21CQUM5QjlOLFFBQVFzSCxVQUFVd0csU0FBU0EsVUFBVWpGOztpQkFFdkNzRixPQUFPL0UsSUFBSTZDLFVBQVU7c0JBQ2hCO2lCQUNMa0MsT0FBTy9FLElBQUlnRixLQUFLcEY7Ozs7OztTQU14QmhKLFFBQVFxRixnQkFDTjNJLE9BQ0FxRCxTQUNBckQsTUFBTTJMLGNBQ04vSCxNQUFNc087Ozs7O0dBTWQsU0FBU3JMLGVBQWU5RyxXQUFXO0tBQ2pDLElBQU11RCxVQUFVO0tBQ2hCLElBQUl2RCxVQUFVb1MsV0FBVyxNQUFNO09BQzdCLElBQUl4RCxNQUNGOztPQUYyQix1QkFHc0I1TyxVQUFVc1AsTUFBTVY7V0FIdEM7V0FHdEJwRixLQUhzQjtXQUdsQjZJLE9BSGtCO1dBR1pDLGtCQUhZO1dBR0tDLGdCQUhMOztPQUk3QixPQUFPOVMsRUFBRStKLElBQ1BqRixPQUFPOE4sTUFBTTlPLFVBQ2JpUCxrQkFBa0JGLGlCQUFpQkM7WUFFaEM7T0FDTCxPQUFPaE8sT0FBT3ZFLFdBQVd1RDs7OztHQUk3QixTQUFTaVAsa0JBQWtCdEgsUUFBUXVILE1BQU07S0FDdkMsT0FBTztPQUFBLG1DQUFJMUksT0FBSjtTQUFJQSxLQUFKOzs7T0FBQSxPQUNMeEYsT0FBT2tPLE1BQ0x2SCxPQUNHK0QsUUFBUSxPQUFPLElBQ2ZTLE1BQU0sS0FDTnJCLE9BQU8sVUFBQ3dCLEtBQUtnQixLQUFLL1AsR0FBTTtTQUN2QitPLElBQUlnQixPQUFPOUcsS0FBS2pKO1NBQ2hCLE9BQU8rTztVQUNOOzs7O0dBSVgsU0FBUzVMLDBCQUEwQmhFLE9BQU87S0FDeEMsSUFBTXNELFVBQVU7S0FDaEIsSUFBTTZJLE1BQU03SSxRQUFRMkMsT0FBT2pHLE1BQU1tTTtLQUNqQyxJQUFJLENBQUM3SSxRQUFRd0gsV0FBVzlLLE1BQU0yTCxnQkFBZ0IsQ0FBQ3JJLFFBQVFoRCxPQUFPMkssT0FBT2tCLE1BQU07O09BRXpFLElBQU1zRyxTQUFTblAsUUFBUXdELGdCQUFnQnFGLEtBQUs3SSxRQUFReUcsT0FBT3VDO09BQzNELElBQUksQ0FBQzlNLEVBQUVFLFlBQVkrUyxTQUFTblAsUUFBUWhELE9BQU8ySyxPQUFPa0IsT0FBT3NHOztLQUUzRG5QLFFBQVFxRixnQkFBZ0IzSSxPQUFPLE1BQU1BLE1BQU0yTDs7O0dBRzdDLFNBQVNoRCxnQkFBZ0J3RCxLQUFLOUksU0FBU3NJLGNBQWMrRyxZQUFZO0tBQy9ELElBQUlwUCxVQUFVOzs7S0FHZCxJQUFJOUQsRUFBRW1ULFNBQVN4RyxRQUFRLENBQUMzTSxFQUFFd00sUUFBUUcsTUFBTTtPQUN0QyxJQUFJLENBQUNBLElBQUlBLE9BQU9BLElBQUlVLE9BQU87U0FDekJyTixFQUFFMEMsS0FBS2lLLElBQUlVLE9BQU8sVUFBVTdNLE9BQU87V0FDakNzRCxRQUFRcUYsZ0JBQWdCM0ksT0FBT3FELFNBQVNyRCxNQUFNMkw7O1NBRWhEO2NBQ0s7U0FDTFEsTUFBTUEsSUFBSUE7Ozs7S0FJZEEsTUFBTTdJLFFBQVEyQyxPQUFPa0c7S0FDckIsSUFBSXlHLFdBQVd6RyxJQUFJa0QsTUFBTTs7S0FFekIsSUFBSXVELFVBQVU7T0FDWnRQLFFBQVFvRixzQkFDTmtLLFNBQVMsSUFDVEEsU0FBUyxJQUNUdlAsU0FDQXNJLGNBQ0ErRztPQUVGOzs7S0FHRixJQUFJOUIsTUFBTXROLFFBQVF3RCxnQkFBZ0JxRixLQUFLN0ksUUFBUXlHLE9BQU91QztLQUN0RCxJQUFJdUcsZUFBZXJULEVBQUU4TSxJQUFJaEosUUFBUTRDLFVBQVVpRyxNQUFNOztLQUVqRCxJQUFJLENBQUM3SSxRQUFRc0gsVUFBVXVCLE1BQU07T0FDM0IsSUFBSXFFLE9BQU9uUyxRQUFRc08sS0FBS2lFO09BQ3hCdE4sUUFBUXNILFVBQVV1QixPQUFPO1NBQ3ZCMkcsVUFBVTtTQUNWbkgsY0FBY0E7U0FDZDZFLE1BQU1BOzs7O0tBSVYsSUFBSW5OLFNBQVM7T0FDWEMsUUFBUXNILFVBQVV1QixLQUFLMkcsU0FBUzFULEtBQUtpRTtPQUNyQyxJQUFJcVAsWUFBWXJQLFFBQVF1TixLQUFLLE1BQU16RTs7OztHQUl2QyxTQUFTekQsc0JBQ1BxSyxRQUNBMUMsVUFDQWhOLFNBQ0FzSSxjQUNBK0csWUFDQTtLQUNBLElBQU1wUCxVQUFVO0tBQ2hCLElBQU0wUCxVQUFVLFNBQVZBLFFBQVdwQyxLQUFLSixNQUFNeUMsU0FBWTtPQUN0QyxJQUFJLENBQUN6QyxRQUFRQSxTQUFTLEtBQUssQ0FBQ0ksTUFBTSxLQUFLLEdBQUc7T0FDMUMsSUFBSS9QLEdBQUdDLEdBQUdxTDs7T0FFVixJQUFJcUUsT0FBT0ksT0FBT3FDLFNBQVM7U0FDekIsSUFBTUMsVUFBVTdDLFdBQ1QwQyxTQURTLE9BQ0N2QyxPQUFPLEtBRFIsT0FDY0gsV0FDdkIwQyxTQUZTLE9BRUN2QyxPQUFPLEtBRlI7OztTQUtoQixJQUFJbE4sUUFBUXNILFVBQVVzSSxVQUFVO1dBQzlCLEtBQUtyUyxJQUFJLEdBQUdDLElBQUkwUCxNQUFNM1AsSUFBSUMsR0FBR0QsS0FBSzthQUNoQ3NMLE1BQU1rRSxXQUFjMEMsU0FBZCxNQUF3QmxTLElBQXhCLE9BQThCd1AsV0FBZ0IwQyxTQUE5QyxNQUF3RGxTLElBQXhEOzthQUVOeUMsUUFBUWdDLG1CQUFtQjZHOzs7U0FHL0IsS0FBS3RMLElBQUksR0FBR0MsSUFBSThQLEtBQUsvUCxJQUFJQyxHQUFHRCxLQUFLO1dBQy9Cc0wsTUFBTWtFLFdBQWMwQyxTQUFkLE1BQXdCbFMsSUFBeEIsT0FBOEJ3UCxXQUFnQjBDLFNBQTlDLE1BQXdEbFMsSUFBeEQ7O1dBRU55QyxRQUFRcUYsZ0JBQWdCd0QsS0FBSzlJLFNBQVNzSTs7OztjQUluQyxJQUFJaUYsT0FBT0osUUFBUSxJQUFJO1NBQzVCLEtBQUszUCxJQUFJMlAsT0FBTyxHQUFHMVAsSUFBSThQLEtBQUsvUCxJQUFJQyxHQUFHRCxLQUFLO1dBQ3RDc0wsTUFBTWtFLFdBQWMwQyxTQUFkLE1BQXdCbFMsSUFBeEIsT0FBOEJ3UCxXQUFnQjBDLFNBQTlDLE1BQXdEbFMsSUFBeEQ7O1dBRU55QyxRQUFRcUYsZ0JBQWdCd0QsS0FBSzlJLFNBQVNzSSxjQUFjK0c7Ozs7OztLQU0xRCxJQUFNUyxTQUFTN1AsUUFBUXdELGdCQUFnQmlNLFFBQVF6UCxRQUFReUcsT0FBT3VDO0tBQzlEOU0sRUFBRTBDLEtBQUtpUixRQUFRLFVBQUNuVCxPQUFPYSxHQUFNO09BQzNCLElBQU1zTCxNQUFNa0UsV0FBYzBDLFNBQWQsTUFBd0JsUyxJQUF4QixPQUE4QndQLFdBQWdCMEMsU0FBOUMsTUFBd0RsUyxJQUF4RDs7T0FFWnlDLFFBQVFxRixnQkFBZ0J3RCxLQUFLOUksU0FBU3NJO09BQ3RDLElBQUkrRyxZQUFZclAsUUFBUSxNQUFNLE1BQU04STs7O0tBR3RDLElBQU1pSCxjQUFpQkwsU0FBakI7S0FDTixJQUFJelAsUUFBUStHLGVBQWUrSSxjQUFjO09BQ3ZDOVAsUUFBUStHLGVBQWUrSSxhQUFhTixTQUFTMVQsS0FBSzRUO1lBQzdDO09BQ0wxUCxRQUFRK0csZUFBZStJLGVBQWU7U0FDcENOLFVBQVUsQ0FBQ0U7U0FDWHhDLE1BQU0yQyxTQUFTQSxPQUFPcFMsU0FBUzs7Ozs7R0FLckMsU0FBU3VFLG1CQUFtQjZHLEtBQUs7S0FDL0IsSUFBSTdJLFVBQVU7O0tBRWQ2SSxNQUFNN0ksUUFBUTJDLE9BQU9rRzs7S0FFckIsSUFBSXlHLFdBQVd6RyxJQUFJa0QsTUFBTTs7S0FFekIsSUFBSXVELFVBQVU7T0FDWnRQLFFBQVFpQyx3QkFBd0JxTixTQUFTLElBQUlBLFNBQVM7T0FDdEQ7OztLQUdGLElBQUl0UCxRQUFRc0gsVUFBVXVCLE1BQU03SSxRQUFRc0gsVUFBVXVCLEtBQUsyRyxXQUFXOzs7O0dBSWhFLFNBQVN2Tix3QkFBd0J3TixRQUFRMUMsVUFBVTtLQUNqRCxJQUFJL00sVUFBVTs7S0FFZEEsUUFDR3dELGdCQUFnQmlNLFFBQVF6UCxRQUFReUcsT0FDaEN1QyxNQUNBUSxRQUFRLFVBQUN1RyxNQUFNeFMsR0FBTTtPQUNwQndQLFdBQ0kvTSxRQUFRZ0MsbUJBQXNCeU4sU0FBOUIsTUFBd0NsUyxJQUF4QyxPQUE4Q3dQLFlBQzlDL00sUUFBUWdDLG1CQUFzQnlOLFNBQTlCLE1BQXdDbFMsSUFBeEM7Ozs7R0FJVixTQUFTMEYsaUJBQWlCO0tBQ3hCLElBQUlqRCxVQUFVO0tBQ2QsSUFBSUEsUUFBUWdRLFVBQVU7S0FDdEIsSUFBSWhRLFFBQVFpUSxZQUFZalEsUUFBUWlROztLQUVoQ2pRLFFBQVFpUSxhQUFhalEsUUFBUThILE1BQU1vSSxPQUNqQztPQUFBLE9BQU1sUSxRQUFReUc7UUFDZHpHLFFBQVFvRCxhQUFhNkUsS0FBS2pJLFVBQzFCOztLQUdGQSxRQUFRa0Q7S0FDUmxELFFBQVFnUSxXQUFXO0tBQ25CaFEsUUFBUW1RLGNBQWM7OztHQUd4QixTQUFTL00sYUFBYWtLLEtBQUtKLE1BQU07S0FDL0IsSUFBSWxOLFVBQVU7OztLQUdkLElBQUlBLFFBQVFtUSxlQUFlLENBQUNwVixRQUFRbU8sT0FBT29FLEtBQUtKLE9BQU87T0FDckRsTixRQUFRbVEsY0FBYztPQUN0Qi9PLE9BQU9nUCxXQUFXcFEsUUFBUXlHOztPQUUxQnpHLFFBQVFxUSxhQUFhdFYsUUFBUXNPLEtBQUtySixRQUFRMkg7O09BRTFDekwsRUFBRTBDLEtBQUtvQixRQUFRK0csZ0JBQWdCLFVBQUN1SixVQUFVekgsS0FBUTtTQUNoRCxJQUFJZ0UsTUFBTTdNLFFBQVF3RCxnQkFBZ0JxRixLQUFLN0ksUUFBUXlHLE9BQU91QztTQUN0RCxJQUFJLENBQUNqTyxRQUFRbU8sT0FBTzJELEtBQUt5RCxTQUFTcEQsT0FBTztXQUN2Q29ELFNBQVNkLFNBQVNoRyxRQUFRLFVBQUN6SixTQUFEO2FBQUEsT0FBYUEsUUFBUThNLEtBQUt5RCxTQUFTcEQ7O1dBQzdEb0QsU0FBU3BELE9BQU9uUyxRQUFRc08sS0FBS3dEOzs7O09BSWpDM1EsRUFBRTBDLEtBQUtvQixRQUFRc0gsV0FBVyxVQUFDZ0osVUFBVXpILEtBQVE7U0FDM0MsSUFBSXlILFVBQVU7V0FDWixJQUFJekQsTUFBTTdNLFFBQVF3RCxnQkFBZ0JxRixLQUFLN0ksUUFBUXlHLE9BQU91QztXQUN0RCxJQUFNdUgsY0FBY3hWLFFBQVFtTyxPQUFPMkQsS0FBSyxPQUFPLENBQUN5RCxTQUFTcEQ7V0FDekQsSUFBSSxDQUFDblMsUUFBUW1PLE9BQU8yRCxLQUFLeUQsU0FBU3BELFNBQVMsQ0FBQ3FELGFBQWE7YUFDdkRELFNBQVNkLFNBQVNoRyxRQUFRLFVBQUN6SixTQUFZO2VBQ3JDQSxRQUFROE0sS0FBS3lELFNBQVNwRCxNQUFNckUsS0FBS3lILFNBQVN4Qzs7YUFFNUN3QyxTQUFTeEMsVUFBVTthQUNuQndDLFNBQVNwRCxPQUFPblMsUUFBUXNPLEtBQUt3RDs7V0FFL0IsSUFDRXlELFNBQVNqSSxnQkFDVCxDQUFDdE4sUUFBUXFCLFlBQVl5USxRQUNyQixDQUFDMEQsZUFDRDFELFFBQVE7O2FBRVI7ZUFDQTdNLFFBQVEySCxPQUFPa0IsT0FBT2dFO29CQUNqQjthQUNMLE9BQU83TSxRQUFRMkgsT0FBT2tCOzs7OztPQUs1QixJQUFJLENBQUM5TixRQUFRbU8sT0FBT2xKLFFBQVEySCxRQUFRM0gsUUFBUXFRLGFBQWE7U0FDdkQsSUFDRXJRLFFBQVF5RyxNQUFNK0osTUFDZCxDQUFDeFEsUUFBUXdILFdBQ1R0TCxFQUFFeU8sUUFBUTNLLFFBQVFxUSxhQUNsQjtXQUNBclEsUUFBUStDO2dCQUNIO1dBQ0wsSUFBSTdHLEVBQUU2TixXQUFXL0osUUFBUTRNLGdCQUFnQjthQUN2QzVNLFFBQVE0TTs7Ozs7OztHQU9sQixTQUFTMUosbUJBQW1CO0tBQzFCLElBQUlsRCxVQUFVO0tBQ2Q5RCxFQUFFMEMsS0FBS29CLFFBQVFzSCxXQUFXLFVBQVVnSixVQUFVekgsS0FBSztPQUNqRCxJQUFJeUgsVUFBVTtTQUNaLElBQUl6RCxNQUFNN00sUUFBUXdELGdCQUFnQnFGLEtBQUs3SSxRQUFReUcsT0FBT3VDO1NBQ3RELElBQ0VzSCxTQUFTakksZ0JBQ1QsQ0FBQ3ROLFFBQVFxQixZQUFZeVEsUUFDckJBLFFBQVEsTUFDUjtXQUNBN00sUUFBUTJILE9BQU9rQixPQUFPZ0U7Ozs7OztHQU05QixTQUFTNEQsYUFBYTVILEtBQUs7S0FDekIsT0FBT0EsSUFBSTZDLFFBQVEsV0FBVzs7O0dBR2hDLFNBQVMxSSxxQkFBcUI7S0FDNUIsSUFBTWhELFVBQVU7O0tBRWhCQSxRQUFRbUgsT0FBT3JMLEtBQ2JrRSxRQUFROEgsTUFBTTRJLElBQUkscUNBQXFDLFVBQUNDLE9BQU83SSxPQUFVO09BQUEsSUFDL0RFLE9BQVNGLE1BQVRFOztPQUNSLElBQUksQ0FBQ0EsS0FBS2EsS0FBSztTQUNiYixLQUFLNEksV0FBYzVJLEtBQUtyTCxPQUF4QixNQUFnQ1QsRUFBRTJVOztPQUVwQyxJQUFNaEksTUFBTWIsS0FBSzRJLFlBQVk1USxRQUFRMkMsT0FBT3FGLEtBQUthOztPQUVqRCxJQUFJM00sRUFBRTRVLFNBQVNoSixNQUFNZ0IsYUFBYTtTQUNoQyxJQUFNaUksYUFBYU4sYUFBYTVIO1NBQ2hDLElBQU1tSSxRQUFRbEosTUFBTWdCO1NBQ3BCZCxLQUFLYyxhQUFha0k7O1NBRWxCLElBQUksQ0FBQ2hSLFFBQVFrQyxhQUFhNk8sWUFBWUMsUUFBUTtXQUM1Q2hSLFFBQVErRCxrQkFBa0JpRSxNQUFNOzs7U0FHbEMsSUFBSSxDQUFDQSxLQUFLdkwsV0FBV3VMLEtBQUt2TCxZQUFZOzs7OztTQUt0Q3VELFFBQVF3QixhQUFhc0csT0FBT2lKLFlBQVlDO1NBQ3hDbEosTUFBTW1KLE1BQU0sMEJBQTBCRjtjQUNqQztTQUNML1EsUUFBUTJCLGdCQUFnQm1HLE9BQU9lOzs7O0tBS3JDN0ksUUFBUW1ILE9BQU9yTCxLQUNia0UsUUFBUThILE1BQU00SSxJQUFJLHlCQUF5QixVQUFDQyxPQUFPN0ksT0FBT2tKLE9BQVU7T0FDbEUsSUFBTW5JLE1BQU03SSxRQUFRMkMsT0FBT21GLE1BQU1FLEtBQUthO09BQ3RDLElBQU15SCxXQUFXdFEsUUFBUXNILFVBQVV1QjtPQUNuQyxJQUFJeUgsVUFBVUEsU0FBU2QsV0FBVzs7T0FFbEN4UCxRQUFRK0IscUJBQXFCOEcsS0FBS21JOztPQUVsQyxJQUFJbEosTUFBTUUsS0FBS2tKLE1BQU07U0FDbkIsSUFBTXBDLE9BQU85TyxRQUNWd0QsZ0JBQWdCc0UsTUFBTUUsS0FBS2tKLE1BQU1sUixRQUFReUcsT0FDekN1QztTQUNIOEYsS0FBS3FDLE9BQU9ILE9BQU87U0FDbkJoUixRQUFRK0IscUJBQXFCK0YsTUFBTUUsS0FBS2tKLE1BQU1GOzs7OztHQU10RCxTQUFTeFAsYUFBYXdHLE1BQU1hLEtBQUttSSxPQUFPO0tBQ3RDLElBQU1oUixVQUFVO0tBQ2hCLElBQUksQ0FBQ2dSLFNBQVNBLFFBQVEsR0FBR0EsUUFBUTtLQUNqQyxJQUFJLENBQUNoUixRQUFROEcsWUFBWStCLE1BQU03SSxRQUFROEcsWUFBWStCLE9BQU87S0FDMUQ3SSxRQUFROEcsWUFBWStCLEtBQUttSSxTQUFTaEo7Ozs7R0FJcEMsU0FBUzlGLGFBQWEyRyxLQUFLbUksT0FBTztLQUNoQyxJQUFNaFIsVUFBVTtLQUNoQixJQUFNb1IsU0FBU3BSLFFBQVE4RyxZQUFZK0I7S0FDbkMsT0FBT3VJLFVBQVVBLE9BQU9KOzs7R0FHMUIsU0FBUzdPLGVBQWUwRyxLQUFLO0tBQzNCLElBQU03SSxVQUFVO0tBQ2hCLE9BQU85RCxFQUFFbVYsTUFBTXJSLFFBQVFxQyxlQUFld0csTUFBTTs7O0dBRzlDLFNBQVN6RyxrQkFBa0JrUCxVQUFVO0tBQ25DLElBQU10UixVQUFVO0tBQ2hCc1IsWUFBWTs7S0FFWixPQUFPcFYsRUFBRXFWLE9BQU92UixRQUFROEcsYUFBYSxVQUFDdUMsTUFBTVIsS0FBUDtPQUFBLE9BQWVBLElBQUlqTSxTQUFTMFU7Ozs7R0FHbkUsU0FBU3ZQLHFCQUFxQjhHLEtBQUttSSxPQUFPO0tBQ3hDLElBQU1oUixVQUFVO0tBQ2hCLElBQU1vUixTQUFTcFIsUUFBUW9DLGtCQUFrQnlHO0tBQ3pDM00sRUFBRTBDLEtBQUt3UyxRQUFRLFVBQUN0QyxNQUFEO09BQUEsT0FBVUEsUUFBUUEsS0FBS3FDLE9BQU9ILE9BQU87Ozs7R0FHdEQsU0FBUzNPLGVBQWV3RyxLQUFLO0tBQzNCLElBQUk3SSxVQUFVO0tBQ2QsT0FBT0EsUUFBUThHLFlBQVkrQjs7O0dBRzdCLFNBQVNsSCxnQkFBZ0JtRyxPQUFPZSxLQUFLO0tBQ25DLElBQU03SSxVQUFVO0tBQ2hCLElBQUlBLFFBQVFxSCxXQUFXd0IsTUFBTTtPQUMzQm1GLFFBQVF3RCxLQUFLLCtCQUErQjNJOztLQUU5QyxPQUFRN0ksUUFBUXFILFdBQVd3QixPQUFPZjs7O0dBR3BDLFNBQVNyRixrQkFBa0JvRyxLQUFLO0tBQzlCLElBQU03SSxVQUFVO0tBQ2hCLE9BQU9BLFFBQVFxSCxXQUFXd0I7OztHQUc1QixTQUFTbkgsZUFBZWhGLE9BQU9tTSxLQUFLO0tBQ2xDLElBQUk3SSxVQUFVO0tBQ2Q2SSxNQUFNQSxPQUFPN0ksUUFBUTJDLE9BQU9qRyxNQUFNbU07S0FDbEMsSUFBSSxDQUFDN0ksUUFBUXdDLGlCQUFpQnFHLE1BQU03SSxRQUFRb0gsVUFBVXlCLE9BQU9uTTs7O0dBRy9ELFNBQVM4RixpQkFBaUJxRyxLQUFLO0tBQzdCLElBQUk3SSxVQUFVO0tBQ2QsT0FBT0EsUUFBUW9ILFVBQVV5Qjs7O0dBRzNCLFNBQVNwSCxlQUFlb0gsS0FBS0UsWUFBWTtLQUN2QyxJQUFJL0ksVUFBVTs7S0FFZCxJQUFJNkksS0FBSztPQUNQN0ksUUFBUWdILFVBQVU2QixPQUFPRTs7OztHQUk3QixTQUFTeEcsaUJBQWlCc0csS0FBSztLQUM3QixJQUFJN0ksVUFBVTs7S0FFZCxPQUFPQSxRQUFRZ0gsVUFBVTZCOzs7R0FHM0IsU0FBUzRJLGlCQUFpQnBHLEtBQUs7S0FDN0IsT0FBT0EsSUFBSVUsTUFBTTs7O0dBR25CLFNBQVNQLHNCQUFzQkgsS0FBSztLQUFBLFlBQ2hCb0csaUJBQWlCcEcsUUFBUTtTQURUO1NBQzdCcUcsWUFENkI7O0tBRWxDLElBQU1DLFdBQVc7O0tBRWpCLE9BQU9ELFdBQVc7T0FDaEJDLFNBQVM3VixLQUFLNFY7T0FDZHJHLE1BQU1BLElBQUlLLFFBQVFnRyxXQUFaLFVBQThCQyxTQUFTbFUsU0FBUyxLQUFoRDs7T0FGVSxZQUdGZ1UsaUJBQWlCcEcsUUFBUTs7T0FIdkI7O09BR2ZxRyxZQUhlOzs7S0FNbEIsSUFBTTNGLFFBQVFWLElBQUlVLE1BQU07O0tBRXhCLE9BQU9BLFNBQVM0RixTQUFTbFUsU0FDckJzTyxNQUFNb0IsSUFBSSxVQUFDOUIsS0FBUTtPQUFBLFlBQ1FBLElBQUlVLE1BQU0sbUJBQW1CO1dBRHJDO1dBQ1oyRixZQURZO1dBQ0RWLFFBREM7O09BRWpCLE9BQU9VLFdBQVc7U0FDaEJyRyxNQUFNQSxJQUFJSyxRQUFRZ0csV0FBV0MsU0FBU1g7O1NBRHRCLGFBRUszRixJQUFJVSxNQUFNLG1CQUFtQjs7U0FGbEM7O1NBRWYyRixZQUZlO1NBRUpWLFFBRkk7O09BSWxCLE9BQU8zRjtVQUVUVTs7O0dBR04sU0FBU3JHLHlCQUF5QjJGLEtBQUtKLE9BQU87S0FDNUMsSUFBTWpMLFVBQVU7O0tBRDRCLGFBRTNCd0wsc0JBQXNCSCxRQUFRO1NBRkg7U0FFckNFLFNBRnFDOztLQUk1QyxPQUFPQSxRQUFRO09BQ2IsSUFBTXFHLFNBQVM1UixRQUFRd0QsZ0JBQWdCK0gsUUFBUU4sT0FBT2pDO09BQ3RELElBQU02SSxTQUFTM1YsRUFBRUUsWUFBWXdWLFVBQ3pCLEtBQ0ExVixFQUFFc0MsU0FBU29ULFVBQVgsT0FDSUEsU0FESixPQUVBQTtPQUNKdkcsTUFBTUEsSUFBSUssUUFBSixNQUFnQkgsU0FBaEIsV0FBK0JzRyxTQUEvQjs7T0FQTyxhQVFBckcsc0JBQXNCSCxRQUFROztPQVI5Qjs7T0FRVkUsU0FSVTs7O0tBV2YsT0FBT0Y7OztHQUdULFNBQVM3SCxnQkFBZ0I2SCxLQUFLSixPQUFPO0tBQ25DLElBQU1qTCxVQUFVOztLQUVoQixJQUFJLENBQUM5RCxFQUFFc0MsU0FBUzZNLFFBQVEsQ0FBQ25QLEVBQUV3TSxRQUFRMkMsTUFBTTtPQUN2QyxPQUFPLEVBQUVyQyxLQUFLO1dBQUEsT0FBTXFDOzs7OztLQUl0QixJQUNFLG9FQUFvRTNNLEtBQ2xFMk0sTUFFRjtPQUNBLE9BQU87U0FDTHJDLEtBQUssZUFBWTtXQUNmLElBQUksQ0FBQ3FDLEtBQUssT0FBT0E7V0FDakIsSUFBTXlHLFFBQVF6RyxJQUFJVSxNQUFNLGlCQUFpQlYsSUFBSVUsTUFBTTtXQUNuRCxJQUFJK0YsT0FBTyxPQUFPQSxNQUFNO1dBQ3hCLFFBQVF6RzthQUNOLEtBQUs7ZUFDSCxPQUFPO2FBQ1QsS0FBSztlQUNILE9BQU87YUFDVCxLQUFLO2VBQ0gsT0FBTzthQUNULEtBQUs7ZUFDSDthQUNGLEtBQUs7ZUFDSCxPQUFPO2FBQ1QsS0FBSztlQUNILE9BQU87YUFDVDtlQUNFLE9BQU8wRyxXQUFXMUc7Ozs7OztLQU01QkEsTUFBTXJMLFFBQVEyQyxPQUFPMEk7O0tBRXJCLElBQU1VLFFBQVFWLElBQUlVLE1BQU07O0tBRXhCLElBQU1oRCxhQUFhO09BQ2pCQyxLQURpQixlQUNYO1NBQ0osSUFBSWdKLFdBQVdoUyxRQUFRMEYseUJBQXlCMkYsS0FBS0o7U0FDckQsSUFBSW1DLE9BQU8vTixXQUFXNkwsTUFBTThHO1NBQzVCLElBQUlDLFFBQVFoSCxTQUFTakw7O1NBRXJCLE9BQU9pUyxTQUFTN0UsS0FBSzNQLFNBQVMsR0FBRztXQUMvQndVLFFBQVFBLE1BQU03RSxLQUFLaEM7OztTQUdyQixPQUFPNkcsU0FBU0EsTUFBTTdFLEtBQUs7O09BRzdCOEUsZUFiaUIseUJBYXNCO1NBQUEsaUZBQUo7YUFBbkJDLGlCQUF1QixPQUF2QkE7O1NBQ2QsSUFBSUgsV0FBV2hTLFFBQVEwRix5QkFBeUIyRixLQUFLSjtTQUNyRCxJQUFJbUMsT0FBTy9OLFdBQVc2TCxNQUFNOEc7U0FDNUIsSUFBSUksV0FBVztTQUNmLElBQUlILFFBQVFoSCxTQUFTakw7O1NBRXJCLE9BQU9pUyxTQUFTN0UsS0FBSzNQLFNBQVMsR0FBRztXQUMvQixJQUFJb0wsTUFBTXVFLEtBQUtoQztXQUNmZ0gsU0FBU3RXLEtBQUsrTTtXQUNkLElBQUksQ0FBQ29KLE1BQU1wSixNQUFNO2FBQ2YsSUFBSXNKLGdCQUFnQjtlQUNsQixPQUFPOzthQUVULElBQUksUUFBUXpULEtBQUswTyxLQUFLLEtBQUs7ZUFDekI2RSxNQUFNcEosT0FBTztvQkFDUjtlQUNMb0osTUFBTXBKLE9BQU87OztXQUdqQm9KLFFBQVFBLE1BQU1wSjs7O1NBR2hCLE9BQU87V0FDTHdKLEtBQUtKO1dBQ0xwSixLQUFLdUUsS0FBSztXQUNWQSxNQUFNcE4sUUFBUTJDLE9BQU95UDtXQUNyQkUsVUFBVXRTLFFBQVEyQyxPQUFPeVAsU0FBU0csT0FBT25GLEtBQUtvRixNQUFNLEdBQUc7OztPQUkzRHBKLEtBM0NpQixhQTJDYnlELEtBQW1CO1NBQUEsSUFBZDRGLFVBQWMsb0VBQUo7O1NBQ2pCLElBQUlULFdBQVdoUyxRQUFRMEYseUJBQXlCMkYsS0FBS0o7U0FDckQsSUFBSW1DLE9BQU8vTixXQUFXNkwsTUFBTThHO1NBQzVCLElBQUluRixRQUFRLFVBQVU7V0FBQSxhQUNELEtBQUtxRixjQUFjLEVBQUVDLGdCQUFnQixXQUFXO2VBQTdERSxNQURjLE9BQ2RBO2VBQUt4SixNQURTLE9BQ1RBOztXQUNYLE9BQU83SSxRQUFRaUgsU0FBUytLLFNBQVN0RyxRQUFRLFVBQVU7V0FDbkQsSUFBSTJHLEtBQUs7YUFDUCxPQUFPQSxJQUFJeEo7O2dCQUVSO1dBQUEscUJBQ2MsS0FBS3FKO2VBQWxCRyxPQURELGVBQ0NBO2VBQUt4SixRQUROLGVBQ01BOztXQUNYd0osS0FBSXhKLFNBQU9nRTs7U0FFYixJQUFJNEYsUUFBUUMsUUFBUTtXQUNsQjFTLFFBQVE4RixpQkFBaUJrTSxVQUFVL0c7V0FDbkNqTCxRQUFRK0YsYUFBYWlNOztTQUV2QixPQUFPbkY7O09BR1RPLE1BL0RpQixnQkErRFY7U0FDTCxPQUFPO1dBQ0wvQixLQUFLQTtXQUNMSixPQUFPQTtXQUNQcEMsS0FBS2tELE1BQU07Ozs7O0tBS2pCLE9BQU9oRDs7O0dBR1QsU0FBU2pELGlCQUFpQndMLFVBQVVyRyxPQUFPO0tBQ3pDLElBQU1qTCxVQUFVO0tBQ2hCOUQsRUFBRTBDLEtBQUtvQixRQUFRc0gsV0FBVyxVQUFDZ0osVUFBVXpILEtBQVE7T0FDM0MsSUFBSUEsSUFBSThKLFFBQVFyQixjQUFjLEdBQUc7U0FDL0JoQixTQUFTcEQsT0FBT25TLFFBQVFzTyxLQUFLckosUUFBUXdELGdCQUFnQnFGLEtBQUtvQyxPQUFPakM7Ozs7O0dBS3ZFLFNBQVNqRCxhQUFhdUwsVUFBVTtLQUM5QixJQUFNdFIsVUFBVTtLQUNoQixJQUFNZ1IsUUFBUU0sU0FBU3ZGLE1BQU0sYUFBYTZHLGNBQWN0QixZQUFZO0tBQ3BFLElBQU11QixLQUFLcEMsYUFBYWE7S0FDeEIsSUFBTW5ILE9BQU9qTyxFQUFFcVYsT0FBT3JWLEVBQUVpTyxLQUFLbkssUUFBUW9ILFlBQVksVUFBQzBMLEdBQUQ7T0FBQSxPQUFPQSxFQUFFakUsV0FBV2dFOztLQUNyRSxJQUFJRSxXQUFXO0tBQ2Y3VyxFQUFFMEMsS0FBS3VMLE1BQU0sVUFBQ3RCLEtBQVE7T0FDcEIsSUFBTW1LLGFBQWFoVCxRQUFRMkYsY0FBY2tELEtBQUttSTtPQUM5QyxJQUFNdkssUUFBUXpHLFFBQVF3RCxnQkFBZ0J3UCxZQUFZaFQsUUFBUXlHLE9BQU91QztPQUNqRSxJQUFJOU0sRUFBRXdNLFFBQVFqQyxRQUFRO1NBQ3BCLElBQU13TSxZQUFZL1csRUFBRXFWLE9BQU9yVixFQUFFaU8sS0FBS25LLFFBQVFvSCxZQUFZLFVBQUMwTCxHQUFEO1dBQUEsT0FDcERBLEVBQUVqRSxXQUFXaEc7OztTQUZLLDJCQUlYdEwsR0FKVztXQUtsQnJCLEVBQUUwQyxLQUFLcVUsV0FBVyxVQUFDSCxHQUFNO2FBQ3ZCQyxTQUFTalgsS0FBS2dYO2FBQ2QsSUFBTUksa0JBQWtCbFQsUUFBUTJGLGNBQWNtTixHQUFHLENBQUM5QixPQUFPelQ7YUFDekR5QyxRQUFReUgsWUFBWXlMLG1CQUFtQjs7OztTQUozQyxLQUFLLElBQUkzVixJQUFJLEdBQUdBLElBQUlrSixNQUFNaEosUUFBUUYsS0FBSztXQUFBLE1BQTlCQTs7Y0FPSixJQUFJLENBQUN3VixTQUFTblcsU0FBU2lNLE1BQU07U0FDbEM3SSxRQUFReUgsWUFBWXVMLGNBQWM7Ozs7O0dBS3hDLFNBQVN2UCxhQUFhN0QsT0FBTztLQUMzQixJQUFJSSxVQUFVO0tBQ2QsSUFBSTZJLE1BQU03SSxRQUFRMkMsT0FBTy9DLE1BQU1pSjs7S0FFL0JqSixNQUFNdVQsY0FBYztPQUNsQmhGLFFBQVEsZ0JBQVVpRixHQUFHQyxJQUFJO1NBQ3ZCLElBQUkvQyxXQUFXdFEsUUFBUStHLGVBQWtCOEIsTUFBMUI7U0FDZnlILFNBQVNkLFNBQVNoRyxRQUFRLFVBQUN6SixTQUFZO1dBQ3JDQSxRQUFRdVEsU0FBU3BELE1BQU1vRCxTQUFTcEQsTUFBTTs7Ozs7S0FLNUNsTixRQUFRMkUsZUFBZS9FOzs7R0FHekIsU0FBUytFLGVBQWVqRixTQUFTUSxZQUFZO0tBQzNDLElBQUlGLFVBQVU7OztLQUdkLElBQUlFLFlBQVk7S0FDaEJoRSxFQUFFMEMsS0FBS2MsUUFBUTZKLE9BQU92SixRQUFRNkQsYUFBYW9FLEtBQUtqSTs7O0dBR2xELFNBQVNnRSxpQkFBaUJ2RSxXQUFXO0tBQ25DLElBQUlPLFVBQVU7O0tBRWRQLFVBQVU5QyxPQUFPO0tBQ2pCOEMsVUFBVWlLLFlBQVk7O0tBRXRCLElBQUk0SixPQUFPLEtBQUtwWCxFQUFFZ08sT0FBT3pLLFVBQVU4SixPQUFPLFVBQVU5TDs7S0FFcER2QixFQUFFMEMsS0FBS2EsVUFBVThKLE9BQU8sVUFBVTdNLE9BQU9hLEdBQUc7T0FDMUN5QyxRQUFRNkQsYUFBYW5IO09BQ3JCK0MsVUFBVThKLE1BQU1oTSxLQUFLO1NBQ25CWixNQUFNO1NBQ04rTSxXQUFXLFlBQVk0SjtTQUN2Qi9KLE9BQU8sQ0FBQzdNOzs7OztHQUtkLFNBQVN1SCxnQkFBZ0J2SCxPQUFPO0tBQzlCQSxNQUFNNlcsaUJBQWlCO09BQ3JCLG9CQUFvQjtPQUNwQix1QkFBdUI7T0FDdkJDLFVBQVU7T0FDVjlXLE1BQU1NLE9BQU9DOztLQUVmUCxNQUFNQyxPQUFPOzs7R0FHZixTQUFTdUgsY0FBY3hILE9BQU87S0FDNUJBLE1BQU1DLE9BQU87OztHQUdmLFNBQVN3SCxrQkFBa0J6SCxPQUFPO0tBQ2hDQSxNQUFNQyxPQUFPOzs7R0FHZixTQUFTeUgsV0FBVzFILE9BQU87S0FDekJBLE1BQU1DLE9BQU87OztHQUdmLFNBQVM4SCxnQkFBZ0IvSCxPQUFPO0tBQzlCLElBQUlzRCxVQUFVO0tBQ2R0RCxNQUFNQyxPQUFPO0tBQ2JELE1BQU0rVyxPQUFPL1csTUFBTStXLFFBQVE7S0FDM0IvVyxNQUFNNk0sTUFBTUMsUUFBUXhKLFFBQVE2RCxhQUFhb0UsS0FBS2pJO0tBQzlDdEQsTUFBTTZNLFFBQVEsQ0FDWjtPQUNFNU0sTUFBTTtPQUNONE0sT0FBTzdNLE1BQU02TTtPQUNiOU0sV0FBVyxZQUFZdUQsUUFBUTJDLE9BQU9qRyxNQUFNbU0sT0FBTzs7OztHQUt6RCxTQUFTakYscUJBQXFCbEgsT0FBTztLQUNuQyxJQUFJc0QsVUFBVTtLQUNkdEQsTUFBTUMsT0FBTztLQUNiLElBQUksQ0FBQ0QsTUFBTWlQLFNBQVM7T0FDbEJqUCxNQUFNaVAsVUFBVTtPQUNoQnpQLEVBQUUwQyxLQUFLbEMsTUFBTStCLE1BQU0sVUFBQzRNLEtBQUt2TCxNQUFOO1NBQUEsT0FBZ0JwRCxNQUFNaVAsUUFBTixVQUFzQjdMLFFBQVV1TDs7O0tBRXJFckwsUUFBUUcsZUFBZXpEOzs7R0FHekIsU0FBU2dILHFCQUFxQmhILE9BQU87S0FDbkMsSUFBSXNELFVBQVU7S0FDZHRELE1BQU1DLE9BQU87S0FDYixJQUFJLENBQUNELE1BQU1pUCxTQUFTO09BQ2xCalAsTUFBTWlQLFVBQVU7T0FDaEJ6UCxFQUFFMEMsS0FBS2xDLE1BQU0rQixNQUFNLFVBQUM0TSxLQUFLdkwsTUFBTjtTQUFBLE9BQWdCcEQsTUFBTWlQLFFBQU4sVUFBc0I3TCxRQUFVdUw7OztLQUVyRXJMLFFBQVFHLGVBQWV6RDs7O0dBR3pCLFNBQVN3SSxtQkFBbUJ4SSxPQUFPO0tBQ2pDLElBQUlzRCxVQUFVO0tBQ2R0RCxNQUFNQyxPQUFPO0tBQ2IsSUFBSSxDQUFDRCxNQUFNaVAsU0FBUztPQUNsQmpQLE1BQU1pUCxVQUFVO09BQ2hCelAsRUFBRTBDLEtBQUtsQyxNQUFNK0IsTUFBTSxVQUFDNE0sS0FBS3ZMLE1BQU47U0FBQSxPQUFnQnBELE1BQU1pUCxRQUFOLFVBQXNCN0wsUUFBVXVMOzs7S0FFckVyTCxRQUFRRyxlQUFlekQ7OztHQUd6QixTQUFTeUksaUJBQWlCekksT0FBTztLQUMvQixJQUFJc0QsVUFBVTtLQUNkdEQsTUFBTUMsT0FBTzs7O0dBR2YsU0FBUzRILGNBQWM3SCxPQUFPO0tBQzVCQSxNQUFNQyxPQUFPOzs7R0FHZixTQUFTNkgsb0JBQW9Ca1AsUUFBUTtLQUNuQyxJQUFJMVQsVUFBVTtLQUNkMFQsT0FBTy9XLE9BQU87S0FDZCxJQUFJK1csT0FBT0MsV0FBVztPQUNwQkQsT0FBT0UsV0FBVyxZQUFZMVgsRUFBRTJYLE9BQU8sSUFBSUgsT0FBTzdXLFNBQVNZOzs7O0dBSS9ELFNBQVM0RyxZQUFZbUosTUFBTTtLQUN6QixJQUFJeE4sVUFBVTtLQUNkd04sS0FBSzdRLE9BQU87O0tBRVosSUFBSTZRLEtBQUt4USxPQUFPQyxXQUFXLGdCQUFnQjtPQUN6Q3VRLEtBQUtzRyxVQUFVO09BQ2Z0RyxLQUFLdUcsWUFBWTs7T0FFakJ2RyxLQUFLd0csaUJBQWlCLFVBQUNuSCxLQUFRO1NBQzdCLElBQUksQ0FBQ0EsS0FBSzs7U0FFVixJQUFJb0gsSUFBSTVGLE9BQU94Qjs7U0FFZixPQUFPM1EsRUFBRW9TLElBQUlwUyxFQUFFZ1ksU0FBU0QsRUFBRUUsU0FBUyxLQUFLRixFQUFFRzs7O09BRzVDNUcsS0FBSzZHLGNBQWMsVUFBQ3hILEtBQVE7U0FDMUIsSUFBSSxDQUFDQSxLQUFLOztTQUVWLElBQUl5SCxJQUFJQyxTQUFTMUg7U0FDakIsSUFBSXNILFFBQVFqWSxFQUFFdVMsTUFBTTZGLElBQUk7U0FDeEIsSUFBSUYsVUFBVUUsSUFBSTs7U0FFbEIsT0FBT2pHLFNBQ0ptRyxRQUFRLE9BQ1JsRyxJQUFJLFNBQVM2RixPQUNiN0YsSUFBSSxXQUFXOEY7OztPQUdwQjVHLEtBQUtpSCxnQkFBZ0IsVUFBQzVILEtBQVE7U0FDNUIsSUFBSSxDQUFDQSxLQUFLOztTQUVWLE9BQU9XLEtBQUs2RyxZQUFZeEgsS0FBSzVQLE9BQU91USxLQUFLa0g7OztPQUczQ2xILEtBQUttSCxhQUFhLFVBQUM5SCxLQUFRO1NBQ3pCLElBQUksQ0FBQ0EsS0FBSzs7U0FFVixJQUFJZCxRQUFRYyxJQUFJZCxNQUFNO1NBQ3RCLElBQUksQ0FBQ0EsT0FBTzs7U0FFWixJQUFJb0ksUUFBUWpZLEVBQUVvUyxJQUNadkMsTUFBTSxPQUFPLE9BQU8sSUFBSUEsTUFBTSxJQUM5QkEsTUFBTSxPQUFPLE1BQU0sSUFBSTtTQUV6QixJQUFJcUksVUFBVXJJLE1BQU0sTUFBTTs7U0FFMUIsSUFBSXFJLFFBQVEzVyxXQUFXLEdBQUcyVyxXQUFXOztTQUVyQyxPQUFPbFksRUFBRW9TLElBQUlwUyxFQUFFZ1ksU0FBU0MsT0FBTyxLQUFLQzs7Ozs7R0FLMUMsU0FBU1EsaUJBQWlCQyxRQUFRO0tBQ2hDLElBQUluTSxVQUFVbU0sT0FBT3BNLG9CQUFvQjtLQUN6QyxPQUNFb00sT0FBT0MsaUJBQ04sQ0FBQ3BNLFVBQVVtTSxPQUFPN1gsT0FBT3VNLE1BQU01TSxPQUFPa1ksT0FBTzdYLE9BQU9MLFVBQVUsWUFDN0Q7OztHQUlOLFNBQVNvWSxzQkFBc0JGLFFBQVFoSSxLQUFLaFEsVUFBVTtLQUNwREEsV0FBV0EsWUFBWWdZLE9BQU9HO0tBQzlCLElBQUlDLFVBQVVMLGlCQUFpQkM7S0FDL0IsSUFBSUssY0FBY0QsVUFDZC9ZLEVBQUVpWixXQUNGalosRUFBRWtaLGFBQWFsWixFQUFFQyxNQUFNO0tBQzNCLElBQUlrWixTQUFTSixVQUNUL1ksRUFBRW9aLFFBQ0FwWixFQUFFcVosUUFBUXJaLEVBQUVnSyxNQUFNckosV0FDbEJYLEVBQUVxWixRQUFRclosRUFBRWtOLEtBQUssSUFBSTZMLFVBQ3JCQyxlQUVGaFosRUFBRW9aLFFBQVFwWixFQUFFcVosUUFBUXJaLEVBQUVnSyxNQUFNckosV0FBV3FZO0tBQzNDLElBQUlMLE9BQU9wTSxvQkFBb0IsU0FBUztPQUN0QyxJQUFJLENBQUNvRSxPQUFPLENBQUMzUSxFQUFFd00sUUFBUW1FLE1BQU07T0FDN0IsT0FBT0EsSUFBSU0sSUFBSWtJLFFBQVE5RCxPQUFPLFVBQUNuRixHQUFEO1NBQUEsT0FBT0EsTUFBTUk7O1lBQ3RDO09BQ0wsT0FBTzZJLE9BQU94STs7OztHQUlsQixTQUFTaEksZ0JBQWdCbkksT0FBTztLQUM5QkEsTUFBTThZLGFBQWE7S0FDbkI5WSxNQUFNQyxPQUFPOzs7R0FHZixTQUFTaUksY0FBY2lRLFFBQVE7S0FDN0IsSUFBTTdVLFVBQVU7S0FDaEIsSUFBTWhELFNBQVM2WCxPQUFPN1g7O0tBRXRCLElBQUk2WCxPQUFPL1gsbUJBQW1CK1gsT0FBT2hZLFVBQVU7T0FDN0NnWSxPQUFPRyxjQUFjO1NBQUEsT0FDbkJILE9BQU9oWSxZQUFZbUQsUUFBUWhELE9BQU95QixLQUFLb1csT0FBTy9YOzs7T0FFaEQrWCxPQUFPWSxTQUFTLFVBQVU1SSxLQUFLN0UsTUFBTTJJLE9BQU8rRSxRQUFROztTQUVsRCxJQUFJM00sYUFBYS9JLFFBQVF3RCxnQkFBZ0J3RSxLQUFLYSxLQUFLN0ksUUFBUXlHO1NBQzNELElBQUlrSyxVQUFVLFlBQVk7V0FDeEIsSUFBSWdGLFNBQVNaLHNCQUFzQkYsUUFBUTlMLFdBQVdDO1dBQ3RELElBQUkyTSxXQUFXbkosV0FBV2tKLE9BQU9DOzs7OztLQUt2QyxJQUFJZCxPQUFPOVgsZUFBZTtPQUN4QixJQUFNNlksY0FBY2YsT0FBTzlYLGNBQWM0SztPQUN6QyxJQUFNa08sYUFBYTNaLEVBQUVpTyxLQUFLeUw7T0FDMUJmLE9BQU90SyxlQUFlO09BQ3RCc0ssT0FBT2lCLGlCQUFpQixDQUFDLENBQUNqQixPQUFPOVgsY0FBYzRLLE9BQU9vTztPQUN0RGxCLE9BQU9tQixjQUFjbkIsT0FBT29CLGNBQWM7T0FDMUNwQixPQUFPcUIsYUFBYSxVQUFDQyxHQUFELFFBQXdCO1NBQUEsSUFBbEJKLGNBQWtCLE9BQWxCQTs7U0FDeEIsSUFBTXBPLFNBQVN6TCxFQUFFMlosWUFBWS9LLE9BQU8sVUFBQ3dCLEtBQUt6RCxLQUFRO1dBQ2hELElBQUlBLFFBQVEsS0FBSzthQUNmeUQsSUFBSXNKLFlBQVkvTSxRQUFRc047a0JBQ25CLElBQUl0TixRQUFRLGVBQWU7YUFDaEMsSUFBSWtOLGFBQWF6SixJQUFJc0osWUFBWS9NLFFBQVE7a0JBQ3BDO2FBQ0wsSUFBTXdDLE1BQU1yTCxRQUFRdUYsa0JBQ2xCcVEsWUFBWS9NLE1BQ1pnTSxPQUFPL0w7YUFFVCxJQUFJK0QsTUFBTTtpQkFDUnVKLFlBQVkvSyxJQUFJYyxNQUFNO2FBTm5CO2FBQUE7YUFBQTs7YUFBQTtlQU9MLHFCQUFnQmlLLFVBQWhCLDZIQUEyQjtpQkFBQSxJQUFsQi9LLE9BQWtCOztpQkFDekJ3QixNQUFNN00sUUFBUXdELGdCQUFnQjZILEtBQUlxQyxRQUFRMUU7aUJBQzFDLElBQUk2RCxLQUFLO21CQUNQOzs7ZUFWQztlQUFBO2VBQUE7dUJBQUE7ZUFBQTtpQkFBQTttQkFBQTs7eUJBQUE7aUJBQUE7bUJBQUE7Ozs7O2FBYUxQLElBQUl6RCxPQUFPZ0U7O1dBRWIsT0FBT1A7WUFDTjtTQUNILE9BQU92TCxJQUFJaUksSUFBSTtXQUNiL0ssS0FBSzRXLE9BQU85WCxjQUFja0I7V0FDMUIwSjs7OztPQUlKLElBQUksQ0FBQ3pMLEVBQUU0VSxTQUFTK0QsT0FBT29CLFlBQ3JCcEIsT0FBT29CLFlBQVlKLFdBQVdwWSxTQUFTLElBQUk7T0FDN0MsSUFBSSxDQUFDdkIsRUFBRStNLElBQUk0TCxRQUFRLGtCQUNqQkEsT0FBT3dCLGdCQUFnQixDQUFDLENBQUN4QixPQUFPb0I7O09BRWxDcEIsT0FBT1ksU0FBUyxVQUFVNUksS0FBSzdFLE1BQU0ySSxPQUFPK0UsUUFBUTtTQUNsRCxJQUFJL0UsVUFBVSxZQUFZO1dBQ3hCK0UsT0FBTzdJOzs7OztLQUtiLElBQUksQ0FBQzNRLEVBQUU0VSxTQUFTK0QsT0FBT29CLFlBQVlwQixPQUFPb0IsWUFBWTs7S0FFdEQsSUFBSWpaLE9BQU91TSxPQUFPO09BQ2hCLElBQUl0QyxXQUFXO09BQ2YvSyxFQUFFMEMsS0FBSzVCLE9BQU91TSxNQUFNNEIsWUFBWSxVQUFVbk8sUUFBUTZMLEtBQUs7U0FDckQsSUFBSTlOLFFBQVFxUCxVQUFVcE4sT0FBT3FELFVBQVU7V0FDckM0RyxTQUFTbkwsS0FBSzthQUNaK00sS0FBS0E7YUFDTHhJLFNBQVNyRCxPQUFPcUQ7Ozs7T0FJdEIsSUFBSTRHLFNBQVN4SixRQUFRO1NBQ25Cb1gsT0FBT3lCLFFBQVEsVUFBVXpKLEtBQUs3RSxNQUFNMkksT0FBTztXQUN6QyxJQUFJOUQsSUFBSXZRLFNBQVNxVSxVQUFVLGFBQWE7YUFDdEN6VSxFQUFFMEMsS0FBS3FJLFVBQVUsVUFBVW5ILE1BQU07ZUFDL0IsSUFBSSxDQUFDK00sSUFBSXZRLE1BQU13RCxLQUFLK0ksTUFBTWdFLElBQUl2USxNQUFNd0QsS0FBSytJLE9BQU8vSSxLQUFLTzs7Ozs7OztLQU8vRCxJQUFJd1UsT0FBTzBCLGVBQWU7T0FDeEIxQixPQUFPMkIsZ0JBQWdCeFcsUUFBUStFLGdCQUFnQjhQLE9BQU8wQjs7O0tBR3hELElBQUksQ0FBQzFCLE9BQU9sWSxLQUFLQyxTQUFTLG9CQUFvQjtPQUM1QyxJQUFJaVksT0FBT3RMLE9BQU87U0FDaEJzTCxPQUFPNEIsZUFBZTs7U0FFdEIsSUFBSTVCLE9BQU90TCxNQUFNLEdBQUc1TSxTQUFTLGFBQWE7V0FDeEMsSUFBSWtZLE9BQU90TCxNQUFNOUwsU0FBUyxHQUFHO2FBQzNCdkIsRUFBRTBDLEtBQUtpVyxPQUFPdEwsT0FBTyxVQUFDaE0sR0FBRDtlQUFBLE9BQVFBLEVBQUVtWixrQkFBa0I7O2FBQ2pEN0IsT0FBT3RMLFFBQVEsQ0FDYjtlQUNFNU0sTUFBTTtlQUNONE0sT0FBT3NMLE9BQU90TDs7OztXQUtwQnZKLFFBQVE4RCxnQkFBZ0IrUTs7O1NBRzFCQSxPQUFPbFksT0FBTztTQUNka1ksT0FBTzZCLGtCQUFrQjtjQUNwQjtTQUNMLElBQUksQ0FBQzdCLE9BQU84QixnQkFBZ0I7V0FDMUI5QixPQUFPOEIsaUJBQ0w5QixPQUFPaE0sUUFBUSxTQUNYLFNBQ0FnTSxPQUFPcE0sb0JBQW9CLFdBQzNCb00sT0FBTzdYLE9BQU80WixhQUFhLElBQzNCLFNBQ0E7O1NBRVIvQixPQUFPbFksT0FBTzs7O09BR2hCLElBQUlrWSxPQUFPL1gsaUJBQWlCO1NBQzFCa0QsUUFBUThILE1BQU00SSxJQUFJLHVCQUF1QixVQUFDMEMsR0FBRzNVLE1BQVM7V0FDcEQsSUFBSUEsS0FBS29XLE9BQU8vWCxrQkFBa0I7YUFDaEMsSUFBSWlNLGFBQWEvSSxRQUFRd0QsZ0JBQWdCcVIsT0FBT2hNLEtBQUs3SSxRQUFReUc7YUFDN0QsSUFBSW9HLE1BQU05RCxXQUFXQzthQUNyQixJQUFJNkQsUUFBUUwsV0FBVztlQUNyQixJQUFJcUssUUFBUTlCLHNCQUNWRixRQUNBaEksS0FDQXBPLEtBQUtvVyxPQUFPL1g7ZUFFZCxJQUFJK1osVUFBVXJLLGFBQWN0USxFQUFFd00sUUFBUW1PLFVBQVUzYSxFQUFFeU8sUUFBUWtNLFFBQ3hEOU4sV0FBV0s7Ozs7OztPQU1yQnBKLFFBQVFxRixnQkFDTndQLE9BQU9oTSxLQUNQLFVBQVVnRSxLQUFLO1NBQ2IsSUFBSTdFLE9BQ0ZoSSxRQUFRb0ksWUFBWXBJLFFBQVFvSSxTQUFTcEksUUFBUTJDLE9BQU9rUyxPQUFPaE07U0FDN0QsSUFBSWIsUUFBUUEsS0FBSzhPLFdBQVc5TyxLQUFLOE87VUFFbkNqQyxPQUFPeE07Ozs7R0FLYixTQUFTckQsY0FBYytSLFFBQVE7S0FDN0JBLE9BQU9wYSxPQUFPOzs7R0FHaEIsU0FBUzJILFlBQVk5RSxNQUFNO0tBQ3pCQSxLQUFLa0ssWUFBWTs7O0dBR25CLFNBQVMvRixlQUFlcVQsU0FBUztLQUMvQixJQUFJaFgsVUFBVTtLQUNkZ1gsUUFBUXJhLE9BQU87S0FDZnFhLFFBQVFDLGFBQWFqWCxRQUFRK0UsZ0JBQWdCaVMsUUFBUVQsZUFBZTs7O0dBR3RFLFNBQVN4UixnQkFBZ0JtUyxLQUFLQyxZQUFZO0tBQ3hDLElBQUluWCxVQUFVOztLQUVkLElBQUlvWCxZQUFZbFc7S0FDaEIsT0FBTyxVQUFVNEcsT0FBT2dCLFlBQVk7T0FDbEMsSUFBSXFPLFlBQVk7U0FDZCxJQUFJcGMsUUFBUXFQLFVBQVV0QixhQUFhO1dBQ2pDaEIsUUFBUTVMLEVBQUVpUixJQUFJckYsT0FBTyxVQUFVZSxLQUFLO2FBQ2xDLE9BQU9BLFFBQVEsZUFBZUMsYUFBYUQ7OztTQUcvQ2YsUUFBUTlILFFBQVF3RCxnQkFBZ0JzRSxPQUFPOUgsUUFBUXlHLE9BQU91Qzs7T0FFeEQsT0FBT29PLFVBQVVGLEtBQUtwUDs7OztHQUkxQixTQUFTaEQsYUFBYXVTLE9BQU87S0FDM0IsSUFBSXJYLFVBQVU7S0FDZHFYLE1BQU0xYSxPQUFPO0tBQ2IwYSxNQUFNOU4sTUFBTUMsUUFBUSxVQUFVOE4sS0FBSztPQUNqQyxLQUFLLElBQUkvWixJQUFJLEdBQUdBLElBQUk4WixNQUFNRSxRQUFROVosUUFBUUYsS0FBSztTQUM3Q3JCLEVBQUUwTCxPQUFPMFAsSUFBSS9OLE1BQU1oTSxJQUFJOFosTUFBTUUsUUFBUWhhO1NBQ3JDeUMsUUFBUTZELGFBQWF5VCxJQUFJL04sTUFBTWhNOzs7OztHQUtyQyxTQUFTNkMscUJBQXFCb1gsZUFBZTtLQUMzQyxJQUFNeFgsVUFBVTs7S0FFaEIsSUFBSXlYLGNBQWM7S0FIeUI7S0FBQTtLQUFBOztLQUFBO09BSTNDLHNCQUFpQkQsY0FBY2pPLE1BQS9CLGtJQUFzQztTQUFBLElBQTdCd0csT0FBNkI7O1NBQ3BDLElBQUlBLEtBQUswSCxhQUFhO1dBQ3BCQSxjQUFjMUg7Z0JBQ1QsSUFBSUEsS0FBS3hHLE9BQU87V0FDckJrTyxjQUFjdmIsRUFBRWdLLEtBQUs2SixLQUFLeEcsT0FBTzs7U0FFbkMsSUFBSWtPLGFBQWE7V0FDZjs7Ozs7O09BWHVDO09BQUE7T0FBQTtlQUFBO09BQUE7U0FBQTtXQUFBOztpQkFBQTtTQUFBO1dBQUE7Ozs7O0tBaUIzQyxJQUFNQyxZQUFZMVgsUUFBUXdELGdCQUN4QmdVLGNBQWN0RyxNQUNkbFIsUUFBUXlHO0tBRVYsSUFBSSxDQUFDaVIsVUFBVTFPLE9BQU8wTyxVQUFVdE8sSUFBSTs7S0FFcENsTixFQUFFMEMsS0FBSzRZLGNBQWNqTyxPQUFPLFVBQUN3RyxNQUFTO09BQ3BDLElBQUlBLEtBQUswSCxnQkFBZ0IsTUFBTTs7T0FFL0IsSUFBTTVPLE1BQU0zTSxFQUFFd00sUUFBUXFILEtBQUtsSCxPQUFPa0gsS0FBS2xILE1BQU14SixXQUFXNkwsTUFBTTZFLEtBQUtsSDtPQUNuRSxJQUFNOE8sYUFBYXpiLEVBQUVxUSxLQUFLMUQ7O09BRTFCa0gsS0FBSzZILGNBQWMsVUFBQzVHLE9BQVU7U0FDNUIsSUFBTTZHLFdBQVc3WCxRQUNkd0QsZ0JBRGMsV0FDV2dVLGNBQWN0RyxPQUR6QixNQUNpQ0YsUUFEakMsY0FFZGhJO1NBQ0gsSUFBTThPLE9BQU9ELFlBQVlBLFNBQVNqYixTQUFTK2E7U0FDM0MsT0FBT0c7OztPQUdULElBQU1yYjtPQUNOc1QsS0FBS3RULFlBQVlzVCxLQUFLdFQsWUFBTCxNQUNUc1QsS0FBS3RULFlBREksVUFDYUEsWUFDMUJBOzs7S0FHTixJQUFJZ0ssUUFBUXpHLFFBQ1R3RCxnQkFBZ0J4RCxRQUFRMkMsT0FBTzZVLGNBQWMzTyxNQUFNN0ksUUFBUXlHLE9BQzNEdUM7S0FDSCxJQUFJK08sWUFBWS9YLFFBQVEyQyxPQUFPOFUsWUFBWTVPO0tBQzNDM00sRUFBRTBDLEtBQUs2SCxPQUFPLFVBQVV1UixNQUFNemEsR0FBRztPQUMvQixJQUFJMGEsbUJBQW1CalksUUFBUTJGLGNBQWNvUyxXQUFXeGE7T0FDeEQsSUFBSTJhLGNBQWNsWSxRQUFRd0QsZ0JBQ3hCeVUsa0JBQ0FqWSxRQUFReUc7T0FFVixJQUFJLENBQUN5UixZQUFZbFAsT0FBT2tQLFlBQVk5TyxJQUFJOzs7O0dBSTVDLFNBQVN2RCxtQkFBbUJzUyxTQUFTO0tBQ25DLElBQU1uWSxVQUFVO0tBQ2hCQSxRQUFRNE0sZ0JBQWdCMVEsRUFBRWtjLFNBQVMsVUFBQy9QLGNBQWlCO09BQ25ELElBQU1WLHNCQUNEL0wsaUJBQWlCSSxlQUFlZ0UsUUFBUXVJLHNCQUN4Q3ZJLFFBQVEySDtPQUViLElBQUkwUSxPQUFPbmMsRUFBRUMsS0FDWGlGLE9BQU9pWCxLQUFLclksUUFBUWhELE9BQU8ySyxRQUFRQSxRQUFRLE9BQzNDO09BRUYsSUFBSXdDOztPQUVKLElBQUksQ0FBQ2pPLEVBQUV5TyxRQUFRME4sU0FBU2hRLGNBQWM7U0FDcEMsSUFBSUEsY0FBY1YsT0FBT1UsZUFBZUEsa0JBQ25DO1dBQ0g4QixPQUFPak8sRUFBRWlPLEtBQUtrTzs7V0FFZCxJQUFJbE8sS0FBSzFNLFNBQVMsR0FBRzthQUNuQjRhLE9BQU9uYyxFQUFFQyxLQUFLa2MsTUFBTW5jLEVBQUVvYzthQUN0Qm5PLE9BQU9qTyxFQUFFaU8sS0FBS2tPOzs7V0FHaEIxUSxPQUFPVSxlQUFlbk0sRUFBRXlNLE1BQU13Qjs7O1NBR2hDLElBQUksQ0FBQ3hDLE9BQU9VLGNBQWM7V0FDeEJnUSxPQUFPalgsT0FBT2lYLEtBQ1oxUSxRQUNBekwsRUFBRUMsS0FBSzZELFFBQVFoRCxPQUFPMkssUUFBUSxDQUFDLGdCQUFnQjtXQUVqRHdDLE9BQU9qTyxFQUFFaU8sS0FBS2tPOztXQUVkMVEsT0FBT1UsZUFBZW5NLEVBQUV5TSxNQUFNd0I7OztTQUdoQ2dPLFFBQVF4USxRQUFRNFEsS0FBSyxVQUFVdmIsUUFBUTtXQUNyQ2dELFFBQVFpRixxQkFBcUJqSTs7O1FBR2hDOztLQUVIZ0QsUUFBUStWLGNBQWM3WixFQUFFa2MsU0FBUyxZQUFZO09BQzNDRCxRQUNFamMsRUFBRTBMLE9BQU81SCxRQUFRaEQsT0FBTzJLLFFBQVEsRUFBRVUsY0FBYyxrQkFDaERrUSxLQUFLLFVBQVV2YixRQUFRO1NBQ3ZCZ0QsUUFBUWlGLHFCQUFxQmpJOztRQUU5Qjs7S0FFSGdELFFBQVFtSCxPQUFPckwsS0FDYmtFLFFBQVE4SCxNQUFNNEksSUFBSSxpQkFBaUIxUSxRQUFRK1Y7OztHQUkvQyxTQUFTOVEscUJBQXFCakksUUFBUTtLQUNwQyxJQUFJZ0QsVUFBVTtLQUNkLElBQUloRCxPQUFPcWIsTUFBTTtPQUNmclksUUFBUStDO09BQ1IvQyxRQUFRaEQsT0FBTzJLLFNBQVMzSyxPQUFPMks7T0FDL0IsSUFBSS9MLGlCQUFpQjRjLGVBQWU7U0FDbEM1YyxpQkFBaUI0YyxjQUFjeGI7OztPQUdqQyxJQUFJeWIsT0FBT3RPLEtBQUtuTixPQUFPcWIsS0FBSzVaLE1BQU1oQixTQUFTLEdBQUc7U0FDNUN1QyxRQUFROEgsTUFBTTBDLFdBQVcsdUJBQXVCeE4sT0FBT3FiLEtBQUs1WjtTQUM1RHZDLEVBQUUwQyxLQUFLNUIsT0FBT3FiLEtBQUs1WixNQUFNLFVBQUNBLE1BQU1xQixNQUFTO1dBQ3ZDLElBQ0VyQixRQUNBQSxLQUFLQSxRQUNMLENBQUN2QyxFQUFFeU8sUUFBUTNLLFFBQVFoRCxPQUFPeUIsS0FBS3FCLE1BQU1yQixTQUNyQyxDQUFDQSxLQUFLaWEsT0FDTjthQUNBamEsS0FBS0EsT0FBT3VCLFFBQVFoRCxPQUFPeUIsS0FBS3FCLE1BQU1yQixLQUFLOFQsT0FBTzlULEtBQUtBOztXQUV6RHVCLFFBQVFoRCxPQUFPeUIsS0FBS3FCLFFBQVFyQjtXQUM1QixJQUFJdUIsUUFBUXVILGdCQUFnQnpILE9BQU87YUFDakM1RCxFQUFFMEMsS0FBS29CLFFBQVF1SCxnQkFBZ0J6SCxPQUFPLFVBQUM2WSxXQUFjO2VBQ25EQSxVQUFVblAsUUFBUSxVQUFDd0QsVUFBYTtpQkFDOUJoTixRQUFROEMsY0FDTmtLLFNBQVN0USxPQUNUc1EsU0FBU2xOLE1BQ1RrTixTQUFTM0I7Ozs7Ozs7T0FRckIsSUFBTWxCLE9BQU87O09BRWIsSUFBSXNPLE9BQU90TyxLQUFLbk4sT0FBT3FiLEtBQUtyYixRQUFRUyxTQUFTLEdBQUc7U0FDOUN1QyxRQUFROEgsTUFBTTBDLFdBQVcseUJBQXlCeE4sT0FBT3FiLEtBQUtyYjtTQUM5RGQsRUFBRTBDLEtBQUs1QixPQUFPcWIsS0FBS3JiLFFBQVEsVUFBVUEsUUFBUTZMLEtBQUs7V0FDaEQrUCxnQkFBZ0I1YixRQUFRNkwsS0FBS3NCO1dBQzdCLElBQU0wTyxVQUFVM2MsRUFBRXFWLE9BQU9wSCxNQUFNLFVBQUMySSxHQUFEO2FBQUEsT0FBTzVXLEVBQUUyUyxXQUFXaUUsR0FBR2pLOztXQUN0RDNNLEVBQUUwQyxLQUFLaWEsU0FBUyxVQUFDaFEsS0FBUTthQUN2QixJQUFNZCxRQUFRN0wsRUFBRTRjLFFBQUYsQ0FDWjlZLFFBQVF3QyxpQkFBaUJxRyxNQURiLDBCQUVSN0ksUUFBUW1DLGVBQWUwRyxRQUFRO2FBRXJDM00sRUFBRTBDLEtBQUttSixPQUFPLFVBQUNDLE1BQVM7ZUFDdEIsSUFBTStRLGFBQWEvUSxLQUFLaEw7ZUFDeEIsSUFBTWdjLFlBQVloWixRQUFRNEMsVUFBVWlHLEtBQWxCLG9CQUNmN0wsT0FBTzZMLEtBQU03TDtlQUVoQixJQUFJK2IsV0FBV0UsWUFBWSxDQUFDRCxVQUFVQyxVQUNwQ2pSLEtBQUtpUixXQUFXOzs7V0FHdEJqWixRQUFRaEQsT0FBT0EsT0FBT21PLFdBQVd0QyxPQUFPN0w7Ozs7T0FJNUMsSUFBSXliLE9BQU90TyxLQUFLbk4sT0FBT3FiLEtBQUtyUSxRQUFRLEdBQUc7U0FDckNoSSxRQUFROEgsTUFBTTBDLFdBQVcsdUJBQXVCeE4sT0FBT3FiLEtBQUtyUTtTQUM1RDlMLEVBQUUwQyxLQUFLNUIsT0FBT3FiLEtBQUtyUSxNQUFNLFVBQUNBLE1BQU1hLEtBQVE7V0FDdEMsSUFBSSxDQUFDc0IsS0FBS3ZOLFNBQVNpTSxNQUFNO2FBQ3ZCc0IsS0FBS3JPLEtBQUsrTTs7Ozs7OztXQU9aM00sRUFBRTBDLEtBQUtvQixRQUFRMEMsa0JBQWtCbUcsTUFBTSxVQUFDUSxNQUFTO2FBQy9DQSxRQUFRckosUUFBUXdGLGVBQWU2RCxNQUFNckI7Ozs7U0FJekMsSUFBTWtSLEtBQUtDLFNBQVNDLHVCQUF1QixXQUFXO1NBQ3RELElBQU1DLFlBQVlILEtBQUtBLEdBQUdJLFlBQVk7O1NBRXRDdFosUUFBUThILE1BQU0wQyxXQUFXOztTQUV6QitPLFdBQVcsWUFBTTtXQUNmLElBQUlMLElBQUk7YUFDTkEsR0FBR0ksWUFBWUQ7O1lBRWhCOzs7T0FHTCxJQUFJbFAsS0FBSzFNLFFBQVE7U0FDZnZCLEVBQUUwQyxLQUFLdUwsTUFBTSxVQUFDdEIsS0FBUTtXQUNwQjNNLEVBQUUwQyxLQUNBb0IsUUFBUTBDLGtCQUFrQm1HLE1BQzFCLFVBQUNRLE1BQUQ7YUFBQSxPQUFVQSxRQUFRckosUUFBUTZELGFBQWF3Rjs7Ozs7T0FLN0NySixRQUFRNEI7WUFDSDtPQUNMNUIsUUFBUXlGO09BQ1J6RixRQUFRcUksYUFBYXJMOzs7O0dBSXpCLFNBQVMwRixrQkFBa0JtRyxLQUFLO0tBQzlCLElBQU03SSxVQUFVOztLQURjLGFBRVA2SSxJQUFJa0QsTUFBTSxlQUFlO1NBRmxCO1NBRXJCakQsYUFGcUI7O0tBRzlCLElBQU1zSSxTQUFTcFIsUUFBUW1DLGVBQWUwRyxJQUFJNkMsUUFBUSxXQUFXO0tBQzdELElBQUl4UCxFQUFFRSxZQUFZME0sYUFBYTtPQUM3QixJQUFNMFEsU0FBU3haLFFBQVF3QyxpQkFBaUJxRztPQUN4QyxRQUFRMlEsUUFBUiwwQkFBbUJwSTs7S0FFckIsT0FBTyxDQUFDQSxPQUFPdEk7OztHQUdqQixTQUFTdEQsZUFBZWlVLFNBQVN0TCxRQUFRdUwsU0FBUztLQUNoRCxJQUFNMVosVUFBVTtLQUNoQixJQUFNNkksTUFBTTdJLFFBQVEyQyxPQUFPOFcsUUFBUTVROzs7OztLQUtuQyxJQUFJLENBQUNzRixPQUFPMVIsYUFBYWdkLFFBQVFoZCxXQUFXMFIsT0FBTzFSLFlBQVk7S0FDL0QsSUFBSWtkLFNBQVMsQ0FBQ0QsV0FBV0QsUUFBUWhkLGNBQWMwUixPQUFPMVI7O0tBRXREUCxFQUFFMEwsT0FBTzZSLFNBQVN2ZCxFQUFFQyxLQUFLZ1MsUUFBUSxTQUFTOztLQUUxQ3NMLFFBQVFwUCxRQUFRYixRQUFRLFVBQUMxSixNQUFTO09BQ2hDLElBQUksQ0FBQ3FPLE9BQU9yTyxPQUFPO1NBQ2pCLE9BQU8yWixRQUFRM1o7OztLQUduQjJaLFFBQVFwUCxVQUFVSixVQUFVa0U7Ozs7S0FJNUJuTyxRQUFROEgsTUFBTTBDLFdBQVcsNEJBQTRCM0I7Ozs7OztLQU1yRCxJQUFJOFEsVUFBVUYsUUFBUUUsUUFBUTtPQUM1QjNMLFFBQVE0TCxJQUFJO09BQ1pILFFBQVFFOzs7O0dBSVosU0FBU2YsZ0JBQWdCNWIsUUFBUTZMLEtBQUtzQixNQUFNO0tBQzFDQSxLQUFLck8sS0FBSytNO0tBQ1YsSUFBSTdMLE9BQU9tTyxZQUFZO09BQ3JCalAsRUFBRTBDLEtBQUs1QixPQUFPbU8sWUFBWSxVQUFVbk8sUUFBUTZjLFFBQVE7U0FDbERqQixnQkFBZ0I1YixRQUFRNkwsTUFBTSxNQUFNZ1IsUUFBUTFQOzs7S0FHaEQsSUFBSW5OLE9BQU91TSxTQUFTdk0sT0FBT3VNLE1BQU00QixZQUFZO09BQzNDalAsRUFBRTBDLEtBQUs1QixPQUFPbU8sWUFBWSxVQUFVbk8sUUFBUTZjLFFBQVE7U0FDbERqQixnQkFBZ0I1YixRQUFRNkwsTUFBTSxRQUFRZ1IsUUFBUTFQOzs7OztHQUtwRCxTQUFTTSxVQUFVNUIsS0FBSztLQUN0QixPQUFPLENBQUMzTSxFQUFFc0MsU0FBU3FLLE9BQU94SixXQUFXNkwsTUFBTXJDLE9BQU9BLEtBQUtpUixLQUFLOzs7R0FHOUQsU0FBU2pZLFdBQVduRixPQUFPO0tBQ3pCLE9BQU87T0FDTG1NLEtBQUs0QixVQUFVL04sTUFBTW1NO09BQ3JCa1IsU0FBU3JkLE1BQU1nTzs7OztHQUluQixTQUFTOUksa0JBQWtCO0tBQ3pCLElBQUk1QixVQUFVO0tBQ2RtQixTQUFTLFlBQVk7T0FDbkIsSUFBSWpGLEVBQUU4TSxJQUFJaEosU0FBUyxXQUFXO1NBQzVCQSxRQUFRa0gsT0FBT3NDLFFBQVEsVUFBVWtCLE9BQU87V0FDdEMxSyxRQUFROEgsTUFBTTBDLFdBQ1osc0JBQXNCRSxNQUFNN0IsS0FDNUIsb0JBQ0E2QixNQUFNcVA7OztRQUlYOzs7R0FHTCxTQUFTeFUsa0JBQWtCb0csU0FBUzlDLEtBQUs7S0FDdkMsT0FBTzhDLFFBQVEvTyxTQUFTLGVBQWU7T0FDckMsSUFBSVYsRUFBRTRVLFNBQVNqSSxNQUFNLE9BQU84QyxRQUFRRCxRQUFRLGVBQWU3QztPQUMzRCxJQUFNbVIsZ0JBQWdCLHlCQUF5QkMsS0FBS3RPO09BQ3BELElBQU11TyxLQUFLLElBQUlDLE9BQU9ILGNBQWMsS0FBSztPQUN6QyxJQUFNaEosUUFBUWtKLEdBQUdELEtBQUtwUjtPQUN0QixJQUFJLENBQUNtSSxPQUFPLE9BQU9yRjtPQUNuQkEsVUFBVUEsUUFBUUQsUUFDaEIsSUFBSXlPLE9BQU9ILGNBQWMsR0FBR3RPLFFBQVEsWUFBWSxTQUFTLE1BQ3pEc0YsTUFBTTs7S0FHVixPQUFPckY7OztHQUdULFNBQVNpSCxjQUFjL0osS0FBSztLQUMxQixJQUFJM00sRUFBRW1ULFNBQVN4RyxNQUFNO09BQ25CLE9BQU8zTSxFQUFFZ0ssS0FBSzJDLElBQUlBLEtBQUssVUFBVUEsS0FBSztTQUNwQyxPQUFPM00sRUFBRTRVLFNBQVNqSTs7O0tBR3RCLFFBQU8sWUFBWW9SLEtBQUtwUixLQUFLOzs7O0dBRy9CLFNBQVNsRCxjQUFja0QsS0FBS21JLE9BQU9vSixTQUFTO0tBQzFDLElBQU1wYSxVQUFVO0tBQ2hCLElBQUlxYTtLQUNKLElBQUksQ0FBQ25lLEVBQUV3TSxRQUFRc0ksUUFBUTtPQUNyQkEsUUFBUSxDQUFDQTs7S0FFWCxJQUFJOVUsRUFBRXNDLFNBQVNxSyxNQUFNO09BQ25Cd1IsVUFBVWhiLFdBQVc2TCxNQUFNckM7WUFDdEI7T0FDTHdSLFVBQVVuZSxFQUFFb2UsTUFBTXpSOztLQUVwQixPQUFPbUksTUFBTXZULFVBQVU0YyxRQUFRMUgsUUFBUSxNQUFNLENBQUMsR0FBRztPQUMvQyxJQUFJNEgsZUFBZUYsUUFBUTFILFFBQVE7T0FDbkMwSCxRQUFRRSxnQkFBZ0J2SixNQUFNNUY7O0tBRWhDLElBQUlnUCxTQUFTO09BQ1gsT0FBT0M7WUFDRjtPQUNMLE9BQU9yYSxRQUFRMkMsT0FBTzBYOzs7O0dBSTFCLFNBQVN2WSxVQUFVO0tBQ2pCLElBQUk5QixVQUFVO0tBQ2Q5RCxFQUFFMEMsS0FBS29CLFFBQVFtSCxRQUFRLFVBQVVtSixVQUFVO09BQ3pDQTs7OztHQUlKLFNBQVM3SyxlQUFlO0tBQ3RCLElBQU16RixVQUFVO0tBQ2hCQSxRQUFRd0gsVUFBVTtLQUNsQnhILFFBQVEySCxPQUFPSCxVQUFVeEgsUUFBUXdIOzs7R0FHbkMsU0FBU3pFLG1CQUFtQjtLQUMxQixJQUFNL0MsVUFBVTtLQUNoQixFQUFFQSxRQUFRd0g7S0FDVnhILFFBQVEySCxPQUFPSCxVQUFVeEgsUUFBUXdIOzs7Ozs7OztBQXhEckMsU0FBUSxVQWdFT25KLDBCOzs7Ozs7QUNub0VmLGdEOzs7Ozs7QUNBQSxnRDs7Ozs7O0FDQUE7OztBQUVBLFFBQU8sZUFBZSxTQUFTLGNBQWM7R0FDM0MsT0FBTzs7QUFIVCxLQUFNbWMsV0FBVztBQUNqQixLQUFNQyxhQUFhOztBQUVuQixVQUFTQyxZQUFZMWMsT0FBTztHQUMxQixJQUFHeWMsV0FBV3pjLFFBQVEsT0FBT3ljLFdBQVd6Yzs7R0FFeEMsSUFBTTJjLFVBQVU7R0FDaEJGLFdBQVd6YyxTQUFTMmM7R0FDcEIsT0FBT0E7OztBQUdULFVBQVNDLFdBQVc1YyxPQUFPd1MsSUFBSXFLLElBQUk7R0FDakMsSUFBTUMsV0FBV0osWUFBWTFjO0dBQzdCLElBQUc4YyxTQUFTdEssS0FBSyxPQUFPc0ssU0FBU3RLOztHQUVqQyxJQUFNbUssVUFBVUUsR0FBR0U7R0FDbkJELFNBQVN0SyxNQUFNbUs7R0FDZixPQUFPQTs7O0FBR1QsVUFBU0ssdUNBQXVDOzs7R0FFOUMsT0FBTztLQUNMbmE7S0FDQWxGLE1BQU1zZjs7Ozs7R0FLUixTQUFTcGEsV0FBVzdDLE9BQU9rZCxLQUFLO0tBQzlCQSxJQUFJdlAsVUFBVSxFQUFFd1A7S0FDaEJYLFNBQVN4YyxTQUFTa2Q7OztHQUdwQixTQUFTQyxPQUFPcGYsY0FBYzhlLElBQUk7S0FDaEM7O0tBRUEsT0FDRUQsV0FBVzdlLGFBQWFxZixPQUFPcmYsYUFBYXNmLFNBQVNSLElBQ3BERixRQUNBcEMsS0FBSztPQUFBLElBQUc0QyxTQUFILEtBQUdBO09BQUgsT0FBZ0JBOzs7OztBQUs1QixVQUFTRiw2QkFBNkJsZixjQUFjOGUsSUFBSTtHQUN0RDs7R0FFQSxPQUFPO0tBQ0xTO0tBQ0FDO0tBQ0FDOzs7OztHQUtGLFNBQVNELGVBQWV2ZCxPQUFPd1MsSUFBSTJLLFFBQXNCO0tBQUEsSUFBZDFJLFVBQWMsb0VBQUo7S0FBSSxJQUMvQzNLLFFBQVUySyxRQUFWM0s7O0tBQ1IsSUFBR0EsT0FBTztPQUNSQSxNQUFNMkssVUFBVTNLLE1BQU0ySyxXQUFXO09BQ2pDM0ssTUFBTTJLLFFBQVFpRSxrQkFBa0I7T0FDaEM4RCxTQUFTeGMsT0FBTzhKLFFBQVFBOztLQUUxQixJQUFNd00sSUFBSXNHLFdBQVc1YyxPQUFPd1MsSUFBSXFLO0tBQ2hDdkcsRUFBRTNJLFFBQVEsRUFBRXdQLGdCQUFRMUk7S0FDcEIsT0FBTzZCLEVBQUVxRzs7O0dBR1gsU0FBU1csV0FBV3RkLE9BQU87S0FDekIsSUFBTXNXLElBQUl1RyxHQUFHRTtLQUNiSCxXQUFXN2UsYUFBYXFmLE9BQU9yZixhQUFhc2YsU0FBU1IsSUFDbERGLFFBQ0FwQyxLQUFLLGlCQUF5QjtPQUFBLElBQXRCNEMsU0FBc0IsTUFBdEJBO1dBQVExSSxVQUFjLE1BQWRBOztPQUNmNkIsRUFBRTNJLFFBQVEsRUFBRTNOLE9BQU93YyxTQUFTeGMsUUFBUXlVO09BQ3BDLE9BQU8wSTs7S0FFWCxPQUFPN0csRUFBRXFHOzs7O0dBSVgsU0FBU2EsY0FBY3hkLE9BQU87S0FDNUJ3YyxTQUFTeGMsU0FBUztLQUNsQnljLFdBQVd6YyxTQUFTOzs7O0FBV3hCLFNBQVEsVUFQT2dkLHFDOzs7Ozs7QUN0RmY7Ozs7QUFFQSxRQUFPLGVBQWUsU0FBUyxjQUFjO0dBQzNDLE9BQU87O0FBSFQsVUFBU1Msb0JBQW9CQyxlQUFlQyxRQUFRQyxZQUFZN2YsY0FBYzhmLFFBQVE7R0FDcEY7O0dBRUEsU0FBU0MsbUJBQW1CO0dBQzVCRCxPQUFPRSxRQUFRRDs7R0FFZixJQUFNRSxLQUFLOztHQUVYQzs7OztHQUlBLFNBQVNBLFdBQVc7S0FDbEJQLGNBQ0dRLEtBQUtGLElBQ0x6RCxLQUFLLGdCQUF1RDtPQUFBLElBQXBENkMsUUFBb0QsS0FBcERBO1dBQW9ELG9CQUE3QzNJO1dBQVcwSixZQUFrQyxhQUFsQ0E7V0FBV0MsaUJBQXVCLGFBQXZCQTs7T0FDcENKLEdBQUdaLFFBQVFBO09BQ1hZLEdBQUdaLE1BQU1uUCxPQUFPb1EsUUFBUUM7O09BRXhCLElBQUdILFdBQVdILEdBQUdaLE1BQU1uUCxPQUFPc1EsTUFBTTtTQUFBLE9BQU1KLFVBQVVwZ0IsYUFBYXlnQjs7T0FDakVSLEdBQUdTLGVBQWViLFdBQVdsTCxJQUFJLHFCQUFxQmdNOzs7O0dBSTVELFNBQVNKLFNBQVM7S0FDaEIsSUFBRyxDQUFDWCxPQUFPZ0IsWUFBWTtPQUNyQmhCLE9BQU9pQixHQUFHOzs7O0dBSWQsU0FBU0YsZUFBZTs7S0FFdEJWLEdBQUdTO0tBQ0hULEdBQUdaLE1BQU15QixPQUFPdEUsS0FBSztPQUFBLE9BQ2pCeUQsR0FBR1osTUFBTTBCOzs7OztBQUtqQixVQUFTcEIsY0FBY1QsOEJBQThCOEIsV0FBV2hoQixjQUFjO0dBQzVFOztHQUVBLE9BQU8sRUFBRW1nQjs7OztHQUlULFNBQVNBLE9BQU87S0FDZCxPQUNFakIsNkJBQ0dLLFdBQVd2ZixhQUFhcWYsT0FDeEI3QyxLQUFLO09BQUEsSUFBR3ZhLFFBQUgsTUFBR0E7V0FBT3lVLFVBQVYsTUFBVUE7T0FBVixPQUF5QjtTQUM3QjJJLE9BQU8yQixVQUFVYixLQUFLbGU7U0FDdEJ5VTs7Ozs7O0FBZ0JWLFNBVFNnSjtBQVVULFNBVjhCQyw4Qjs7Ozs7O0FDM0Q5Qjs7O0FBRUEsUUFBTyxlQUFlLFNBQVMsY0FBYztHQUMzQyxPQUFPOztBQUhULFVBQVNzQixhQUFhO0dBQ3BCLE9BQU87S0FDTEMsVUFBVTtLQUNWQztLQWlCQXBWLE9BQU87T0FDTDVNLFFBQVE7T0FDUnVMLE9BQU87T0FDUDBXLFdBQVc7T0FDWEMsVUFBVTtPQUNWQyxXQUFXO09BQ1hDLGNBQWM7O0tBRWhCamlCLFlBQVlraUI7S0FDWnhmLGNBQWM7S0FDZHlmLGtCQUFrQjs7OztBQUl0QixVQUFTRCxTQUFTRSxtQkFBbUI1QixRQUFRNkIsV0FBVztHQUN0RDs7R0FFQSxTQUFTQyxnQkFBZ0I7R0FDekI5QixPQUFPRSxRQUFRLElBQUk0Qjs7R0FFbkIsSUFBSTNCLEtBQUs7R0FDVEEsR0FBR2hjLFVBQVV3TTtHQUNid1AsR0FBRzdVLFNBQVM7O0dBRVo2VSxHQUFHQyxXQUFXQTtHQUNkRCxHQUFHbGEsVUFBVUE7R0FDYmthLEdBQUc0QixVQUFVQTtHQUNiNUIsR0FBRzZCLFdBQVdBOztHQUVkN0IsR0FBRzdVLE9BQU9yTCxLQUFLK2YsT0FBTzNMLE9BQU87S0FBQSxPQUFNOEwsR0FBRzlnQixPQUFPOEI7TUFBUWdmLEdBQUc0Qjs7R0FFeEQ1QixHQUFHQzs7R0FFSEosT0FBT25MLElBQUlzTCxHQUFHc0IsZ0JBQWdCLFlBQVl0QixHQUFHbGE7Ozs7R0FJN0MsU0FBU21hLFdBQVc7S0FDbEIsSUFBR2xoQixRQUFRK1YsU0FBU2tMLEdBQUdtQixZQUFZO09BQ2pDbkIsR0FBR2hVLE9BQU9nVSxHQUFHOWdCLE9BQU84QixPQUFPK0ssTUFBTWlVLEdBQUdtQixXQUFXblY7WUFFNUM7T0FDSGdVLEdBQUdoVSxPQUFPZ1UsR0FBRzlnQixPQUFPOEIsT0FBT2dMOzs7O0tBSTdCLElBQUcwVixVQUFVSSxTQUFTalgsT0FBTztPQUMzQm1WLEdBQUduVixRQUFROzs7O0dBSWYsU0FBUytXLFFBQVF0USxLQUFLSixNQUFNO0tBQzFCLElBQUc4TyxHQUFHaFUsTUFBTTtPQUNWLElBQUcsQ0FBQ2dVLEdBQUdoYyxTQUFTO1NBQ2RnYyxHQUFHaGMsVUFBVXlkLGtCQUFrQnpCLEdBQUc5Z0IsT0FBTzhCLFFBQVFnZixHQUFHdlYsT0FBTztXQUN6RG9CLFVBQVVtVSxHQUFHOWdCLE9BQU8yTSxZQUFhO2FBQUEsT0FBTWdVOztXQUN2Q3pULFVBQVU0VCxHQUFHOWdCLE9BQU9rTjtXQUNwQnhGLFdBQVdvWixHQUFHOWdCLE9BQU8wSDtXQUNyQnlGLGNBQWNBOztjQUdiO1NBQ0gyVCxHQUFHaGMsUUFBUXVCLFFBQVF5YSxHQUFHOWdCLE9BQU84QixRQUFRZ2YsR0FBR3ZWLE9BQU91VixHQUFHOWdCOzs7OztHQUt4RCxTQUFTMmlCLFdBQVc7S0FDbEIsT0FBTyxDQUFDN0IsR0FBR3FCLGFBQWFyQixHQUFHaGMsV0FBV2djLEdBQUdoYyxRQUFRbUQ7OztHQUduRCxTQUFTa0YsYUFBYXJMLFFBQVE7S0FDNUJnZixHQUFHOWdCLE9BQU84QixTQUFTQTtLQUNuQmdmLEdBQUdDOzs7R0FHTCxTQUFTbmEsVUFBVTtLQUNqQjVGLEVBQUUwQyxLQUFLb2QsR0FBRzdVLFFBQVEsVUFBU21KLFVBQVU7T0FDbkNBOzs7S0FHRm1OLGtCQUFrQnRYLGVBQWU2VixHQUFHaGM7Ozs7QUFMeEMsU0FBUSxVQVVPZ2QsVzs7Ozs7OztBQzFHZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QixVQUFVOzs7Ozs7O0FDbkx0Qzs7O0FBRUEsUUFBTyxlQUFlLFNBQVMsY0FBYztHQUMzQyxPQUFPOztBQUhULFVBQVNlLG1CQUFtQjtHQUMxQixPQUFPO0tBQ0xkLFVBQVU7S0FDVm5WLE9BQU87T0FDTDVNLFFBQVE7T0FDUjhpQixRQUFRO09BQ1JDLGVBQWU7O0tBRWpCNWlCLFlBQVk2aUI7S0FDWlYsa0JBQWtCO0tBQ2xCemYsY0FBYztLQUNkbWY7Ozs7QUF5REosVUFBU2dCLGVBQWVyQyxRQUFRO0dBQzlCOztHQUVBLFNBQVNzQyxjQUFjO0dBQ3ZCdEMsT0FBT0UsUUFBUSxJQUFJb0M7O0dBRW5CLElBQU1uQyxLQUFLOztHQUVYQSxHQUFHb0MsYUFBYUE7R0FDaEJwQyxHQUFHcUMsYUFBYUE7Ozs7R0FJaEJ4QyxPQUFPM0wsT0FBTyxtQkFBbUJvTyxXQUFXO0dBQzVDekMsT0FBTzNMLE9BQU8sMEJBQTBCcU8sa0JBQWtCOzs7O0dBSTFELFNBQVNELFlBQVk7S0FDVHRDLEdBQUd3QyxRQUFVeEMsR0FBRzlnQixPQUF2QnNqQjs7O0dBR0wsU0FBU0QsbUJBQW1CO0tBQUEsV0FPdEJ2QyxHQUFHOWdCLE9BQU91akIsZ0JBQWdCOztLQUxmekMsR0FBRzBDLGNBRlEsS0FFeEJBO0tBQ2ExQyxHQUFHMkMsY0FIUSxLQUd4QkE7S0FDWTNDLEdBQUc0QyxhQUpTLEtBSXhCQTtLQUNhNUMsR0FBRzZDLGNBTFEsS0FLeEJBO0tBQ1M3QyxHQUFHOEMsVUFOWSxLQU14QkE7OztHQUlKLFNBQVNWLGFBQWE7Ozs7S0FJcEJ2QyxPQUFPa0QsUUFBUUEsUUFBUXZVLFdBQVc7OztHQUdwQyxTQUFTNlQsV0FBV1csV0FBVztLQUM3QixJQUFHaEQsR0FBRzlnQixPQUFPbWpCLFlBQVksT0FBT3JDLEdBQUc5Z0IsT0FBT21qQixXQUFXVztLQUNyRCxPQUFPOzs7O0FBNUNYLFNBQVEsVUFnRE9qQixpQjs7Ozs7Ozs7Ozs7QUNqSGYsVUFBU2tCLFVBQVQsR0FBc0I7QUFDcEIsVUFBTztBQUNMaEMsZUFBVSxHQURMO0FBRUxuVixZQUFPLEVBQUVFLE1BQU0sYUFBUixFQUZGO0FBR0w1SSxjQUFTLFNBSEo7QUFJTDhSLFdBQU1BO0FBSkQsSUFBUDtBQU1EOztBQUVELFVBQVNBLElBQVQsQ0FBYzJLLE1BQWQsRUFBc0I3RCxJQUF0QixFQUE0QmtILEtBQTVCLEVBQW1DQyxPQUFuQyxFQUE0QztBQUMxQyxZQUFTQyxhQUFULEdBQXlCLENBQUU7QUFDM0J2RCxVQUFPRSxLQUFQLEdBQWUsSUFBSXFELGFBQUosRUFBZjs7QUFFQSxPQUFHdkQsT0FBTzdULElBQVAsSUFBZTZULE9BQU83VCxJQUFQLENBQVlxWCxRQUE5QixFQUF3QztBQUN0Q3hELFlBQU8zTCxNQUFQLENBQWMsWUFBVztBQUFFLGNBQU9pUCxRQUFRRyxVQUFmO0FBQTRCLE1BQXZELEVBQXlELFVBQVNoakIsS0FBVCxFQUFnQjtBQUN2RTtBQUNBNmlCLGVBQVFJLFlBQVIsQ0FBcUIsWUFBckIsRUFBbUMsSUFBbkM7QUFDQUosZUFBUUksWUFBUixDQUFxQixTQUFyQixFQUFnQ2pqQixLQUFoQztBQUNELE1BSkQ7QUFLRDtBQUNGOzttQkFFYzJpQixVIiwiZmlsZSI6ImFsbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImxvZGFzaFwiKSwgcmVxdWlyZShcIm9iamVjdHBhdGhcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJjbi1mbGV4LWZvcm1cIiwgW1wibG9kYXNoXCIsIFwib2JqZWN0cGF0aFwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJjbi1mbGV4LWZvcm1cIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJsb2Rhc2hcIiksIHJlcXVpcmUoXCJvYmplY3RwYXRoXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJjbi1mbGV4LWZvcm1cIl0gPSBmYWN0b3J5KHJvb3RbXCJsb2Rhc2hcIl0sIHJvb3RbXCJvYmplY3RwYXRoXCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzdfXykge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBlYWZmN2FmNzViZjE3ZGZiZTI4ZSIsImltcG9ydCBjbkZsZXhGb3JtQ29uZmlnUHJvdmlkZXIgZnJvbSAnLi9jbi1mbGV4LWZvcm0tY29uZmlnLnNlcnZpY2UnO1xuaW1wb3J0IGNuRmxleEZvcm1UeXBlc1Byb3ZpZGVyIGZyb20gJy4vY24tZmxleC1mb3JtLXR5cGVzLnNlcnZpY2UnO1xuaW1wb3J0IHsgY25GbGV4Rm9ybVJvdXRlc1Byb3ZpZGVyLCBjbkZsZXhGb3JtUm91dGVzIH0gZnJvbSAnLi9jbi1mbGV4LWZvcm0ucm91dGVzJztcbmltcG9ydCB7IHNjaGVtYUZvcm1Db25maWcsIGFkZFRlbXBsYXRlcyB9IGZyb20gJy4vc2NoZW1hLWZvcm0tZXh0ZW5zaW9ucyc7XG5pbXBvcnQgY25GbGV4Rm9ybVNlcnZpY2VQcm92aWRlciBmcm9tICcuL2NuLWZsZXgtZm9ybS5zZXJ2aWNlJztcbmltcG9ydCBjbkZsZXhGb3JtTW9kYWxMb2FkZXJTZXJ2aWNlUHJvdmlkZXIgZnJvbSAnLi9jbi1mbGV4LWZvcm0tbW9kYWwtbG9hZGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgRmxleEZvcm1Nb2RhbExvYWRlciwgRmxleEZvcm1Nb2RhbCB9IGZyb20gJy4vY24tZmxleC1mb3JtLW1vZGFsLWxvYWRlcic7XG5pbXBvcnQgY25GbGV4Rm9ybSBmcm9tICcuL2NuLWZsZXgtZm9ybS5kaXJlY3RpdmUnO1xuaW1wb3J0IGNuRmxleEZvcm1IZWFkZXIgZnJvbSAnLi9jbi1mbGV4LWZvcm0taGVhZGVyLmRpcmVjdGl2ZSc7XG5pbXBvcnQgZmZWYWxpZGF0ZSBmcm9tICcuL2NuLWZsZXgtZm9ybS12YWxpZGF0ZS5kaXJlY3RpdmUnO1xuXG5leHBvcnQgZGVmYXVsdCBhbmd1bGFyXG4gIC5tb2R1bGUoJ2NuLmZsZXgtZm9ybScsIFtcbiAgICAndWkucm91dGVyJyxcbiAgICAnc2NoZW1hRm9ybScsXG4gICAgJ3VpLmJvb3RzdHJhcC5kYXRldGltZXBpY2tlcicsXG4gICAgJ2NuVGFnc0lucHV0JyxcbiAgICAnY24udXRpbCdcbiAgXSlcbiAgLnByb3ZpZGVyKCdjbkZsZXhGb3JtQ29uZmlnJywgY25GbGV4Rm9ybUNvbmZpZ1Byb3ZpZGVyKVxuICAucHJvdmlkZXIoJ2NuRmxleEZvcm1UeXBlcycsIGNuRmxleEZvcm1UeXBlc1Byb3ZpZGVyKVxuICAucHJvdmlkZXIoJ2NuRmxleEZvcm1Sb3V0ZXMnLCBjbkZsZXhGb3JtUm91dGVzUHJvdmlkZXIpXG4gIC5jb25maWcoY25GbGV4Rm9ybVJvdXRlcylcbiAgLmNvbmZpZyhzY2hlbWFGb3JtQ29uZmlnKVxuICAucnVuKGFkZFRlbXBsYXRlcylcbiAgLnByb3ZpZGVyKCdjbkZsZXhGb3JtU2VydmljZScsIGNuRmxleEZvcm1TZXJ2aWNlUHJvdmlkZXIpXG4gIC5wcm92aWRlcignY25GbGV4Rm9ybU1vZGFsTG9hZGVyU2VydmljZScsIGNuRmxleEZvcm1Nb2RhbExvYWRlclNlcnZpY2VQcm92aWRlcilcbiAgLmZhY3RvcnkoJ0ZsZXhGb3JtTW9kYWwnLCBGbGV4Rm9ybU1vZGFsKVxuICAuY29udHJvbGxlcignRmxleEZvcm1Nb2RhbExvYWRlcicsIEZsZXhGb3JtTW9kYWxMb2FkZXIpXG4gIC5kaXJlY3RpdmUoJ2NuRmxleEZvcm0nLCBjbkZsZXhGb3JtKVxuICAuZGlyZWN0aXZlKCdjbkZsZXhGb3JtSGVhZGVyJywgY25GbGV4Rm9ybUhlYWRlcilcbiAgLmRpcmVjdGl2ZSgnZmZWYWxpZGF0ZScsIGZmVmFsaWRhdGUpXG4gIC5uYW1lO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL19jbi1mbGV4LWZvcm0ubW9kdWxlLmpzIiwiZnVuY3Rpb24gY25GbGV4Rm9ybUNvbmZpZ1Byb3ZpZGVyKCkge1xuXG4gIGNvbnN0IGlnbm9yZVBhcmFtcyA9IFsncGFnZScsICdkZWJ1ZycsICdzYW5kYm94JywgJ21vZGFsJywgJ21vZGFsSWQnXTtcblxuICByZXR1cm4ge1xuICAgIGFkZElnbm9yZVBhcmFtLFxuICAgICRnZXQ6IGNuRmxleEZvcm1Db25maWdcbiAgfTtcblxuICAvLy8vLy8vL1xuXG4gIGZ1bmN0aW9uIGFkZElnbm9yZVBhcmFtKHBhcmFtKSB7XG4gICAgaWdub3JlUGFyYW1zLnB1c2gocGFyYW0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY25GbGV4Rm9ybUNvbmZpZygkc3RhdGVQYXJhbXMpIHtcbiAgICAnbmdJbmplY3QnO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdldFN0YXRlUGFyYW1zLFxuICAgICAgaWdub3JlUGFyYW1zXG4gICAgfTtcblxuICAgIC8vLy8vLy8vXG5cbiAgICBmdW5jdGlvbiBnZXRTdGF0ZVBhcmFtcyhvdmVycmlkZXMgPSB7fSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgXyh7IC4uLiRzdGF0ZVBhcmFtcywgLi4ub3ZlcnJpZGVzIH0pXG4gICAgICAgIC5vbWl0KGlnbm9yZVBhcmFtcylcbiAgICAgICAgLm9taXQodiA9PiAoXy5pc1VuZGVmaW5lZCh2KSB8fCB2ID09PSBudWxsKSlcbiAgICAgICAgLnZhbHVlKClcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbn1cblxuLy9hbmd1bGFyXG4gICAgLy8ubW9kdWxlKCdjbi5mbGV4LWZvcm0nKVxuICAgIC8vLnByb3ZpZGVyKCdjbkZsZXhGb3JtQ29uZmlnJywgY25GbGV4Rm9ybUNvbmZpZ1Byb3ZpZGVyKTtcblxuZXhwb3J0IGRlZmF1bHQgY25GbGV4Rm9ybUNvbmZpZ1Byb3ZpZGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NuLWZsZXgtZm9ybS1jb25maWcuc2VydmljZS5qcyIsImZ1bmN0aW9uIGNuRmxleEZvcm1UeXBlc1Byb3ZpZGVyKCkge1xuXG4gIHZhciBmaWVsZFR5cGVSZWdpc3RlciA9IFt7XG4gICAgY29uZGl0aW9uOiBmaWVsZCA9PiBmaWVsZC50eXBlID09PSAnaGlkZGVuJyxcbiAgICB0eXBlOiAnaGlkZGVuJ1xuICB9LCB7XG4gICAgY29uZGl0aW9uOiBmaWVsZCA9PiBmaWVsZC50eXBlLmluY2x1ZGVzKCdyYWRpb3MnKSxcbiAgICB0eXBlOiAnY24tcmFkaW9zJ1xuICB9LCB7XG4gICAgY29uZGl0aW9uOiBmaWVsZCA9PiBmaWVsZC50eXBlLmluY2x1ZGVzKCdyYWRpb2J1dHRvbnMnKSxcbiAgICB0eXBlOiAnY24tcmFkaW9idXR0b25zJ1xuICB9LCB7XG4gICAgY29uZGl0aW9uOiBmaWVsZCA9PiBmaWVsZC50eXBlLmluY2x1ZGVzKCdhdXRvY29tcGxldGUnKSB8fCBmaWVsZC50aXRsZU1hcCB8fCBmaWVsZC50aXRsZU1hcFJlc29sdmUgfHwgZmllbGQudGl0bGVNYXBRdWVyeSxcbiAgICB0eXBlOiAnY24tYXV0b2NvbXBsZXRlJ1xuICB9LCB7XG4gICAgY29uZGl0aW9uOiBmaWVsZCA9PiBmaWVsZC50eXBlID09PSAnY24tZGF0ZXRpbWVwaWNrZXInIHx8IGZpZWxkLnR5cGUgPT09ICdkYXRldGltZS1sb2NhbCcgfHwgZmllbGQudHlwZSA9PT0gJ3RpbWUtbWludXRlcycsXG4gICAgdHlwZTogJ2NuLWRhdGV0aW1lcGlja2VyJ1xuICB9LCB7XG4gICAgY29uZGl0aW9uOiBmaWVsZCA9PiBmaWVsZC50eXBlID09PSAnaGVscCcsXG4gICAgdHlwZTogJ2hlbHAnXG4gIH0sIHtcbiAgICBjb25kaXRpb246IGZpZWxkID0+IGZpZWxkLnR5cGUuaW5jbHVkZXMoJ2Rpc3BsYXknKSxcbiAgICB0eXBlOiAnY24tZGlzcGxheSdcbiAgfSwge1xuICAgIGNvbmRpdGlvbjogZmllbGQgPT4gZmllbGQuc2NoZW1hICYmIGZpZWxkLnNjaGVtYS5mb3JtYXQgJiYgZmllbGQuc2NoZW1hLmZvcm1hdC5pbmNsdWRlcygnY3VycmVuY3knKSxcbiAgICB0eXBlOiAnY24tY3VycmVuY3knXG4gIH0sIHtcbiAgICBjb25kaXRpb246IGZpZWxkID0+IGZpZWxkLnNjaGVtYSAmJiBmaWVsZC5zY2hlbWEuZm9ybWF0ID09PSAncGVyY2VudGFnZScsXG4gICAgdHlwZTogJ2NuLXBlcmNlbnRhZ2UnXG4gIH0sIHtcbiAgICBjb25kaXRpb246IGZpZWxkID0+IGZpZWxkLnNjaGVtYSAmJiBmaWVsZC50eXBlID09PSAndXJsJyxcbiAgICB0eXBlOiAnY24tdXJsJ1xuICB9LCB7XG4gICAgY29uZGl0aW9uOiBmaWVsZCA9PiBmaWVsZC50eXBlID09PSAndG9nZ2xlJyB8fCBmaWVsZC50eXBlID09PSAnYm9vbGVhbicsXG4gICAgdHlwZTogJ2NuLXRvZ2dsZSdcbiAgfSwge1xuICAgIGNvbmRpdGlvbjogZmllbGQgPT4gZmllbGQudHlwZSA9PT0gJ2NyZWF0aXZlaW1hZ2UnLFxuICAgIHR5cGU6ICdjbi1jcmVhdGl2ZWltYWdlJ1xuICB9LCB7XG4gICAgY29uZGl0aW9uOiBmaWVsZCA9PiBmaWVsZC50eXBlID09PSAnZmFjZWJvb2t2aWRlbycsXG4gICAgdHlwZTogJ2NuLWZhY2Vib29rdmlkZW8nXG4gIH0sIHtcbiAgICBjb25kaXRpb246IGZpZWxkID0+IGZpZWxkLnR5cGUgPT09ICdtZWRpYXVwbG9hZCcsXG4gICAgdHlwZTogJ2NuLW1lZGlhdXBsb2FkJ1xuICB9LCB7XG4gICAgY29uZGl0aW9uOiBmaWVsZCA9PiBmaWVsZC50eXBlID09PSAnY3N2dXBsb2FkJyxcbiAgICB0eXBlOiAnY24tY3N2dXBsb2FkJ1xuICB9LCB7XG4gICAgY29uZGl0aW9uOiBmaWVsZCA9PiBmaWVsZC50eXBlID09PSAncmV1c2FibGUnLFxuICAgIHR5cGU6ICdjbi1yZXVzYWJsZSdcbiAgfSwge1xuICAgIGNvbmRpdGlvbjogZmllbGQgPT4gZmllbGQudHlwZSA9PT0gJ3RhYmxlJyxcbiAgICB0eXBlOiAnY24tdGFibGUnXG4gIH0sIHtcbiAgICBjb25kaXRpb246IGZpZWxkID0+IGZpZWxkLnR5cGUgPT09ICdhcnJheScsXG4gICAgdHlwZTogJ2FycmF5J1xuICB9LCB7XG4gICAgY29uZGl0aW9uOiBmaWVsZCA9PiBmaWVsZC50eXBlID09PSAnc2NoZWR1bGUnLFxuICAgIHR5cGU6ICdjbi1zY2hlZHVsZSdcbiAgfSwge1xuICAgIGNvbmRpdGlvbjogZmllbGQgPT4gZmllbGQuc2NoZW1hICYmIGZpZWxkLnNjaGVtYS50eXBlID09PSAnbnVtYmVyJyxcbiAgICB0eXBlOiAnY24tbnVtYmVyJ1xuICB9XTtcblxuICByZXR1cm4ge1xuICAgIHJlZ2lzdGVyRmllbGRUeXBlOiByZWdpc3RlckZpZWxkVHlwZSxcbiAgICAkZ2V0OiBjbkZsZXhGb3JtVHlwZXNcbiAgfTtcblxuICAvLy8vLy8vL1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyRmllbGRUeXBlKGZpZWxkVHlwZSkge1xuICAgIGZpZWxkVHlwZVJlZ2lzdGVyLnVuc2hpZnQoZmllbGRUeXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNuRmxleEZvcm1UeXBlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmllbGRUeXBlUmVnaXN0ZXI6IGZpZWxkVHlwZVJlZ2lzdGVyLFxuICAgICAgZ2V0RmllbGRUeXBlOiBnZXRGaWVsZFR5cGVcbiAgICB9O1xuXG4gICAgLy8vLy8vLy8vXG5cbiAgICBmdW5jdGlvbiBnZXRGaWVsZFR5cGUoZmllbGQpIHtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBmaWVsZFR5cGVSZWdpc3Rlci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYoZmllbGRUeXBlUmVnaXN0ZXJbaV0uY29uZGl0aW9uKGZpZWxkKSkge1xuICAgICAgICAgIHJldHVybiBmaWVsZFR5cGVSZWdpc3RlcltpXS50eXBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmllbGQudHlwZSB8fCBmaWVsZC5zY2hlbWEgJiYgZmllbGQuc2NoZW1hLnR5cGU7XG4gICAgfVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgY25GbGV4Rm9ybVR5cGVzUHJvdmlkZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY24tZmxleC1mb3JtLXR5cGVzLnNlcnZpY2UuanMiLCJmdW5jdGlvbiBjbkZsZXhGb3JtUm91dGVzUHJvdmlkZXIoJHN0YXRlUHJvdmlkZXIpIHtcbiAgJ25nSW5qZWN0JztcblxuICByZXR1cm4ge1xuICAgIGFkZFN0YXRlcyxcbiAgICAkZ2V0XG4gIH07XG5cbiAgLy8vLy8vLy8vLy8vXG5cbiAgZnVuY3Rpb24gJGdldCgpIHtcbiAgICAvLyBub3RoaW5nIHRvIGRvIGhlcmUsIGJ1dCByZXF1aXJlZFxuICB9XG5cbiAgZnVuY3Rpb24gYWRkU3RhdGVzKHsgcGVybWlzc2lvbnMsIG5hbWUgfSkge1xuICAgIGNvbnN0IHNoYXJlZCA9IHtcbiAgICAgIGNvbnRyb2xsZXI6ICdGbGV4Rm9ybU1vZGFsTG9hZGVyJyxcbiAgICAgIGNvbnRyb2xsZXJBczogJ3ZtJyxcbiAgICAgIHBlcm1pc3Npb25zXG4gICAgfTtcbiAgICAkc3RhdGVQcm92aWRlclxuICAgICAgICAuc3RhdGUoYCR7bmFtZX0ucGFnZS5tb2RhbGAsIHtcbiAgICAgICAgICB1cmw6ICcvfjptb2RhbC86bW9kYWxJZCcsXG4gICAgICAgICAgLi4uc2hhcmVkXG4gICAgICAgIH0pXG4gICAgICAgIC5zdGF0ZShgJHtuYW1lfS5wYWdlLm1vZGFsUGFyYW1zYCwge1xuICAgICAgICAgIHVybDogJy9+Om1vZGFsLzptb2RhbElkLzpyZXN0UGFyYW1zJyxcbiAgICAgICAgICAuLi5zaGFyZWRcbiAgICAgICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY25GbGV4Rm9ybVJvdXRlcygkc3RhdGVQcm92aWRlcikge1xuICAnbmdJbmplY3QnO1xuXG4gICRzdGF0ZVByb3ZpZGVyXG4gICAgICAuc3RhdGUoJ2ZsZXgtZm9ybS1zYW5kYm94Jywge1xuICAgICAgICB1cmw6ICcvZmxleC1mb3JtL3NhbmRib3gnLFxuICAgICAgICBjb250cm9sbGVyOiAnRmxleEZvcm1TYW5kYm94JyxcbiAgICAgICAgY29udHJvbGxlckFzOiAndm0nLFxuICAgICAgICB0ZW1wbGF0ZVVybDogJ2FwcC9jb21wb25lbnRzL2NuLWZsZXgtZm9ybS9zYW5kYm94Lmh0bWwnXG4gICAgICB9KTtcbn1cblxuZXhwb3J0IHsgY25GbGV4Rm9ybVJvdXRlcywgY25GbGV4Rm9ybVJvdXRlc1Byb3ZpZGVyIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY24tZmxleC1mb3JtLnJvdXRlcy5qcyIsImZ1bmN0aW9uIHNjaGVtYUZvcm1Db25maWcoY25GbGV4Rm9ybVNlcnZpY2VQcm92aWRlcikge1xuICAnbmdJbmplY3QnO1xuXG4gIHR2NC5hZGRGb3JtYXQoe1xuICAgICd1cmwnOiBkYXRhID0+IF8uaXNTdHJpbmcoZGF0YSkgJiYgIS9eKGh0dHBzPzpcXC9cXC8uezJ9fCQpLy50ZXN0KGRhdGEpICYmICdpbnZhbGlkIHVybCdcbiAgfSk7XG5cbiAgdmFyIGV4dGVuc2lvbnMgPSBbXG4gICAgJ2NuLWZpZWxkc2V0JyxcbiAgICAnY24tdG9nZ2xlJyxcbiAgICAnY24tZGF0ZXRpbWVwaWNrZXInLFxuICAgICdjbi1hdXRvY29tcGxldGUnLFxuICAgICdjbi1hdXRvY29tcGxldGUtZGV0YWlsZWQnLFxuICAgICdjbi1udW1iZXInLFxuICAgICdjbi1jdXJyZW5jeScsXG4gICAgJ2NuLXVybCcsXG4gICAgJ2NuLXJhZGlvcycsXG4gICAgJ2NuLXJhZGlvYnV0dG9ucycsXG4gICAgJ2NuLXBlcmNlbnRhZ2UnLFxuICAgICdjbi1kaXNwbGF5JyxcbiAgICAnY24tbWVkaWF1cGxvYWQnLFxuICAgICdjbi1jc3Z1cGxvYWQnLFxuICAgICdjbi1yZXVzYWJsZScsXG4gICAgJ2NuLXRhYmxlJyxcbiAgICAnY24tY3JlYXRpdmVpbWFnZScsXG4gICAgJ2NuLXNjaGVkdWxlJyxcbiAgICAnY24tZmFjZWJvb2t2aWRlbydcbiAgXTtcblxuICBfLmVhY2goZXh0ZW5zaW9ucywgZnVuY3Rpb24oZXh0ZW5zaW9uKSB7XG4gICAgY25GbGV4Rm9ybVNlcnZpY2VQcm92aWRlci5yZWdpc3RlckZpZWxkKHtcbiAgICAgIHR5cGU6IGV4dGVuc2lvbixcbiAgICAgIHRlbXBsYXRlVXJsOiBgYXBwL2NvbXBvbmVudHMvY24tZmxleC1mb3JtL2Zvcm1zLyR7ZXh0ZW5zaW9ufS5odG1sYFxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVGVtcGxhdGVzKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICduZ0luamVjdCc7XG5cbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFxuICAgICAgJ2FwcC9jb21wb25lbnRzL2NuLWZsZXgtZm9ybS9mb3Jtcy9jbi10b2dnbGUuaHRtbCcsXG4gICAgICBgXG4gICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCB7e2Zvcm0uaHRtbENsYXNzfX1cIlxuICAgICAgICAgICBuZy1jbGFzcz1cInsnaGFzLWVycm9yJzogaGFzRXJyb3IoKSwgJ2hhcy1zdWNjZXNzJzogaGFzU3VjY2VzcygpfVwiPlxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJjb250cm9sLWxhYmVsXCIgbmctc2hvdz1cInNob3dUaXRsZSgpXCI+e3tmb3JtLnRpdGxlfX08L2xhYmVsPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2xlYXJmaXhcIj5cbiAgICAgICAgICA8Y24tdG9nZ2xlLXN3aXRjaFxuICAgICAgICAgICAgbmFtZT1cInt7Zm9ybS5rZXkuam9pbignLicpfX1cIlxuICAgICAgICAgICAgY2xhc3M9XCJwdWxsLWxlZnRcIlxuICAgICAgICAgICAgbmctc2hvdz1cImZvcm0ua2V5XCJcbiAgICAgICAgICAgIG5nLW1vZGVsLW9wdGlvbnM9XCJmb3JtLm5nTW9kZWxPcHRpb25zXCJcbiAgICAgICAgICAgIG5nLW1vZGVsPVwiJCR2YWx1ZSQkXCJcbiAgICAgICAgICAgIHNmLWNoYW5nZWQ9XCJmb3JtXCJcbiAgICAgICAgICAgIHNjaGVtYS12YWxpZGF0ZT1cImZvcm1cIlxuICAgICAgICAgICAgb24tdmFsdWU9XCJmb3JtLm9uVmFsdWVcIlxuICAgICAgICAgICAgb2ZmLXZhbHVlPVwiZm9ybS5vZmZWYWx1ZVwiXG4gICAgICAgICAgICBuZy1yZXF1aXJlZD1cImZvcm0ucmVxdWlyZWRcIlxuICAgICAgICAgICAgcmVhZC1vbmx5PVwiZm9ybS5yZWFkb25seVwiXG4gICAgICAgICAgICB1bmRlZmluZWQtY2xhc3M9XCJmb3JtLnVuZGVmaW5lZENsYXNzXCIvPlxuICAgICAgICAgIDxzcGFuIG5nLXNob3c9XCJmb3JtLm9uVGV4dCAmJiBmb3JtLm9mZlRleHRcIj5cbiAgICAgICAgICAgIHt7JCR2YWx1ZSQkID09PSBmb3JtLm9uVmFsdWUgPyBmb3JtLm9uVGV4dCA6IGZvcm0ub2ZmVGV4dH19XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJoZWxwLWJsb2NrXCIgc2YtbWVzc2FnZT1cImZvcm0uZGVzY3JpcHRpb25cIj48L3NwYW4+XG4gICAgICA8L2Rpdj5gXG4gICk7XG5cbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFxuICAgICAgJ2FwcC9jb21wb25lbnRzL2NuLWZsZXgtZm9ybS9mb3Jtcy9jbi1kYXRldGltZXBpY2tlci5odG1sJyxcbiAgICAgIGBcbiAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHt7Zm9ybS5odG1sQ2xhc3N9fVwiXG4gICAgICAgICAgIG5nLWNsYXNzPVwieydoYXMtZXJyb3InOiBoYXNFcnJvcigpLCAnaGFzLXN1Y2Nlc3MnOiBoYXNTdWNjZXNzKCl9XCI+XG4gICAgICAgIDxsYWJlbCBjbGFzcz1cImNvbnRyb2wtbGFiZWxcIlxuICAgICAgICAgICAgICAgZm9yPVwie3tmb3JtLmtleS5qb2luKCcuJyl9fVwiXG4gICAgICAgICAgICAgICBuZy1zaG93PVwic2hvd1RpdGxlKClcIj57e2Zvcm0udGl0bGV9fTwvbGFiZWw+XG4gICAgICAgIDxjbi1kYXRldGltZXBpY2tlclxuICAgICAgICAgIG5nLXNob3c9XCJmb3JtLmtleVwiXG4gICAgICAgICAgbmctbW9kZWw9XCIkJHZhbHVlJCRcIlxuICAgICAgICAgIG5nLW1vZGVsLW9wdGlvbnM9XCJmb3JtLm5nTW9kZWxPcHRpb25zXCJcbiAgICAgICAgICBpcy1kaXNhYmxlZD1cImZvcm0ucmVhZG9ubHlcIlxuICAgICAgICAgIHNmLWNoYW5nZWQ9XCJmb3JtXCJcbiAgICAgICAgICBzY2hlbWEtdmFsaWRhdGU9XCJmb3JtXCJcbiAgICAgICAgICBpbnB1dC1pZD1cInt7Zm9ybS5rZXkuam9pbignLicpfX1cIlxuICAgICAgICAgIG1pbi1kYXRlPVwiZm9ybS5taW5EYXRlXCJcbiAgICAgICAgICBtYXgtZGF0ZT1cImZvcm0ubWF4RGF0ZVwiXG4gICAgICAgICAgbWF4LXZpZXc9XCJ7e2Zvcm0ubWF4Vmlld319XCJcbiAgICAgICAgICBkZWZhdWx0LXRpbWU9XCJmb3JtLmRlZmF1bHRUaW1lXCJcbiAgICAgICAgICBjbi1kYXRlLXJlcXVpcmVkPVwiZm9ybS5yZXF1aXJlZFwiXG4gICAgICAgICAgcGxhY2Vob2xkZXI9XCJ7e2Zvcm0ucGxhY2Vob2xkZXJ9fVwiXG4gICAgICAgICAgbW9kZWwtdHlwZT1cInt7Zm9ybS5zY2hlbWEudHlwZX19XCJcbiAgICAgICAgICBtb2RlbC1mb3JtYXR0ZXI9XCJmb3JtLm1vZGVsRm9ybWF0dGVyXCJcbiAgICAgICAgICBtb2RlbC1wYXJzZXI9XCJmb3JtLm1vZGVsUGFyc2VyXCJcbiAgICAgICAgICB2aWV3LWZvcm1hdHRlcj1cImZvcm0udmlld0Zvcm1hdHRlclwiXG4gICAgICAgICAgdmlldy1wYXJzZXI9XCJmb3JtLnZpZXdQYXJzZXJcIlxuICAgICAgICAgIGZvcm1hdC1zdHJpbmc9e3tmb3JtLmRhdGVGb3JtYXR9fVxuICAgICAgICAgIGljb24tY2xhc3M9e3tmb3JtLmljb25DbGFzc319PlxuICAgICAgICA8L2NuLWRhdGV0aW1lcGlja2VyPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImhlbHAtYmxvY2tcIiBzZi1tZXNzYWdlPVwiZm9ybS5kZXNjcmlwdGlvblwiPjwvc3Bhbj5cbiAgICAgIDwvZGl2PmBcbiAgKTtcblxuICB2YXIgc2hhcmVkQXV0b2NvbXBsZXRlVHBsID0gYFxuICAgICAgICA8dGFncy1pbnB1dFxuICAgICAgICAgIG5nLXNob3c9XCJmb3JtLmtleVwiXG4gICAgICAgICAgbmctbW9kZWw9XCIkJHZhbHVlJCRcIlxuICAgICAgICAgIG5nLW1vZGVsLW9wdGlvbnM9XCJmb3JtLm5nTW9kZWxPcHRpb25zXCJcbiAgICAgICAgICBuZy1kaXNhYmxlZD1cImZvcm0ucmVhZG9ubHlcIlxuICAgICAgICAgIHNmLWNoYW5nZWQ9XCJmb3JtXCJcbiAgICAgICAgICBzY2hlbWEtdmFsaWRhdGU9XCJmb3JtXCJcbiAgICAgICAgICBpbnB1dC1pZD1cInt7Zm9ybS5rZXkuam9pbignLicpfX1cIlxuICAgICAgICAgIGRpc3BsYXktcHJvcGVydHk9XCJ7e2Zvcm0uZGlzcGxheVByb3BlcnR5IHx8ICduYW1lJ319XCJcbiAgICAgICAgICB2YWx1ZS1wcm9wZXJ0eT1cInt7Zm9ybS52YWx1ZVByb3BlcnR5fX1cIlxuICAgICAgICAgIHBsYWNlaG9sZGVyPVwie3tmb3JtLnBsYWNlaG9sZGVyIHx8ICcgJ319XCJcbiAgICAgICAgICBjbGVhci1vbi1ibHVyPVwidHJ1ZVwiXG4gICAgICAgICAgYWRkLW9uLWNvbW1hPVwiZmFsc2VcIlxuICAgICAgICAgIGFkZC1mcm9tLWF1dG9jb21wbGV0ZS1vbmx5PVwie3shZm9ybS5hbGxvd05ld319XCJcbiAgICAgICAgICBvbi1iZWZvcmUtdGFnLWFkZGVkPVwiZm9ybS5vbkFkZCh7dmFsdWU6ICR0YWd9LCBmb3JtLCAkZXZlbnQsICRwcmV2KVwiXG4gICAgICAgICAgb24taW5pdD1cImZvcm0ub25Jbml0KCR0YWcsIGZvcm0sICRldmVudCwgJHNldHRlcilcIlxuICAgICAgICAgIG1vZGVsLXR5cGU9XCJ7e2Zvcm0uZ2V0U2NoZW1hVHlwZSgpfX1cIlxuICAgICAgICAgIGFycmF5LXZhbHVlLXR5cGU9XCJ7e2Zvcm0uc2NoZW1hLml0ZW1zLnR5cGV9fVwiXG4gICAgICAgICAgaGlkZS10YWdzPVwie3tmb3JtLmRldGFpbGVkTGlzdH19XCJcbiAgICAgICAgICB0YWdzLXN0eWxlPVwie3tmb3JtLnNlbGVjdGlvblN0eWxlfX1cIlxuICAgICAgICAgIHJlcXVpcmVkPVwie3tmb3JtLnJlcXVpcmVkfX1cIlxuICAgICAgICAgIG1pbi1sZW5ndGg9XCJ7e2Zvcm0ubWluTGVuZ3RofX1cIlxuICAgICAgICAgIGFsbG93ZWQtdGFncy1wYXR0ZXJuPVwiLipcIlxuICAgICAgICAgIGRyb3Bkb3duLWljb249XCJ0cnVlXCJcbiAgICAgICAgICBpdGVtLWZvcm1hdHRlcj1cImZvcm0uaXRlbUZvcm1hdHRlclwiXG4gICAgICAgICAgbWluLXRhZ3M9XCJ7e2Zvcm0ubWluSXRlbXMgfHwgZm9ybS5zY2hlbWEubWluSXRlbXN9fVwiXG4gICAgICAgICAgbWF4LXRhZ3M9XCJ7e2Zvcm0ubWF4SXRlbXMgfHwgZm9ybS5zY2hlbWEubWF4SXRlbXMgfHwgKGZvcm0uZ2V0U2NoZW1hVHlwZSgpICE9PSAnYXJyYXknID8gMSA6IDApfX1cIlxuICAgICAgICAgIGFsbG93LWJ1bGs9XCJ7e2Zvcm0uYnVsa0FkZH19XCJcbiAgICAgICAgICBidWxrLWRlbGltaXRlcj1cInt7Zm9ybS5idWxrRGVsaW1pdGVyfX1cIlxuICAgICAgICAgIGJ1bGstcGxhY2Vob2xkZXI9XCJ7e2Zvcm0uYnVsa1BsYWNlaG9sZGVyfX1cIlxuICAgICAgICAgIGJ1bGstc2luZ2xlLXJlcXVlc3Q9XCJ7e2Zvcm0uYnVsa1NpbmdsZVJlcXVlc3R9fVwiXG4gICAgICAgICAgc29ydC1maWx0ZXJlZC1yZXN1bHRzPVwie3soZm9ybS50aXRsZU1hcFJlc29sdmUgfHwgZm9ybS50aXRsZU1hcCkgJiYgIWZvcm0udGl0bGVNYXBRdWVyeX19XCJcbiAgICAgICAgICBzaG93LWNsZWFyLWFsbD1cInt7Zm9ybS5zaG93Q2xlYXJBbGx9fVwiXG4gICAgICAgICAgc2hvdy1jbGVhci1jYWNoZT1cInt7Zm9ybS5zaG93Q2xlYXJDYWNoZX19XCJcbiAgICAgICAgICBzaG93LWJ1dHRvbj1cInRydWVcIj5cbiAgICAgICAgICA8YXV0by1jb21wbGV0ZVxuICAgICAgICAgICAgc291cmNlPVwiZm9ybS5nZXRUaXRsZU1hcCAmJiBmb3JtLmdldFRpdGxlTWFwKCkgfHwgZm9ybS50aXRsZVF1ZXJ5KCRxdWVyeSwgb3B0aW9ucylcIlxuICAgICAgICAgICAgc2tpcC1maWx0ZXJpbmc9XCJ7e2Zvcm0uc2tpcEZpbHRlcmluZ319XCJcbiAgICAgICAgICAgIHNpbmdsZS1xdWVyeT1cInt7Zm9ybS5zaW5nbGVRdWVyeX19XCJcbiAgICAgICAgICAgIGRlYm91bmNlLWRlbGF5PVwie3tmb3JtLmRlYm91bmNlRGVsYXl9fVwiXG4gICAgICAgICAgICBtaW4tbGVuZ3RoPVwie3tmb3JtLm1pbkxvb2t1cH19XCI+XG4gICAgICAgICAgPC9hdXRvLWNvbXBsZXRlPlxuICAgICAgICA8L3RhZ3MtaW5wdXQ+YDtcblxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXG4gICAgICAnYXBwL2NvbXBvbmVudHMvY24tZmxleC1mb3JtL2Zvcm1zL2NuLWF1dG9jb21wbGV0ZS5odG1sJyxcbiAgICAgIGBcbiAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHt7Zm9ybS5odG1sQ2xhc3N9fVwiXG4gICAgICAgICAgIG5nLWNsYXNzPVwieydoYXMtZXJyb3InOiBoYXNFcnJvcigpLCAnaGFzLXN1Y2Nlc3MnOiBoYXNTdWNjZXNzKCl9XCI+XG4gICAgICAgIDxsYWJlbCBjbGFzcz1cImNvbnRyb2wtbGFiZWxcIlxuICAgICAgICAgICAgICAgZm9yPVwie3tmb3JtLmtleS5qb2luKCcuJyl9fS1pbnB1dFwiXG4gICAgICAgICAgICAgICBuZy1zaG93PVwic2hvd1RpdGxlKClcIj57e2Zvcm0udGl0bGV9fTwvbGFiZWw+XG4gICAgICAgICR7c2hhcmVkQXV0b2NvbXBsZXRlVHBsfVxuICAgICAgICA8c3BhbiBjbGFzcz1cImhlbHAtYmxvY2tcIiBzZi1tZXNzYWdlPVwiZm9ybS5kZXNjcmlwdGlvblwiPjwvc3Bhbj5cbiAgICAgIDwvZGl2PmBcbiAgKTtcblxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXG4gICAgICAnYXBwL2NvbXBvbmVudHMvY24tZmxleC1mb3JtL2Zvcm1zL2NuLWF1dG9jb21wbGV0ZS1kZXRhaWxlZC5odG1sJyxcbiAgICAgIGBcbiAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHt7Zm9ybS5odG1sQ2xhc3N9fVwiXG4gICAgICAgICAgIG5nLWNsYXNzPVwieydoYXMtZXJyb3InOiBoYXNFcnJvcigpLCAnaGFzLXN1Y2Nlc3MnOiBoYXNTdWNjZXNzKCl9XCI+XG4gICAgICAgIDxsYWJlbCBjbGFzcz1cImNvbnRyb2wtbGFiZWxcIlxuICAgICAgICAgICAgICAgZm9yPVwie3tmb3JtLmtleS5qb2luKCcuJyl9fS1pbnB1dFwiXG4gICAgICAgICAgICAgICBuZy1zaG93PVwic2hvd1RpdGxlKClcIj57e2Zvcm0udGl0bGV9fTwvbGFiZWw+XG4gICAgICAgIDxkaXYgc2YtYXJyYXk9XCJmb3JtXCI+XG4gICAgICAgICAgPG9sIGNsYXNzPVwibGlzdC1ncm91cCBjbi1hdXRvY29tcGxldGUtbGlzdFwiXG4gICAgICAgICAgICAgIG5nLWlmPVwibW9kZWxBcnJheS5sZW5ndGhcIlxuICAgICAgICAgICAgICBuZy1tb2RlbD1cIm1vZGVsQXJyYXlcIj5cbiAgICAgICAgICAgIDxsaSBjbGFzcz1cImxpc3QtZ3JvdXAtaXRlbSB7e2Zvcm0uZmllbGRIdG1sQ2xhc3N9fVwiXG4gICAgICAgICAgICAgICAgbmctcmVwZWF0PVwiaXRlbSBpbiBtb2RlbEFycmF5IHRyYWNrIGJ5ICRpbmRleFwiPlxuICAgICAgICAgICAgICA8YnV0dG9uIG5nLWhpZGU9XCJmb3JtLnJlYWRvbmx5IHx8IGZvcm0ucmVtb3ZlID09PSBudWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICBuZy1jbGljaz1cImRlbGV0ZUZyb21BcnJheSgkaW5kZXgpXCJcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJjbG9zZSBwdWxsLXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JnRpbWVzOzwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgIDxzZi1kZWNvcmF0b3IgZm9ybT1cImNvcHlXaXRoSW5kZXgoJGluZGV4KVwiLz5cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgPC9vbD5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgICR7c2hhcmVkQXV0b2NvbXBsZXRlVHBsfVxuICAgICAgICA8c3BhbiBjbGFzcz1cImhlbHAtYmxvY2tcIiBzZi1tZXNzYWdlPVwiZm9ybS5kZXNjcmlwdGlvblwiPjwvc3Bhbj5cbiAgICAgIDwvZGl2PmBcbiAgKTtcblxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXG4gICAgICAnYXBwL2NvbXBvbmVudHMvY24tZmxleC1mb3JtL2Zvcm1zL2NuLW51bWJlci5odG1sJyxcbiAgICAgIGBcbiAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHt7Zm9ybS5odG1sQ2xhc3N9fVwiXG4gICAgICAgICAgIG5nLWNsYXNzPVwieydoYXMtZXJyb3InOiBoYXNFcnJvcigpLCAnaGFzLXN1Y2Nlc3MnOiBoYXNTdWNjZXNzKCl9XCI+XG4gICAgICAgIDxsYWJlbCBjbGFzcz1cImNvbnRyb2wtbGFiZWxcIlxuICAgICAgICAgICAgICAgbmctc2hvdz1cInNob3dUaXRsZSgpXCJcbiAgICAgICAgICAgICAgIGZvcj1cInt7Zm9ybS5rZXkuam9pbignLicpfX1cIj57e2Zvcm0udGl0bGV9fTwvbGFiZWw+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ7e2Zvcm0uZmllbGRDbGFzc319XCI+XG4gICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jb250cm9sXCJcbiAgICAgICAgICAgICAgICAgY24tbnVtYmVyXG4gICAgICAgICAgICAgICAgIG5nLXNob3c9XCJmb3JtLmtleVwiXG4gICAgICAgICAgICAgICAgIG5nLW1vZGVsLW9wdGlvbnM9XCJmb3JtLm5nTW9kZWxPcHRpb25zXCJcbiAgICAgICAgICAgICAgICAgbmctZGlzYWJsZWQ9XCJmb3JtLnJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICAgc2YtY2hhbmdlZD1cImZvcm1cIlxuICAgICAgICAgICAgICAgICBzY2hlbWEtdmFsaWRhdGU9XCJmb3JtXCJcbiAgICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgICBzdGVwPVwiYW55XCJcbiAgICAgICAgICAgICAgICAgbWluPVwie3tmb3JtLm1pbn19XCJcbiAgICAgICAgICAgICAgICAgbWF4PVwie3tmb3JtLm1heH19XCJcbiAgICAgICAgICAgICAgICAgaWQ9XCJ7e2Zvcm0ua2V5LmpvaW4oJy4nKX19XCJcbiAgICAgICAgICAgICAgICAgbmFtZT1cInt7Zm9ybS5rZXkuam9pbignLicpfX1cIlxuICAgICAgICAgICAgICAgICBuZy1tb2RlbD1cIiQkdmFsdWUkJFwiPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJoZWxwLWJsb2NrXCIgc2YtbWVzc2FnZT1cImZvcm0uZGVzY3JpcHRpb25cIj48L3NwYW4+XG4gICAgICA8L2Rpdj5gXG4gICk7XG5cblxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXG4gICAgICAnYXBwL2NvbXBvbmVudHMvY24tZmxleC1mb3JtL2Zvcm1zL2NuLWN1cnJlbmN5Lmh0bWwnLFxuICAgICAgYFxuICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAge3tmb3JtLmh0bWxDbGFzc319XCJcbiAgICAgICAgICAgbmctY2xhc3M9XCJ7J2hhcy1lcnJvcic6IGhhc0Vycm9yKCksICdoYXMtc3VjY2Vzcyc6IGhhc1N1Y2Nlc3MoKX1cIj5cbiAgICAgICAgPGxhYmVsIGNsYXNzPVwiY29udHJvbC1sYWJlbFwiXG4gICAgICAgICAgICAgICBuZy1zaG93PVwic2hvd1RpdGxlKClcIlxuICAgICAgICAgICAgICAgZm9yPVwie3tmb3JtLmtleS5qb2luKCcuJyl9fVwiPnt7Zm9ybS50aXRsZX19PC9sYWJlbD5cbiAgICAgICAgPGRpdiBjbGFzcz1cInt7Zm9ybS5maWVsZENsYXNzfX0gaW5wdXQtZ3JvdXBcIj5cbiAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJpbnB1dC1ncm91cC1hZGRvblwiXG4gICAgICAgICAgICAgICAgIG5nLWRpc2FibGVkPVwiZm9ybS5yZWFkb25seVwiXG4gICAgICAgICAgICAgICAgIGZvcj1cInt7Zm9ybS5rZXkuam9pbignLicpfX1cIj4kPC9sYWJlbD5cbiAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIlxuICAgICAgICAgICAgICAgICBjbi1jdXJyZW5jeS1mb3JtYXQ9XCJ7e2Zvcm0uY3VycmVuY3lGb3JtYXR9fVwiXG4gICAgICAgICAgICAgICAgIGNuLWN1cnJlbmN5LXBsYWNlaG9sZGVyPVwie3tmb3JtLnBsYWNlaG9sZGVyfX1cIlxuICAgICAgICAgICAgICAgICBuZy1zaG93PVwiZm9ybS5rZXlcIlxuICAgICAgICAgICAgICAgICBuZy1tb2RlbC1vcHRpb25zPVwiZm9ybS5uZ01vZGVsT3B0aW9uc1wiXG4gICAgICAgICAgICAgICAgIG5nLWRpc2FibGVkPVwiZm9ybS5yZWFkb25seVwiXG4gICAgICAgICAgICAgICAgIHNmLWNoYW5nZWQ9XCJmb3JtXCJcbiAgICAgICAgICAgICAgICAgc2NoZW1hLXZhbGlkYXRlPVwiZm9ybVwiXG4gICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgc3RlcD1cImFueVwiXG4gICAgICAgICAgICAgICAgIG1pbj1cInt7Zm9ybS5taW59fVwiXG4gICAgICAgICAgICAgICAgIG1heD1cInt7Zm9ybS5tYXh9fVwiXG4gICAgICAgICAgICAgICAgIGlkPVwie3tmb3JtLmtleS5qb2luKCcuJyl9fVwiXG4gICAgICAgICAgICAgICAgIG5hbWU9XCJ7e2Zvcm0ua2V5LmpvaW4oJy4nKX19XCJcbiAgICAgICAgICAgICAgICAgbmctbW9kZWw9XCIkJHZhbHVlJCRcIj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaGVscC1ibG9ja1wiIHNmLW1lc3NhZ2U9XCJmb3JtLmRlc2NyaXB0aW9uXCI+PC9zcGFuPlxuICAgICAgPC9kaXY+YFxuICApO1xuXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcbiAgICAgICdhcHAvY29tcG9uZW50cy9jbi1mbGV4LWZvcm0vZm9ybXMvY24tdXJsLmh0bWwnLFxuICAgICAgYFxuICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAge3tmb3JtLmh0bWxDbGFzc319XCJcbiAgICAgICAgICAgbmctY2xhc3M9XCJ7J2hhcy1lcnJvcic6IGhhc0Vycm9yKCksICdoYXMtc3VjY2Vzcyc6IGhhc1N1Y2Nlc3MoKX1cIj5cbiAgICAgICAgPGxhYmVsIGNsYXNzPVwiY29udHJvbC1sYWJlbFwiXG4gICAgICAgICAgICAgICBuZy1zaG93PVwic2hvd1RpdGxlKClcIlxuICAgICAgICAgICAgICAgZm9yPVwie3tmb3JtLmtleS5qb2luKCcuJyl9fVwiPnt7Zm9ybS50aXRsZX19PC9sYWJlbD5cbiAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jb250cm9sXCJcbiAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiaHR0cHM6Ly9cIlxuICAgICAgICAgICAgICAgY24tdXJsLWZvcm1hdFxuICAgICAgICAgICAgICAgbmctc2hvdz1cImZvcm0ua2V5XCJcbiAgICAgICAgICAgICAgIG5nLW1vZGVsLW9wdGlvbnM9XCJmb3JtLm5nTW9kZWxPcHRpb25zXCJcbiAgICAgICAgICAgICAgIG5nLWRpc2FibGVkPVwiZm9ybS5yZWFkb25seVwiXG4gICAgICAgICAgICAgICBzZi1jaGFuZ2VkPVwiZm9ybVwiXG4gICAgICAgICAgICAgICBzY2hlbWEtdmFsaWRhdGU9XCJmb3JtXCJcbiAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgIGlkPVwie3tmb3JtLmtleS5qb2luKCcuJyl9fVwiXG4gICAgICAgICAgICAgICBuYW1lPVwie3tmb3JtLmtleS5qb2luKCcuJyl9fVwiXG4gICAgICAgICAgICAgICBuZy1tb2RlbD1cIiQkdmFsdWUkJFwiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImhlbHAtYmxvY2tcIiBzZi1tZXNzYWdlPVwiZm9ybS5kZXNjcmlwdGlvblwiPjwvc3Bhbj5cbiAgICAgIDwvZGl2PmBcbiAgKTtcblxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXG4gICAgICAnYXBwL2NvbXBvbmVudHMvY24tZmxleC1mb3JtL2Zvcm1zL2NuLXJhZGlvcy5odG1sJyxcbiAgICAgIGA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCB7e2Zvcm0uaHRtbENsYXNzfX1cIlxuICAgICAgICAgICAgbmctY2xhc3M9XCJ7J2hhcy1lcnJvcic6IGhhc0Vycm9yKCksICdoYXMtc3VjY2Vzcyc6IGhhc1N1Y2Nlc3MoKX1cIj5cbiAgICAgICAgIDxsYWJlbCBjbGFzcz1cImNvbnRyb2wtbGFiZWxcIiBuZy1zaG93PVwic2hvd1RpdGxlKClcIj57e2Zvcm0udGl0bGV9fTwvbGFiZWw+XG4gICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIGNsZWFyZml4XCI+XG4gICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInJhZGlvIHJhZGlvLWJsb2NrXCJcbiAgICAgICAgICAgICAgICAgIG5nLXJlcGVhdD1cIml0ZW0gaW4gZm9ybS50aXRsZU1hcFwiPlxuICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIlxuICAgICAgICAgICAgICAgICAgICBzZi1jaGFuZ2VkPVwiZm9ybVwiXG4gICAgICAgICAgICAgICAgICAgIG5nLWRpc2FibGVkPVwiZm9ybS5yZWFkb25seVwiXG4gICAgICAgICAgICAgICAgICAgIG5nLW1vZGVsPVwiJCR2YWx1ZSQkXCJcbiAgICAgICAgICAgICAgICAgICAgbmctbW9kZWwtb3B0aW9ucz1cImZvcm0ubmdNb2RlbE9wdGlvbnNcIlxuICAgICAgICAgICAgICAgICAgICBzY2hlbWEtdmFsaWRhdGU9XCJmb3JtXCJcbiAgICAgICAgICAgICAgICAgICAgZmYtdmFsaWRhdGU9XCJmb3JtXCJcbiAgICAgICAgICAgICAgICAgICAgbmctdmFsdWU9XCJpdGVtLnZhbHVlXCJcbiAgICAgICAgICAgICAgICAgICAgbmFtZT1cInt7Zm9ybS5rZXkuam9pbignLicpfX1cIj5cbiAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInJhZGlvLWJsb2NrLWljb25cIiBuZy1pZj1cIml0ZW0uaWNvbkNsYXNzIHx8IGl0ZW0uaWNvblBhdGhcIj5cbiAgICAgICAgICAgICAgIDxpIG5nLWlmPVwiaXRlbS5pY29uQ2xhc3NcIiBjbGFzcz1cImZhIGZhLXt7aXRlbS5pY29uQ2xhc3N9fSBmYS1sZ1wiPjwvaT5cbiAgICAgICAgICAgICAgIDxpbWcgbmctaWY9XCJpdGVtLmljb25QYXRoXCIgY2xhc3M9XCJjdXN0b21cIiBuZy1zcmM9XCJ7e2l0ZW0uaWNvblBhdGh9fVwiLz5cbiAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgPHNwYW4gbmctYmluZC1odG1sPVwiaXRlbS5uYW1lXCI+PC9zcGFuPlxuICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgPC9kaXY+XG4gICAgICAgICA8c3BhbiBjbGFzcz1cImhlbHAtYmxvY2tcIiBzZi1tZXNzYWdlPVwiZm9ybS5kZXNjcmlwdGlvblwiPjwvc3Bhbj5cbiAgICAgICA8L2Rpdj5gXG4gICk7XG5cbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFxuICAgICAgJ2FwcC9jb21wb25lbnRzL2NuLWZsZXgtZm9ybS9mb3Jtcy9jbi1yYWRpb2J1dHRvbnMuaHRtbCcsXG4gICAgICBgXG4gICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCBzY2hlbWEtZm9ybS1yYWRpb2J1dHRvbnMgY24tcmFkaW9idXR0b25zIHt7Zm9ybS5odG1sQ2xhc3N9fVwiXG4gICAgICAgICAgIG5nLWNsYXNzPVwieydoYXMtZXJyb3InOiBoYXNFcnJvcigpLCAnaGFzLXN1Y2Nlc3MnOiBoYXNTdWNjZXNzKCl9XCI+XG4gICAgICAgIDxsYWJlbCBjbGFzcz1cImNvbnRyb2wtbGFiZWxcIiBuZy1zaG93PVwic2hvd1RpdGxlKClcIj57e2Zvcm0udGl0bGV9fTwvbGFiZWw+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgY2xlYXJmaXhcIj5cbiAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJidG4gYnRuLXt7aXRlbS52YWx1ZX19IHt7Zm9ybS5idG5DbGFzc319IHt7aXRlbS52YWx1ZSA9PT0gJCR2YWx1ZSQkID8gJ2FjdGl2ZScgOiAnJ319XCJcbiAgICAgICAgICAgICAgICAgbmctcmVwZWF0PVwiaXRlbSBpbiBmb3JtLnRpdGxlTWFwXCI+XG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCJcbiAgICAgICAgICAgICAgICAgICBjbGFzcz1cInt7Zm9ybS5maWVsZEh0bWxDbGFzc319IGhpZGVcIlxuICAgICAgICAgICAgICAgICAgIHNmLWNoYW5nZWQ9XCJmb3JtXCJcbiAgICAgICAgICAgICAgICAgICBuZy1kaXNhYmxlZD1cImZvcm0ucmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgICAgIG5nLW1vZGVsPVwiJCR2YWx1ZSQkXCJcbiAgICAgICAgICAgICAgICAgICBuZy1tb2RlbC1vcHRpb25zPVwiZm9ybS5uZ01vZGVsT3B0aW9uc1wiXG4gICAgICAgICAgICAgICAgICAgc2NoZW1hLXZhbGlkYXRlPVwiZm9ybVwiXG4gICAgICAgICAgICAgICAgICAgZmYtdmFsaWRhdGU9XCJmb3JtXCJcbiAgICAgICAgICAgICAgICAgICBuZy12YWx1ZT1cIml0ZW0udmFsdWVcIlxuICAgICAgICAgICAgICAgICAgIG5hbWU9XCJ7e2Zvcm0ua2V5LmpvaW4oJy4nKX19XCI+XG4gICAgICAgICAgICA8aSBjbGFzcz1cImZhIGZhLXt7aXRlbS52YWx1ZX19IGZhLWxnXCI+PC9pPlxuICAgICAgICAgICAgPHNwYW4gbmctYmluZC1odG1sPVwiaXRlbS5uYW1lXCI+PC9zcGFuPlxuICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8c3BhbiBjbGFzcz1cImhlbHAtYmxvY2tcIiBzZi1tZXNzYWdlPVwiZm9ybS5kZXNjcmlwdGlvblwiPjwvc3Bhbj5cbiAgICAgIDwvZGl2PmBcbiAgKTtcblxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXG4gICAgICAnYXBwL2NvbXBvbmVudHMvY24tZmxleC1mb3JtL2Zvcm1zL2NuLXBlcmNlbnRhZ2UuaHRtbCcsXG4gICAgICBgXG4gICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCB7e2Zvcm0uaHRtbENsYXNzfX1cIlxuICAgICAgICAgICBuZy1jbGFzcz1cInsnaGFzLWVycm9yJzogaGFzRXJyb3IoKSwgJ2hhcy1zdWNjZXNzJzogaGFzU3VjY2VzcygpfVwiPlxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJjb250cm9sLWxhYmVsXCJcbiAgICAgICAgICAgICAgIG5nLXNob3c9XCJzaG93VGl0bGUoKVwiXG4gICAgICAgICAgICAgICBmb3I9XCJ7e2Zvcm0ua2V5ICYmIGZvcm0ua2V5WzBdfX1cIj57e2Zvcm0udGl0bGV9fTwvbGFiZWw+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ7e2Zvcm0uZmllbGRDbGFzc319IGlucHV0LWdyb3VwXCI+XG4gICAgICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jb250cm9sXCJcbiAgICAgICAgICAgICAgICAgY24tcGVyY2VudGFnZS1mb3JtYXRcbiAgICAgICAgICAgICAgICAgbmctc2hvdz1cImZvcm0ua2V5XCJcbiAgICAgICAgICAgICAgICAgbmctbW9kZWwtb3B0aW9ucz1cImZvcm0ubmdNb2RlbE9wdGlvbnNcIlxuICAgICAgICAgICAgICAgICBuZy1kaXNhYmxlZD1cImZvcm0ucmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgICBzZi1jaGFuZ2VkPVwiZm9ybVwiXG4gICAgICAgICAgICAgICAgIHNjaGVtYS12YWxpZGF0ZT1cImZvcm1cIlxuICAgICAgICAgICAgICAgICB0eXBlPVwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICAgc3RlcD1cImFueVwiXG4gICAgICAgICAgICAgICAgIG1pbj1cInt7Zm9ybS5taW59fVwiXG4gICAgICAgICAgICAgICAgIG1heD1cInt7Zm9ybS5tYXh9fVwiXG4gICAgICAgICAgICAgICAgIGlkPVwie3tmb3JtLmtleSAmJiBmb3JtLmtleVswXX19XCJcbiAgICAgICAgICAgICAgICAgbmFtZT1cInt7Zm9ybS5rZXkgJiYgZm9ybS5rZXlbMF19fVwiXG4gICAgICAgICAgICAgICAgIG5nLW1vZGVsPVwiJCR2YWx1ZSQkXCI+XG4gICAgICAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cC1hZGRvblwiXG4gICAgICAgICAgICAgICAgICBuZy1kaXNhYmxlZD1cImZvcm0ucmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgICAgZm9yPVwie3tmb3JtLmtleSAmJiBmb3JtLmtleVswXX19XCI+JTwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJoZWxwLWJsb2NrXCIgc2YtbWVzc2FnZT1cImZvcm0uZGVzY3JpcHRpb25cIj48L3NwYW4+XG4gICAgICA8L2Rpdj5gXG4gICk7XG5cbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFxuICAgICAgJ2FwcC9jb21wb25lbnRzL2NuLWZsZXgtZm9ybS9mb3Jtcy9jbi1kaXNwbGF5Lmh0bWwnLFxuICAgICAgYFxuICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgY24tZGlzcGxheXt7Zm9ybS5odG1sQ2xhc3N9fVwiPlxuICAgICAgICA8aW5wdXQgbmctc2hvdz1cImZvcm0ua2V5XCJcbiAgICAgICAgICAgICAgIGNsYXNzPVwiZm9ybS1jb250cm9sXCJcbiAgICAgICAgICAgICAgIGlkPVwie3tmb3JtLmtleS5qb2luKCcuJyl9fVwiXG4gICAgICAgICAgICAgICBuYW1lPVwie3tmb3JtLmtleS5qb2luKCcuJyl9fVwiXG4gICAgICAgICAgICAgICBuZy1kaXNhYmxlZD1cInRydWVcIlxuICAgICAgICAgICAgICAgdmFsdWU9XCJ7e2Zvcm0uZ2V0RGlzcGxheShmb3JtLmtleSwgZm9ybS5hcnJheUluZGV4KX19XCI+XG4gICAgICA8L2Rpdj5gXG4gICk7XG5cbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFxuICAgICAgJ2FwcC9jb21wb25lbnRzL2NuLWZsZXgtZm9ybS9mb3Jtcy9jbi1maWVsZHNldC5odG1sJyxcbiAgICAgIGBcbiAgICAgIDxmaWVsZHNldFxuICAgICAgICBuZy1kaXNhYmxlZD1cImZvcm0ucmVhZG9ubHlcIlxuICAgICAgICBjbGFzcz1cInNjaGVtYS1mb3JtLWZpZWxkc2V0IHt7Zm9ybS5odG1sQ2xhc3N9fVwiXG4gICAgICAgIG5nLWNsYXNzPVwieydib3JkZXJsZXNzJzogZm9ybS5wb3MgPT09IDAsICdub3RpdGxlJzogZm9ybS5ub3RpdGxlIHx8ICFmb3JtLnRpdGxlfVwiPlxuICAgICAgICA8bGVnZW5kIG5nLWhpZGU9XCJmb3JtLm5vdGl0bGVcIlxuICAgICAgICAgICAgICAgIG5nLWNsaWNrPVwiZm9ybS50b2dnbGVDb2xsYXBzZShmb3JtKVwiXG4gICAgICAgICAgICAgICAgbmctY2xhc3M9XCJ7J3NyLW9ubHknOiAhc2hvd1RpdGxlKCksIGNvbGxhcHNpYmxlOiBmb3JtLmNvbGxhcHNpYmxlfVwiXG4gICAgICAgICAgICAgICAgbmctbW91c2VlbnRlcj1cImZvcm0ucmVuZGVyID0gdHJ1ZVwiPlxuICAgICAgICAgIDxpIG5nLXNob3c9XCJmb3JtLmNvbGxhcHNpYmxlXCJcbiAgICAgICAgICAgICBjbGFzcz1cImZhIGZhLWNhcmV0LXt7Zm9ybS5jb2xsYXBzZWQgPyAncmlnaHQnIDogJ2Rvd24nfX1cIj48L2k+XG4gICAgICAgICAge3sgZm9ybS50aXRsZSB9fVxuICAgICAgICA8L2xlZ2VuZD5cbiAgICAgICAgPGRpdiBjbGFzcz1cImhlbHAtYmxvY2tcIiBuZy1zaG93PVwiZm9ybS5kZXNjcmlwdGlvblwiIG5nLWJpbmQtaHRtbD1cImZvcm0uZGVzY3JpcHRpb25cIj48L2Rpdj5cbiAgICAgICAgPGRpdiB1aWItY29sbGFwc2U9XCJmb3JtLmNvbGxhcHNlZFwiPlxuICAgICAgICAgIDxkaXYgbmctaWY9XCJmb3JtLnJlbmRlclwiPlxuICAgICAgICAgICAgPHNmLWRlY29yYXRvciBuZy1yZXBlYXQ9XCJpdGVtIGluIGZvcm0uaXRlbXNcIiBmb3JtPVwiaXRlbVwiLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2ZpZWxkc2V0PmBcbiAgKTtcblxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXG4gICAgICAnYXBwL2NvbXBvbmVudHMvY24tZmxleC1mb3JtL2Zvcm1zL2NuLW1lZGlhdXBsb2FkLmh0bWwnLFxuICAgICAgYFxuICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAge3tmb3JtLmh0bWxDbGFzc319XCJcbiAgICAgICAgICAgbmctY2xhc3M9XCJ7J2hhcy1lcnJvcic6IGhhc0Vycm9yKCksICdoYXMtc3VjY2Vzcyc6IGhhc1N1Y2Nlc3MoKX1cIj5cbiAgICAgICAgPGxhYmVsIGNsYXNzPVwiY29udHJvbC1sYWJlbFwiXG4gICAgICAgICAgICAgICBuZy1zaG93PVwic2hvd1RpdGxlKClcIlxuICAgICAgICAgICAgICAgZm9yPVwie3tmb3JtLmtleSAmJiBmb3JtLmtleVswXX19XCI+e3tmb3JtLnRpdGxlfX08L2xhYmVsPlxuICAgICAgICA8bWVkaWEtdXBsb2FkIG5nLW1vZGVsPVwiJCR2YWx1ZSQkXCJcbiAgICAgICAgICAgICAgICAgICAgICBjbi1kaXNhYmxlZD1cImZvcm0ucmVhZG9ubHlcIlxuICAgICAgICAgICAgICAgICAgICAgIGNuLWZpbGUtdHlwZT1cImZvcm0uZmlsZVR5cGVcIlxuICAgICAgICAgICAgICAgICAgICAgIGNuLXRleHQtYnV0dG9uPVwiZm9ybS50ZXh0QnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgICBjbi11cGxvYWQtcGF0aD1cImZvcm0udXBsb2FkUGF0aFwiXG4gICAgICAgICAgICAgICAgICAgICAgY24tZGF0YT1cImZvcm0uZGF0YVwiXG4gICAgICAgICAgICAgICAgICAgICAgY24tcHJldmlldy1wYXRoPVwiZm9ybS5wcmV2aWV3UGF0aFwiXG4gICAgICAgICAgICAgICAgICAgICAgY24tbW9kZWwtdmFsdWUta2V5PVwiZm9ybS5tb2RlbFZhbHVlS2V5XCJcbiAgICAgICAgICAgICAgICAgICAgICBjbi1leGlzdGluZy1wcmV2aWV3PVwiZm9ybS5leGlzdGluZ1ByZXZpZXdcIlxuICAgICAgICAgICAgICAgICAgICAgIGNuLWltYWdlLXByZXZpZXdzPVwiZm9ybS5kYXRhLmltYWdlUHJldmlld3NcIlxuICAgICAgICAgICAgICAgICAgICAgIGNuLWtleT1cImZvcm0ua2V5ICYmIGZvcm0ua2V5WzBdXCJcbiAgICAgICAgICAgICAgICAgICAgICBjbi1mb3JtPVwiZm9ybVwiXG4gICAgICAgICAgICAgICAgICAgICAgbmctbW9kZWwtb3B0aW9ucz1cImZvcm0ubmdNb2RlbE9wdGlvbnNcIlxuICAgICAgICAgICAgICAgICAgICAgIHNmLWNoYW5nZWQ9XCJmb3JtXCJcbiAgICAgICAgICAgICAgICAgICAgICBzY2hlbWEtdmFsaWRhdGU9XCJmb3JtXCJcbiAgICAgICAgICAgICAgICAgICAgICBmZi1mb3JtPVwiZm9ybVwiXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJjbGVhcmZpeFwiPlxuICAgICAgICA8L21lZGlhLXVwbG9hZD5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJoZWxwLWJsb2NrXCIgc2YtbWVzc2FnZT1cImZvcm0uZGVzY3JpcHRpb25cIj48L3NwYW4+XG4gICAgIDwvZGl2PmBcbiAgKTtcblxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXG4gICAgICAnYXBwL2NvbXBvbmVudHMvY24tZmxleC1mb3JtL2Zvcm1zL2NuLWNzdnVwbG9hZC5odG1sJyxcbiAgICAgIGBcbiAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHt7Zm9ybS5odG1sQ2xhc3N9fVwiXG4gICAgICAgICAgIG5nLWNsYXNzPVwieydoYXMtZXJyb3InOiBoYXNFcnJvcigpLCAnaGFzLXN1Y2Nlc3MnOiBoYXNTdWNjZXNzKCl9XCI+XG4gICAgICAgIDxsYWJlbCBjbGFzcz1cImNvbnRyb2wtbGFiZWxcIlxuICAgICAgICAgICAgICAgbmctc2hvdz1cInNob3dUaXRsZSgpXCJcbiAgICAgICAgICAgICAgIGZvcj1cInt7Zm9ybS5rZXkgJiYgZm9ybS5rZXlbMF19fVwiPnt7Zm9ybS50aXRsZX19PC9sYWJlbD5cbiAgICAgICAgPGNzdi11cGxvYWQgbmctbW9kZWw9XCIkJHZhbHVlJCRcIlxuICAgICAgICAgICAgICAgICAgICAgIGNuLXVwbG9hZC1wYXRoPVwiZm9ybS51cGxvYWRQYXRoXCJcbiAgICAgICAgICAgICAgICAgICAgICBuZy1tb2RlbC1vcHRpb25zPVwiZm9ybS5uZ01vZGVsT3B0aW9uc1wiXG4gICAgICAgICAgICAgICAgICAgICAgc2YtY2hhbmdlZD1cImZvcm1cIlxuICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYS12YWxpZGF0ZT1cImZvcm1cIlxuICAgICAgICAgICAgICAgICAgICAgIGZmLWZvcm09XCJmb3JtXCJcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImNsZWFyZml4XCI+XG4gICAgICAgIDwvY3N2LXVwbG9hZD5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJoZWxwLWJsb2NrXCIgc2YtbWVzc2FnZT1cImZvcm0uZGVzY3JpcHRpb25cIj48L3NwYW4+XG4gICAgIDwvZGl2PmBcbiAgKTtcblxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXG4gICAgICAnYXBwL2NvbXBvbmVudHMvY24tZmxleC1mb3JtL2Zvcm1zL2NuLXJldXNhYmxlLmh0bWwnLFxuICAgICAgYFxuICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgY24tcmV1c2FibGUge3tmb3JtLmh0bWxDbGFzc319XCJcbiAgICAgICAgICAgbmctY2xhc3M9XCJ7J2hhcy1lcnJvcic6IGhhc0Vycm9yKCksICdoYXMtc3VjY2Vzcyc6IGhhc1N1Y2Nlc3MoKX1cIj5cbiAgICAgICAgPGxhYmVsIGNsYXNzPVwiY29udHJvbC1sYWJlbFwiXG4gICAgICAgICAgICAgICBuZy1zaG93PVwic2hvd1RpdGxlKClcIlxuICAgICAgICAgICAgICAgZm9yPVwie3tmb3JtLmtleS5qb2luKCcuJyl9fVwiPnt7Zm9ybS50aXRsZX19PC9sYWJlbD5cbiAgICAgICAgPGNuLXNlbGVjdC1vclxuICAgICAgICAgIG5nLXNob3c9XCJmb3JtLmtleVwiXG4gICAgICAgICAgc2VsZWN0LWZyb209XCJmb3JtLmxpYnJhcnlcIlxuICAgICAgICAgIG5nLW1vZGVsPVwiJCR2YWx1ZSQkXCJcbiAgICAgICAgICBuZy1tb2RlbC1vcHRpb25zPVwiZm9ybS5uZ01vZGVsT3B0aW9uc1wiXG4gICAgICAgICAgc2YtY2hhbmdlZD1cImZvcm1cIlxuICAgICAgICAgIHNjaGVtYS12YWxpZGF0ZT1cImZvcm1cIlxuICAgICAgICAgIGZmLWZvcm09XCJmb3JtXCJcbiAgICAgICAgICBkaXJlY3RpdmVJZD1cImZvcm0uZGlyZWN0aXZlSWRcIlxuICAgICAgICAgIGl0ZW0tdGVtcGxhdGU9XCJmb3JtLml0ZW1UZW1wbGF0ZVwiXG4gICAgICAgICAgdG9nZ2xlLXRleHQ9XCJmb3JtLnRvZ2dsZVRleHRcIlxuICAgICAgICAgIG5nLWRpc2FibGVkPVwiZm9ybS5yZWFkb25seVwiXG4gICAgICAgICAgdmlldz1cImZvcm0udmlld1wiPlxuICAgICAgICAgIDxzZi1kZWNvcmF0b3IgbmctcmVwZWF0PVwiaXRlbSBpbiBmb3JtLml0ZW1zXCIgZm9ybT1cIml0ZW1cIi8+XG4gICAgICAgIDwvY24tc2VsZWN0LW9yPlxuICAgICAgICA8cCBuZy1pZj1cImZvcm0ubG9hZE1vcmUgJiYgZm9ybS52aWV3ID09PSAnbGlzdCdcIj5cbiAgICAgICAgICA8YSBuZy1jbGljaz1cImZvcm0ubG9hZE1vcmUoKVwiXG4gICAgICAgICAgICAgY2xhc3M9XCJidG4gYnRuLWRlZmF1bHQgYnRuLWJsb2NrXCI+TG9hZCBNb3JlPC9hPlxuICAgICAgICA8L3A+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaGVscC1ibG9ja1wiIHNmLW1lc3NhZ2U9XCJmb3JtLmRlc2NyaXB0aW9uXCI+PC9zcGFuPlxuICAgICAgPC9kaXY+YFxuICApO1xuXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcbiAgICAgICdhcHAvY29tcG9uZW50cy9jbi1mbGV4LWZvcm0vZm9ybXMvY24tdGFibGUuaHRtbCcsXG4gICAgICBgXG4gICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCBjbi1mZi10YWJsZSB7e2Zvcm0uaHRtbENsYXNzfX1cIlxuICAgICAgICAgICBuZy1jbGFzcz1cInsnaGFzLWVycm9yJzogaGFzRXJyb3IoKSwgJ2hhcy1zdWNjZXNzJzogaGFzU3VjY2VzcygpfVwiPlxuICAgICAgICA8aDY+e3tmb3JtLnRpdGxlfX08L2g2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgPGRpdiBuZy1yZXBlYXQ9XCJjb2wgaW4gZm9ybS5jb2x1bW5zXCIgY2xhc3M9XCJ7e2NvbC5jb2x1bW5XaWR0aH19XCI+XG4gICAgICAgICAgICA8cCBjbGFzcz1cImNvbHVtbi1oZWFkZXJcIj57e2NvbC5jb2x1bW5IZWFkZXJ9fTwvcD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIiBuZy1yZXBlYXQ9XCJyb3cgaW4gZm9ybS5pdGVtc1wiPlxuICAgICAgICAgIDxkaXYgbmctcmVwZWF0PVwiY29sIGluIHJvdy5pdGVtc1wiIGNsYXNzPVwie3tjb2wuY29sdW1uV2lkdGh9fVwiPlxuICAgICAgICAgICAgPHNmLWRlY29yYXRvciBmb3JtPVwiY29sXCI+PC9zZi1kZWNvcmF0b3I+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8c3BhbiBjbGFzcz1cImhlbHAtYmxvY2tcIiBzZi1tZXNzYWdlPVwiZm9ybS5kZXNjcmlwdGlvblwiPjwvc3Bhbj5cbiAgICAgIDwvZGl2PmBcbiAgKTtcblxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXG4gICAgICAnYXBwL2NvbXBvbmVudHMvY24tZmxleC1mb3JtL2Zvcm1zL2NuLWNyZWF0aXZlaW1hZ2UuaHRtbCcsXG4gICAgICBgXG4gICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCB7e2Zvcm0uaHRtbENsYXNzfX1cIlxuICAgICAgICAgICBuZy1jbGFzcz1cInsnaGFzLWVycm9yJzogaGFzRXJyb3IoKSwgJ2hhcy1zdWNjZXNzJzogaGFzU3VjY2VzcygpfVwiPlxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJjb250cm9sLWxhYmVsXCJcbiAgICAgICAgICAgICAgIG5nLXNob3c9XCJzaG93VGl0bGUoKVwiXG4gICAgICAgICAgICAgICBmb3I9XCJ7e2Zvcm0ua2V5ICYmIGZvcm0ua2V5WzBdfX1cIj57e2Zvcm0udGl0bGV9fTwvbGFiZWw+XG4gICAgICAgIDxjbi1jcmVhdGl2ZS1pbWFnZSBuZy1tb2RlbD1cIiQkdmFsdWUkJFwiXG4gICAgICAgICAgICAgICAgICAgICAgY24tZGlzYWJsZWQ9XCJmb3JtLnJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICAgICAgICBjbi11cGxvYWQtcGF0aD1cImZvcm0udXBsb2FkUGF0aFwiXG4gICAgICAgICAgICAgICAgICAgICAgY24tZGF0YT1cImZvcm0uZGF0YVwiXG4gICAgICAgICAgICAgICAgICAgICAgY24tcHJldmlldy1wYXRoPVwiZm9ybS5wcmV2aWV3UGF0aFwiXG4gICAgICAgICAgICAgICAgICAgICAgY24tbW9kZWwtdmFsdWUta2V5PVwiZm9ybS5tb2RlbFZhbHVlS2V5XCJcbiAgICAgICAgICAgICAgICAgICAgICBjbi1leGlzdGluZy1wcmV2aWV3PVwiZm9ybS5leGlzdGluZ1ByZXZpZXdcIlxuICAgICAgICAgICAgICAgICAgICAgIG5nLW1vZGVsLW9wdGlvbnM9XCJmb3JtLm5nTW9kZWxPcHRpb25zXCJcbiAgICAgICAgICAgICAgICAgICAgICBjbi1uZy1tb2RlbC1rZXk9XCJmb3JtLm5nTW9kZWxLZXlcIlxuICAgICAgICAgICAgICAgICAgICAgIHNmLWNoYW5nZWQ9XCJmb3JtXCJcbiAgICAgICAgICAgICAgICAgICAgICBzY2hlbWEtdmFsaWRhdGU9XCJmb3JtXCJcbiAgICAgICAgICAgICAgICAgICAgICBmZi1mb3JtPVwiZm9ybVwiXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJjbGVhcmZpeFwiPlxuICAgICAgICA8L2NuLWNyZWF0aXZlLWltYWdlPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImhlbHAtYmxvY2tcIiBzZi1tZXNzYWdlPVwiZm9ybS5kZXNjcmlwdGlvblwiPjwvc3Bhbj5cbiAgICAgPC9kaXY+YFxuICApO1xuXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcbiAgICAnYXBwL2NvbXBvbmVudHMvY24tZmxleC1mb3JtL2Zvcm1zL2NuLXNjaGVkdWxlLmh0bWwnLFxuICAgIGBcbiAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwIHt7IGZvcm0uaHRtbENsYXNzIH19XCJcbiAgICAgICAgICAgbmctY2xhc3M9XCJ7ICdoYXMtZXJyb3InOiBoYXNFcnJvcigpLCAnaGFzLXN1Y2Nlc3MnOiBoYXNTdWNjZXNzKCkgfVwiPlxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJjb250cm9sLWxhYmVsXCJcbiAgICAgICAgICAgICAgIG5nLXNob3c9XCJzaG93VGl0bGUoKVwiXG4gICAgICAgICAgICAgICBmb3I9XCJ7eyBmb3JtLmtleS5qb2luKCcuJykgfX1cIj5cbiAgICAgICAgICB7eyBmb3JtLnRpdGxlIH19XG4gICAgICAgIDwvbGFiZWw+XG4gICAgICAgIDxjbi1zY2hlZHVsZSBmb3JtPVwiZm9ybVwiXG4gICAgICAgICAgICAgICAgICAgICBuZy1tb2RlbD1cIiQkdmFsdWUkJFwiPlxuICAgICAgICA8L2NuLXNjaGVkdWxlPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImhlbHAtYmxvY2tcIiBzZi1tZXNzYWdlPVwiZm9ybS5kZXNjcmlwdGlvblwiPjwvc3Bhbj5cbiAgICAgIDwvZGl2PlxuICAgIGBcbiAgKTtcblxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXG4gICAgICAnYXBwL2NvbXBvbmVudHMvY24tZmxleC1mb3JtL2Zvcm1zL2NuLWZhY2Vib29rdmlkZW8uaHRtbCcsXG4gICAgICBgXG4gICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCB7e2Zvcm0uaHRtbENsYXNzfX1cIlxuICAgICAgICAgICBuZy1jbGFzcz1cInsnaGFzLWVycm9yJzogaGFzRXJyb3IoKSwgJ2hhcy1zdWNjZXNzJzogaGFzU3VjY2VzcygpfVwiPlxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJjb250cm9sLWxhYmVsXCJcbiAgICAgICAgICAgICAgIG5nLXNob3c9XCJzaG93VGl0bGUoKVwiXG4gICAgICAgICAgICAgICBmb3I9XCJ7e2Zvcm0ua2V5ICYmIGZvcm0ua2V5WzBdfX1cIj57e2Zvcm0udGl0bGV9fTwvbGFiZWw+XG4gICAgICAgIDxjbi1mYWNlYm9vay12aWRlbyBuZy1tb2RlbD1cIiQkdmFsdWUkJFwiXG4gICAgICAgICAgICAgICAgICAgICAgY24tZGlzYWJsZWQ9XCJmb3JtLnJlYWRvbmx5XCJcbiAgICAgICAgICAgICAgICAgICAgICBjbi11cGxvYWQtcGF0aD1cImZvcm0udXBsb2FkUGF0aFwiXG4gICAgICAgICAgICAgICAgICAgICAgY24tZGF0YT1cImZvcm0uZGF0YVwiXG4gICAgICAgICAgICAgICAgICAgICAgY24tcHJldmlldy1wYXRoPVwiZm9ybS5wcmV2aWV3UGF0aFwiXG4gICAgICAgICAgICAgICAgICAgICAgY24tbW9kZWwtdmFsdWUta2V5PVwiZm9ybS5tb2RlbFZhbHVlS2V5XCJcbiAgICAgICAgICAgICAgICAgICAgICBjbi1leGlzdGluZy1wcmV2aWV3PVwiZm9ybS5leGlzdGluZ1ByZXZpZXdcIlxuICAgICAgICAgICAgICAgICAgICAgIG5nLW1vZGVsLW9wdGlvbnM9XCJmb3JtLm5nTW9kZWxPcHRpb25zXCJcbiAgICAgICAgICAgICAgICAgICAgICBjbi12aWRlby1rZXk9XCJmb3JtLnZpZGVvS2V5XCJcbiAgICAgICAgICAgICAgICAgICAgICBjbi10aHVtYm5haWwta2V5PVwiZm9ybS50aHVtYm5haWxLZXlcIlxuICAgICAgICAgICAgICAgICAgICAgIGNuLWltYWdlLWlkLWtleT1cImZvcm0uaW1hZ2VJZEtleVwiXG4gICAgICAgICAgICAgICAgICAgICAgc2YtY2hhbmdlZD1cImZvcm1cIlxuICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYS12YWxpZGF0ZT1cImZvcm1cIlxuICAgICAgICAgICAgICAgICAgICAgIGZmLWZvcm09XCJmb3JtXCJcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImNsZWFyZml4XCI+XG4gICAgICAgIDwvY24tZmFjZWJvb2stdmlkZW8+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaGVscC1ibG9ja1wiIHNmLW1lc3NhZ2U9XCJmb3JtLmRlc2NyaXB0aW9uXCI+PC9zcGFuPlxuICAgICA8L2Rpdj5gXG4gICk7XG59XG5cbmV4cG9ydCB7IHNjaGVtYUZvcm1Db25maWcsIGFkZFRlbXBsYXRlcyB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NjaGVtYS1mb3JtLWV4dGVuc2lvbnMuanMiLCIvLyBOZWVkIHRoZXNlIG1vZHVsZXMgZm9yIHRlc3QgYnVuZGxlXG52YXIgXyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5fKSB8fCByZXF1aXJlKFwibG9kYXNoXCIpO1xudmFyIE9iamVjdFBhdGggPVxuICAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuT2JqZWN0UGF0aCkgfHwgcmVxdWlyZShcIm9iamVjdHBhdGhcIik7XG5cbmNvbnN0IGZpZWxkVHlwZUhhbmRsZXJzID0ge1xuICBmaWVsZHNldDogXCJwcm9jZXNzRmllbGRzZXRcIixcbiAgXCJjbi1yYWRpb3NcIjogXCJwcm9jZXNzUmFkaW9zXCIsXG4gIFwiY24tcmFkaW9idXR0b25zXCI6IFwicHJvY2Vzc1JhZGlvYnV0dG9uc1wiLFxuICBcImNuLWF1dG9jb21wbGV0ZVwiOiBcInByb2Nlc3NTZWxlY3RcIixcbiAgXCJjbi1kYXRldGltZXBpY2tlclwiOiBcInByb2Nlc3NEYXRlXCIsXG4gIGhlbHA6IFwicHJvY2Vzc0hlbHBcIixcbiAgXCJjbi1kaXNwbGF5XCI6IFwicHJvY2Vzc0Rpc3BsYXlcIixcbiAgXCJjbi1udW1iZXJcIjogXCJwcm9jZXNzTnVtYmVyXCIsXG4gIFwiY24tY3VycmVuY3lcIjogXCJwcm9jZXNzQ3VycmVuY3lcIixcbiAgXCJjbi1wZXJjZW50YWdlXCI6IFwicHJvY2Vzc1BlcmNlbnRhZ2VcIixcbiAgXCJjbi11cmxcIjogXCJwcm9jZXNzVXJsXCIsXG4gIFwiY24tbWVkaWF1cGxvYWRcIjogXCJwcm9jZXNzTWVkaWFVcGxvYWRcIixcbiAgXCJjbi1jcmVhdGl2ZWltYWdlXCI6IFwicHJvY2Vzc0NyZWF0aXZlSW1hZ2VcIixcbiAgXCJjbi1mYWNlYm9va3ZpZGVvXCI6IFwicHJvY2Vzc0ZhY2Vib29rVmlkZW9cIixcbiAgXCJjbi1jc3Z1cGxvYWRcIjogXCJwcm9jZXNzQ3N2VXBsb2FkXCIsXG4gIFwiY24tcmV1c2FibGVcIjogXCJwcm9jZXNzUmV1c2FibGVcIixcbiAgXCJjbi10b2dnbGVcIjogXCJwcm9jZXNzVG9nZ2xlXCIsXG4gIFwiY24tdGFibGVcIjogXCJwcm9jZXNzVGFibGVcIixcbiAgY29tcG9uZW50OiBcInByb2Nlc3NDb21wb25lbnRcIixcbiAgc2VjdGlvbjogXCJwcm9jZXNzU2VjdGlvblwiLFxuICB0YWJhcnJheTogXCJwcm9jZXNzU2VjdGlvblwiLFxuICBhcnJheTogXCJwcm9jZXNzQXJyYXlcIixcbiAgXCJjbi1zY2hlZHVsZVwiOiBcInByb2Nlc3NTY2hlZHVsZVwiLFxufTtcblxuLy8gaGFuZGxlcnMgdGhhdCBkb24ndCBydW4gb24gc2Vjb25kUGFzcyBhcmUgb25lcyB0aGF0IHNob3VsZG4ndCBldmVyIGNoYW5nZVxuLy8gYW5kIHdlIHdhbnQgdG8gYXZvaWQgY29tcG91bmRpbmcgdGhlaXIgZWZmZWN0c1xuY29uc3QgZmllbGRQcm9wSGFuZGxlcnMgPSBbXG4gIHtcbiAgICBwcm9wOiBcImRlZmF1bHRcIixcbiAgICBoYW5kbGVyOiAoZmllbGQsIHNlcnZpY2UpID0+IHNlcnZpY2UucHJvY2Vzc0RlZmF1bHQoZmllbGQpLFxuICB9LFxuICB7XG4gICAgcHJvcDogXCJyZXNvbHZlXCIsXG4gICAgaGFuZGxlcjogKGZpZWxkLCBzZXJ2aWNlLCBzZWNvbmRQYXNzKSA9PlxuICAgICAgIXNlY29uZFBhc3MgJiYgc2VydmljZS5wcm9jZXNzUmVzb2x2ZShmaWVsZCksXG4gIH0sXG4gIHtcbiAgICBwcm9wOiBcInNlbGVjdERpc3BsYXlcIixcbiAgICBoYW5kbGVyOiAoZmllbGQsIHNlcnZpY2UpID0+IHNlcnZpY2UucHJvY2Vzc1NlbGVjdERpc3BsYXkoZmllbGQpLFxuICB9LFxuICB7XG4gICAgcHJvcDogXCJzY2hlbWFcIixcbiAgICBoYW5kbGVyOiAoZmllbGQsIHNlcnZpY2UpID0+XG4gICAgICBfLmlzVW5kZWZpbmVkKGZpZWxkLmRlZmF1bHQpICYmXG4gICAgICAhXy5pc1VuZGVmaW5lZChmaWVsZC5zY2hlbWEuZGVmYXVsdCkgJiZcbiAgICAgIHNlcnZpY2UucHJvY2Vzc0RlZmF1bHQoZmllbGQpLFxuICB9LFxuICB7XG4gICAgcHJvcDogXCJ3YXRjaFwiLFxuICAgIGhhbmRsZXI6IChmaWVsZCwgc2VydmljZSwgc2Vjb25kUGFzcykgPT5cbiAgICAgICFzZWNvbmRQYXNzICYmIGZpZWxkLndhdGNoICYmIHNlcnZpY2UucHJvY2Vzc0ZpZWxkV2F0Y2goZmllbGQpLFxuICB9LFxuICB7XG4gICAgcHJvcDogXCJ0eXBlXCIsXG4gICAgaGFuZGxlcjogKGZpZWxkLCBzZXJ2aWNlLCBzZWNvbmRQYXNzKSA9PlxuICAgICAgc2VydmljZS5wcm9jZXNzRmllbGRUeXBlKGZpZWxkLCBzZWNvbmRQYXNzKSxcbiAgfSxcbiAge1xuICAgIHByb3A6IFwiY29uZGl0aW9uYWxzXCIsXG4gICAgaGFuZGxlcjogKGZpZWxkLCBzZXJ2aWNlKSA9PiBzZXJ2aWNlLnByb2Nlc3NDb25kaXRpb25hbChmaWVsZCksXG4gIH0sXG4gIHtcbiAgICBwcm9wOiBcInVwZGF0ZVNjaGVtYVwiLFxuICAgIGhhbmRsZXI6IChmaWVsZCwgc2VydmljZSwgc2Vjb25kUGFzcykgPT5cbiAgICAgICFzZWNvbmRQYXNzICYmIHNlcnZpY2UucHJvY2Vzc0ZpZWxkVXBkYXRlZFNjaGVtYShmaWVsZCksXG4gIH0sXG5dO1xuXG5mdW5jdGlvbiBjbkZsZXhGb3JtU2VydmljZVByb3ZpZGVyKFxuICBzY2hlbWFGb3JtRGVjb3JhdG9yc1Byb3ZpZGVyLFxuICBjbkZsZXhGb3JtVHlwZXNQcm92aWRlclxuKSB7XG4gIFwibmdJbmplY3RcIjtcblxuICByZXR1cm4ge1xuICAgIHJlZ2lzdGVyRmllbGQsXG4gICAgJGdldDogQ05GbGV4Rm9ybVNlcnZpY2UsXG4gIH07XG5cbiAgLy8vLy8vLy8vL1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyRmllbGQoZmllbGRUeXBlKSB7XG4gICAgaWYgKGZpZWxkVHlwZS5jb25kaXRpb24pIHtcbiAgICAgIGNuRmxleEZvcm1UeXBlc1Byb3ZpZGVyLnJlZ2lzdGVyRmllbGRUeXBlKHtcbiAgICAgICAgY29uZGl0aW9uOiBmaWVsZFR5cGUuY29uZGl0aW9uLFxuICAgICAgICB0eXBlOiBmaWVsZFR5cGUudHlwZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChmaWVsZFR5cGUuaGFuZGxlcikge1xuICAgICAgZmllbGRUeXBlSGFuZGxlcnNbZmllbGRUeXBlLnR5cGVdID0gZmllbGRUeXBlLmhhbmRsZXI7XG4gICAgfVxuXG4gICAgaWYgKGZpZWxkVHlwZS50ZW1wbGF0ZVVybCkge1xuICAgICAgc2NoZW1hRm9ybURlY29yYXRvcnNQcm92aWRlci5hZGRNYXBwaW5nKFxuICAgICAgICBcImJvb3RzdHJhcERlY29yYXRvclwiLFxuICAgICAgICBmaWVsZFR5cGUudHlwZSxcbiAgICAgICAgZmllbGRUeXBlLnRlbXBsYXRlVXJsXG4gICAgICApO1xuICAgICAgc2NoZW1hRm9ybURlY29yYXRvcnNQcm92aWRlci5jcmVhdGVEaXJlY3RpdmUoXG4gICAgICAgIGZpZWxkVHlwZS50eXBlLFxuICAgICAgICBmaWVsZFR5cGUudGVtcGxhdGVVcmxcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIENORmxleEZvcm1TZXJ2aWNlKFxuICBBcGksXG4gICRwYXJzZSxcbiAgY25GbGV4Rm9ybUNvbmZpZyxcbiAgY25GbGV4Rm9ybVR5cGVzLFxuICBzZlBhdGgsXG4gICRpbnRlcnBvbGF0ZSxcbiAgJHRpbWVvdXQsXG4gIGNuVXRpbCxcbiAgJHN0YXRlUGFyYW1zXG4pIHtcbiAgXCJuZ0luamVjdFwiO1xuXG4gIGNvbnN0IHNlcnZpY2VzID0gW107XG4gIGNvbnN0IHByb3RvdHlwZSA9IHtcbiAgICBjb21waWxlLFxuICAgIGFkZEFycmF5Q29weSxcbiAgICBhZGRUb0RhdGFDYWNoZSxcbiAgICBhZGRUb0Zvcm1DYWNoZSxcbiAgICBhZGRUb1Njb3BlQ2FjaGUsXG4gICAgYnJvYWRjYXN0RXJyb3JzLFxuICAgIGJ1aWxkRXJyb3IsXG4gICAgY2xlYW51cCxcbiAgICBkZWxldGVBcnJheUNvcGllc0ZvcixcbiAgICBkZXJlZ2lzdGVySGFuZGxlcnMsXG4gICAgZGVyZWdpc3RlckFycmF5SGFuZGxlcnMsXG4gICAgZ2V0QXJyYXlDb3B5LFxuICAgIGdldEFycmF5Q29waWVzLFxuICAgIGdldEFycmF5Q29waWVzRm9yLFxuICAgIGdldEFycmF5U2NvcGVzLFxuICAgIGdldERlZmF1bHQsXG4gICAgZ2V0RnJvbURhdGFDYWNoZSxcbiAgICBnZXRGcm9tRm9ybUNhY2hlLFxuICAgIGdldEZyb21TY29wZUNhY2hlLFxuICAgIGdldEZvcm1zVG9Qcm9jZXNzLFxuICAgIGdldEtleSxcbiAgICBnZXRTY2hlbWEsXG4gICAgZ2V0V2F0Y2hhYmxlcyxcbiAgICBoYW5kbGVSZXNvbHZlLFxuICAgIGluY3JlbWVudFVwZGF0ZXMsXG4gICAgaW5pdEFycmF5Q29weVdhdGNoLFxuICAgIGluaXRNb2RlbFdhdGNoLFxuICAgIGluaXRTY2hlbWFQYXJhbXMsXG4gICAgaXNDb21waWxlZCxcbiAgICBvbk1vZGVsV2F0Y2gsXG4gICAgcGFyc2VBbGwsXG4gICAgcGFyc2VBbnksXG4gICAgcGFyc2VDb25kaXRpb24sXG4gICAgcGFyc2VFeHByZXNzaW9uLFxuICAgIHByb2Nlc3NBcnJheSxcbiAgICBwcm9jZXNzQ3JlYXRpdmVJbWFnZSxcbiAgICBwcm9jZXNzRGVmYXVsdCxcbiAgICBwcm9jZXNzRGlzcGxheSxcbiAgICBwcm9jZXNzRmFjZWJvb2tWaWRlbyxcbiAgICBwcm9jZXNzRmllbGQsXG4gICAgcHJvY2Vzc0ZpZWxkc2V0LFxuICAgIHByb2Nlc3NGaWVsZFByb3BzLFxuICAgIHByb2Nlc3NGaWVsZFR5cGUsXG4gICAgcHJvY2Vzc0ZpZWxkVXBkYXRlZFNjaGVtYSxcbiAgICBwcm9jZXNzRmllbGRXYXRjaCxcbiAgICBwcm9jZXNzQ29tcG9uZW50LFxuICAgIHByb2Nlc3NDb25kaXRpb25hbCxcbiAgICBwcm9jZXNzQ3VycmVuY3ksXG4gICAgcHJvY2Vzc051bWJlcixcbiAgICBwcm9jZXNzUGVyY2VudGFnZSxcbiAgICBwcm9jZXNzVXJsLFxuICAgIHByb2Nlc3NEYXRlLFxuICAgIHByb2Nlc3NIZWxwLFxuICAgIHByb2Nlc3NSYWRpb3MsXG4gICAgcHJvY2Vzc1JhZGlvYnV0dG9ucyxcbiAgICBwcm9jZXNzUmV1c2FibGUsXG4gICAgcHJvY2Vzc1NjaGVtYSxcbiAgICBwcm9jZXNzU2VsZWN0RGlzcGxheSxcbiAgICBwcm9jZXNzUmVzb2x2ZSxcbiAgICBwcm9jZXNzU2VjdGlvbixcbiAgICBwcm9jZXNzU2VsZWN0LFxuICAgIHByb2Nlc3NTY2hlZHVsZSxcbiAgICBwcm9jZXNzVGFibGUsXG4gICAgcHJvY2Vzc1RlbXBsYXRlLFxuICAgIHByb2Nlc3NUb2dnbGUsXG4gICAgcHJvY2Vzc1VwZGF0ZWRTY2hlbWEsXG4gICAgcHJvY2Vzc01lZGlhVXBsb2FkLFxuICAgIHByb2Nlc3NDc3ZVcGxvYWQsXG4gICAgcmVnaXN0ZXJBcnJheUhhbmRsZXJzLFxuICAgIHJlZ2lzdGVySGFuZGxlcixcbiAgICByZWdpc3RlclJlc29sdmUsXG4gICAgcmVwbGFjZUFycmF5SW5kZXgsXG4gICAgcmVwcm9jZXNzRmllbGQsXG4gICAgcmVzZXRVcGRhdGVzLFxuICAgIHJlc29sdmVOZXN0ZWRFeHByZXNzaW9ucyxcbiAgICBzZXRBcnJheUluZGV4LFxuICAgIHNldHVwQ29uZmlnLFxuICAgIHNldHVwU2NoZW1hUmVmcmVzaCxcbiAgICBzaWxlbmNlTGlzdGVuZXJzLFxuICAgIHNraXBEZWZhdWx0cyxcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRTZXJ2aWNlKGZuKSB7XG4gICAgcmV0dXJuIF8uZmluZChzZXJ2aWNlcywgZm4pO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveVNlcnZpY2UoZm4pIHtcbiAgICBjb25zdCBzZXJ2aWNlID0gZ2V0U2VydmljZShmbik7XG4gICAgaWYgKHNlcnZpY2UpIHtcbiAgICAgIHNlcnZpY2UuY2xlYW51cCgpO1xuICAgICAgXy5lbXB0eShzZXJ2aWNlKTtcbiAgICAgIF8ucmVtb3ZlKHNlcnZpY2VzLCAocykgPT4gcyA9PT0gc2VydmljZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gQ05GbGV4Rm9ybUNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgW3NjaGVtYSwgbW9kZWwsIGNvbmZpZ10gPSBhcmdzO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgeyBzY2hlbWEsIG1vZGVsLCBjb25maWcgfSA9IGFyZ3NbMF07XG4gICAgfVxuXG4gICAgY29uc3QgY3VyU2VydmljZSA9IGdldFNlcnZpY2UoKHNlcnZpY2UpID0+IHNlcnZpY2UubW9kZWwgPT09IG1vZGVsKTtcbiAgICBpZiAoY3VyU2VydmljZSkge1xuICAgICAgaWYgKHNjaGVtYSkge1xuICAgICAgICBjdXJTZXJ2aWNlLmNvbXBpbGUoc2NoZW1hLCBtb2RlbCwgY29uZmlnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJTZXJ2aWNlO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld1NlcnZpY2UgPSBuZXcgQ05GbGV4Rm9ybShzY2hlbWEsIG1vZGVsLCBjb25maWcpO1xuICAgIHNlcnZpY2VzLnB1c2gobmV3U2VydmljZSk7XG4gICAgcmV0dXJuIG5ld1NlcnZpY2U7XG4gIH1cblxuICBmdW5jdGlvbiBDTkZsZXhGb3JtKHNjaGVtYSwgbW9kZWwsIGNvbmZpZykge1xuICAgIGlmICgkc3RhdGVQYXJhbXMuZGVidWcpIHtcbiAgICAgIHdpbmRvdy5zZXJ2aWNlcyA9IHNlcnZpY2VzO1xuICAgIH1cblxuICAgIHRoaXMuYXJyYXlDb3BpZXMgPSB7fTtcbiAgICB0aGlzLmFycmF5TGlzdGVuZXJzID0ge307XG4gICAgdGhpcy5kYXRhQ2FjaGUgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRzID0ge307XG4gICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICAgIHRoaXMuZm9ybUNhY2hlID0ge307XG4gICAgdGhpcy5zY29wZUNhY2hlID0ge307XG4gICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICB0aGlzLnJlc29sdmVSZWdpc3RlciA9IHt9O1xuICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICB0aGlzLnVwZGF0ZXMgPSAwO1xuICAgIHRoaXMuc2tpcERlZmF1bHQgPSB7fTtcblxuICAgIGNvbnN0IG92ZXJyaWRlcyA9IGNvbmZpZy5nZXRQYXJhbXMgPyBjb25maWcuZ2V0UGFyYW1zKCkgOiB7fTtcbiAgICB0aGlzLnBhcmFtcyA9IGNuRmxleEZvcm1Db25maWcuZ2V0U3RhdGVQYXJhbXMob3ZlcnJpZGVzKTtcblxuICAgIHRoaXMuXyA9IF87XG5cbiAgICB0aGlzLmNvbXBpbGUoc2NoZW1hLCBtb2RlbCwgY29uZmlnKTtcbiAgfVxuXG4gIF8uZXh0ZW5kKENORmxleEZvcm0ucHJvdG90eXBlLCBwcm90b3R5cGUpO1xuICBfLmV4dGVuZChDTkZsZXhGb3JtQ29uc3RydWN0b3IsIHByb3RvdHlwZSwgeyBnZXRTZXJ2aWNlLCBkZXN0cm95U2VydmljZSB9KTtcblxuICByZXR1cm4gQ05GbGV4Rm9ybUNvbnN0cnVjdG9yO1xuXG4gIC8vLy8vLy8vLy8vLy8vXG5cbiAgZnVuY3Rpb24gY29tcGlsZShzY2hlbWEsIG1vZGVsLCBjb25maWcpIHtcbiAgICB2YXIgc2VydmljZSA9IHRoaXM7XG5cbiAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5nZXRTY29wZSkge1xuICAgICAgc2VydmljZS5zY29wZSA9IGNvbmZpZy5nZXRTY29wZSgpO1xuICAgIH1cbiAgICBzZXJ2aWNlLnNjaGVtYSA9IHNjaGVtYTtcbiAgICBzZXJ2aWNlLm1vZGVsID0gbW9kZWw7XG5cbiAgICBpZiAoIXNlcnZpY2UuaXNDb21waWxlZCgpKSB7XG4gICAgICBzZXJ2aWNlLnNldHVwQ29uZmlnKGNvbmZpZyk7XG5cbiAgICAgIGlmIChzY2hlbWEuZm9ybXMpIHtcbiAgICAgICAgXy5lYWNoKHNjaGVtYS5mb3JtcywgZnVuY3Rpb24gKGZvcm0pIHtcbiAgICAgICAgICBfLmVhY2goZm9ybS5mb3JtLCBzZXJ2aWNlLnByb2Nlc3NGaWVsZC5iaW5kKHNlcnZpY2UpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfLmVhY2goc2NoZW1hLmZvcm0sIHNlcnZpY2UucHJvY2Vzc0ZpZWxkLmJpbmQoc2VydmljZSkpO1xuICAgICAgfVxuXG4gICAgICBzZXJ2aWNlLmluaXRNb2RlbFdhdGNoKCk7XG4gICAgICBzZXJ2aWNlLmluaXRBcnJheUNvcHlXYXRjaCgpO1xuICAgICAgc2VydmljZS5pc0NvbXBpbGVkKHRydWUpO1xuICAgIH1cblxuICAgIHNlcnZpY2UuYnJvYWRjYXN0RXJyb3JzKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0NvbXBpbGVkKHNldFZhbHVlKSB7XG4gICAgdmFyIHNlcnZpY2UgPSB0aGlzO1xuICAgIGlmIChzZXRWYWx1ZSkge1xuICAgICAgc2VydmljZS5zY2hlbWEuY29tcGlsZWQgPSBzZXRWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcnZpY2Uuc2NoZW1hICYmIHNlcnZpY2Uuc2NoZW1hLmNvbXBpbGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0dXBDb25maWcoY29uZmlnKSB7XG4gICAgdmFyIHNlcnZpY2UgPSB0aGlzO1xuICAgIGlmIChjb25maWcpIHtcbiAgICAgIGlmIChjb25maWcuZm9ybUN0cmwpIHNlcnZpY2UuZm9ybUN0cmwgPSBjb25maWcuZm9ybUN0cmw7XG4gICAgICBpZiAoY29uZmlnLnVwZGF0ZVNjaGVtYSkgc2VydmljZS51cGRhdGVTY2hlbWEgPSBjb25maWcudXBkYXRlU2NoZW1hO1xuICAgICAgaWYgKGNvbmZpZy5nZXRTY2hlbWEpXG4gICAgICAgIHNlcnZpY2UuZ2V0U2NoZW1hRm9ybSA9IHNlcnZpY2Uuc2V0dXBTY2hlbWFSZWZyZXNoKGNvbmZpZy5nZXRTY2hlbWEpO1xuICAgIH1cbiAgICBzZXJ2aWNlLmdldFBhcmFtT3ZlcnJpZGVzID0gY29uZmlnLmdldFBhcmFtcyB8fCBfLm5vb3A7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzU2NoZW1hKGZpZWxkKSB7XG4gICAgY29uc3Qgc2VydmljZSA9IHRoaXM7XG4gICAgY29uc3QgeyBzY2hlbWEgfSA9IGZpZWxkO1xuXG4gICAgZmllbGQuZ2V0U2NoZW1hVHlwZSA9ICgpID0+XG4gICAgICBfLmlzQXJyYXkoc2NoZW1hLnR5cGUpID8gXy5maXJzdChzY2hlbWEudHlwZSkgOiBzY2hlbWEudHlwZTtcbiAgICBpZiAoIWZpZWxkLnR5cGUpIGZpZWxkLnR5cGUgPSBmaWVsZC5nZXRTY2hlbWFUeXBlICYmIGZpZWxkLmdldFNjaGVtYVR5cGUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NEZWZhdWx0KGZpZWxkKSB7XG4gICAgY29uc3Qgc2VydmljZSA9IHRoaXM7XG4gICAgY29uc3QgeyBzY2hlbWEgfSA9IGZpZWxkO1xuICAgIGNvbnN0IGN1ckRlZmF1bHQgPSBmaWVsZC5kZWZhdWx0IHx8IHNjaGVtYS5kZWZhdWx0O1xuICAgIGNvbnN0IGtleSA9IHNlcnZpY2UuZ2V0S2V5KGZpZWxkLmtleSk7XG5cbiAgICBpZiAoc2VydmljZS5za2lwRGVmYXVsdFtrZXldKSB7XG4gICAgICBkZWxldGUgc2VydmljZS5za2lwRGVmYXVsdFtrZXldO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChmaWVsZC5jb25kaXRpb24pIHtcbiAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IHJlcGxhY2VBcnJheUluZGV4KFxuICAgICAgICBmaWVsZC5jb25kaXRpb24sXG4gICAgICAgIGZpZWxkLmFycmF5SW5kZXggfHwga2V5XG4gICAgICApO1xuICAgICAgaWYgKCFzZXJ2aWNlLnBhcnNlQ29uZGl0aW9uKGNvbmRpdGlvbikpIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpZiBzY2hlbWFVcGRhdGUgaGFzbid0IGJlZW4gdHJpZ2dlcmVkLCBsZXQgc2NoZW1hRm9ybSBkaXJlY3RpdmUgaGFuZGxlIGRlZmF1bHRzXG4gICAgLy9pZihzZXJ2aWNlLnVwZGF0ZXMgfHwgZmllbGQuZGVmYXVsdCkge1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChjdXJEZWZhdWx0KSkge1xuICAgICAgaWYgKGtleS5pbmNsdWRlcyAmJiBrZXkuaW5jbHVkZXMoXCJbXVwiKSkgcmV0dXJuO1xuICAgICAgY29uc3QgbW9kZWwgPSBzZXJ2aWNlLnBhcnNlRXhwcmVzc2lvbihmaWVsZC5rZXksIHNlcnZpY2UubW9kZWwpO1xuICAgICAgY29uc3QgbW9kZWxWYWx1ZSA9IG1vZGVsLmdldCgpO1xuICAgICAgLy8gaWYgdGhlcmUncyBhbiBleGlzdGluZyBkZWZhdWx0IGFuZCBpdCdzIHRoZSBzYW1lIGFzIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICAvLyB1cGRhdGUgdGhlIGN1cnJlbnQgdmFsdWUgdG8gdGhlIG5ldyBkZWZhdWx0XG4gICAgICBpZiAoXG4gICAgICAgIF8uaXNVbmRlZmluZWQobW9kZWxWYWx1ZSkgfHxcbiAgICAgICAgKChfLmhhcyhzZXJ2aWNlLmRlZmF1bHRzLCBrZXkpXG4gICAgICAgICAgPyBhbmd1bGFyLmVxdWFscyhtb2RlbFZhbHVlLCBzZXJ2aWNlLmRlZmF1bHRzW2tleV0pXG4gICAgICAgICAgOiBfLmlzVHJ1bHlFbXB0eShtb2RlbFZhbHVlKSkgJiZcbiAgICAgICAgICAhYW5ndWxhci5lcXVhbHMobW9kZWxWYWx1ZSwgY3VyRGVmYXVsdCkpXG4gICAgICApIHtcbiAgICAgICAgbW9kZWwuc2V0KGFuZ3VsYXIuY29weShjdXJEZWZhdWx0KSk7XG4gICAgICB9XG4gICAgfVxuICAgIHNlcnZpY2UuZGVmYXVsdHNba2V5XSA9IGFuZ3VsYXIuY29weShjdXJEZWZhdWx0KTtcblxuICAgIGlmIChzY2hlbWEuZm9ybWF0ID09PSBcInVybFwiICYmICFmaWVsZC52YWxpZGF0aW9uTWVzc2FnZSkge1xuICAgICAgaWYgKCFmaWVsZC50eXBlKSBmaWVsZC50eXBlID0gXCJjbi11cmxcIjtcbiAgICAgIGZpZWxkLnZhbGlkYXRpb25NZXNzYWdlID0gXCJNdXN0IGJlIGEgdmFsaWQgdXJsIChodHRwczovLy4uLilcIjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzRmllbGRzZXQoZmllbGRzZXQpIHtcbiAgICB2YXIgc2VydmljZSA9IHRoaXM7XG5cbiAgICBmaWVsZHNldC50eXBlID0gXCJjbi1maWVsZHNldFwiO1xuICAgIGZpZWxkc2V0Lml0ZW1zLmZvckVhY2goc2VydmljZS5wcm9jZXNzRmllbGQuYmluZChzZXJ2aWNlKSk7XG5cbiAgICBpZiAoXy5oYXMoZmllbGRzZXQsIFwicG9zXCIpICYmIGZpZWxkc2V0LnBvcyA9PT0gMCkge1xuICAgICAgZmllbGRzZXQuaHRtbENsYXNzID0gKGZpZWxkc2V0Lmh0bWxDbGFzcyB8fCBcIlwiKSArIFwiIGJvcmRlcmxlc3NcIjtcbiAgICB9XG4gICAgaWYgKGZpZWxkc2V0LmNvbGxhcHNpYmxlKSB7XG4gICAgICBmaWVsZHNldC50b2dnbGVDb2xsYXBzZSA9IChmaWVsZHNldCkgPT4ge1xuICAgICAgICBpZiAoZmllbGRzZXQuY29sbGFwc2libGUpIHtcbiAgICAgICAgICBmaWVsZHNldC5jb2xsYXBzZWQgPSAhZmllbGRzZXQuY29sbGFwc2VkO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmaWVsZHNldC5yZW5kZXIgPSAhZmllbGRzZXQuY29sbGFwc2VkO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaWVsZHNldC5yZW5kZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NGaWVsZFR5cGUoZmllbGQsIHNlY29uZFBhc3MpIHtcbiAgICBjb25zdCBzZXJ2aWNlID0gdGhpcztcbiAgICBjb25zdCBmaWVsZFR5cGUgPSBjbkZsZXhGb3JtVHlwZXMuZ2V0RmllbGRUeXBlKGZpZWxkKTtcbiAgICBjb25zdCBoYW5kbGVyID0gZmllbGRUeXBlSGFuZGxlcnNbZmllbGRUeXBlXTtcbiAgICBpZiAoXy5pc1N0cmluZyhoYW5kbGVyKSkge1xuICAgICAgc2VydmljZVtoYW5kbGVyXShmaWVsZCwgc2Vjb25kUGFzcyk7XG4gICAgfSBlbHNlIGlmIChfLmlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICAgIGhhbmRsZXIuY2FsbChzZXJ2aWNlLCBmaWVsZCwgc2Vjb25kUGFzcyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0T2dLZXlzKGZpZWxkKSB7XG4gICAgcmV0dXJuIF8ucmVqZWN0KF8ua2V5cyhmaWVsZCksIChrZXkpID0+IC9ea2V5JHxeaHRtbENsYXNzJHxeXy8udGVzdChrZXkpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NGaWVsZChmaWVsZCwgcG9zKSB7XG4gICAgY29uc3Qgc2VydmljZSA9IHRoaXM7XG5cbiAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQocG9zKSkge1xuICAgICAgZmllbGQucG9zID0gcG9zO1xuICAgIH1cblxuICAgIGlmICghZmllbGQuX29nS2V5cykge1xuICAgICAgZmllbGQuX29nS2V5cyA9IGdldE9nS2V5cyhmaWVsZCk7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5ID0gc2VydmljZS5nZXRLZXkoZmllbGQua2V5KTtcblxuICAgIGlmIChrZXkpIHtcbiAgICAgIHNlcnZpY2UuYWRkVG9Gb3JtQ2FjaGUoZmllbGQsIGtleSk7XG4gICAgICBjb25zdCBzY2hlbWEgPSBzZXJ2aWNlLmdldFNjaGVtYShrZXkpO1xuXG4gICAgICBpZiAoc2NoZW1hKSB7XG4gICAgICAgIGZpZWxkLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgaWYgKHNjaGVtYS5kZXNjcmlwdGlvbikgZmllbGQuZGVzY3JpcHRpb24gPSBzY2hlbWEuZGVzY3JpcHRpb247XG4gICAgICAgIGlmIChzY2hlbWEudHlwZSA9PT0gXCJhcnJheVwiICYmICEoXCJzaG93Q2xlYXJBbGxcIiBpbiBmaWVsZCkpXG4gICAgICAgICAgZmllbGQuc2hvd0NsZWFyQWxsID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgc2VydmljZS5wcm9jZXNzU2NoZW1hKGZpZWxkKTtcbiAgICB9XG5cbiAgICBzZXJ2aWNlLnByb2Nlc3NGaWVsZFByb3BzKGZpZWxkKTtcblxuICAgIGlmIChrZXkpIHtcbiAgICAgICgoa2V5KSA9PiB7XG4gICAgICAgIGlmIChfLmZpbmQoc2VydmljZS5lcnJvcnMsIHsga2V5IH0pKSB7XG4gICAgICAgICAgc2VydmljZS5lcnJvcnMgPSBfLnJlamVjdChzZXJ2aWNlLmVycm9ycywgeyBrZXkgfSk7XG4gICAgICAgICAgc2VydmljZS5zY29wZS4kYnJvYWRjYXN0KFxuICAgICAgICAgICAgXCJzY2hlbWFGb3JtLmVycm9yLlwiICsga2V5LFxuICAgICAgICAgICAgXCJzZXJ2ZXJWYWxpZGF0aW9uXCIsXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZXJ2aWNlLnNjb3BlLiRicm9hZGNhc3QoXG4gICAgICAgICAgICBcInNjaGVtYUZvcm0uZXJyb3IuXCIgKyBrZXksXG4gICAgICAgICAgICBcInNjaGVtYUZvcm1cIixcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KShnZXREb3RLZXkoa2V5KSk7XG5cbiAgICAgIGlmIChmaWVsZC5lcnJvcikge1xuICAgICAgICBzZXJ2aWNlLmVycm9ycy5wdXNoKHNlcnZpY2UuYnVpbGRFcnJvcihmaWVsZCkpO1xuICAgICAgICBpZiAoXy5pc0VtcHR5KGZpZWxkLm5nTW9kZWxPcHRpb25zKSkge1xuICAgICAgICAgIGZpZWxkLm5nTW9kZWxPcHRpb25zID0ge1xuICAgICAgICAgICAgYWxsb3dJbnZhbGlkOiB0cnVlLFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmllbGQubmdNb2RlbE9wdGlvbnMuYWxsb3dJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NGaWVsZFByb3BzKGZpZWxkLCBzZWNvbmRQYXNzKSB7XG4gICAgY29uc3Qgc2VydmljZSA9IHRoaXM7XG4gICAgZmllbGRQcm9wSGFuZGxlcnMuZm9yRWFjaChcbiAgICAgICh7IHByb3AsIGhhbmRsZXIgfSkgPT5cbiAgICAgICAgXy5oYXMoZmllbGQsIHByb3ApICYmIGhhbmRsZXIoZmllbGQsIHNlcnZpY2UsIHNlY29uZFBhc3MpXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEtleShrZXkpIHtcbiAgICBpZiAoXy5pc0FycmF5KGtleSkpIHtcbiAgICAgIGtleSA9IF8ucmVkdWNlKGtleSwgKHRvdGFsLCBuZXh0KSA9PlxuICAgICAgICAvXigtP1xcZCopJC8udGVzdChuZXh0KSA/IHRvdGFsICsgXCJbXCIgKyBuZXh0ICsgXCJdXCIgOiB0b3RhbCArIFwiLlwiICsgbmV4dFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNjaGVtYShrZXksIGRlcHRoKSB7XG4gICAgdmFyIHNlcnZpY2UgPSB0aGlzO1xuICAgIGlmICgha2V5KSByZXR1cm47XG5cbiAgICBrZXkgPSBPYmplY3RQYXRoLnBhcnNlKHNlcnZpY2UuZ2V0S2V5KGtleSkpO1xuICAgIGRlcHRoID0gZGVwdGggfHwgc2VydmljZS5zY2hlbWEuc2NoZW1hLnByb3BlcnRpZXM7XG4gICAgbGV0IGZpcnN0LCBuZXh0O1xuXG4gICAgd2hpbGUgKGtleS5sZW5ndGggPiAxKSB7XG4gICAgICBuZXh0ID0ga2V5WzFdO1xuICAgICAgaWYgKC9eLT9cXGQqJC8udGVzdChuZXh0KSkge1xuICAgICAgICBpZiAoa2V5Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGRlcHRoID0gZGVwdGhba2V5LnNoaWZ0KCldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlcHRoID0gZGVwdGhba2V5LnNoaWZ0KCldLml0ZW1zLnByb3BlcnRpZXM7XG4gICAgICAgICAga2V5LnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlcHRoID0gZGVwdGhba2V5LnNoaWZ0KCldLnByb3BlcnRpZXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgYXJyYXkgaXRlbVxuICAgIGZpcnN0ID0ga2V5WzBdIHx8IFwiaXRlbXNcIjtcblxuICAgIHJldHVybiBkZXB0aFtmaXJzdF07XG4gIH1cblxuICBmdW5jdGlvbiBnZXREZWZhdWx0KGZpZWxkKSB7XG4gICAgY29uc3Qgc2VydmljZSA9IHRoaXM7XG4gICAgZmllbGQgPSBmaWVsZC5rZXkgPyBmaWVsZCA6IHNlcnZpY2UuZ2V0RnJvbUZvcm1DYWNoZShmaWVsZCk7XG4gICAgcmV0dXJuIChcbiAgICAgIGZpZWxkICYmXG4gICAgICAoYW5ndWxhci5pc0RlZmluZWQoZmllbGQuZGVmYXVsdClcbiAgICAgICAgPyBmaWVsZC5kZWZhdWx0XG4gICAgICAgIDogZmllbGQuc2NoZW1hICYmIGZpZWxkLnNjaGVtYS5kZWZhdWx0KVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRXYXRjaGFibGVzKGV4cCkge1xuICAgIGNvbnN0IHdhdGNoYWJsZXMgPSBbXTtcbiAgICBsZXQgbmVzdGVkID0gbWF0Y2hOZXN0ZWRFeHByZXNzaW9uKGV4cCk7XG4gICAgbGV0IHJlcGxhY2VTdHIgPSBcIlwiO1xuXG4gICAgd2hpbGUgKG5lc3RlZCkge1xuICAgICAgaWYgKC9eLT9cXGQrJC8udGVzdChuZXN0ZWRbMV0pIHx8IC9eKFwifCcpLiooXCJ8JykkLy50ZXN0KG5lc3RlZFsxXSkpIHtcbiAgICAgICAgcmVwbGFjZVN0ciA9IG5lc3RlZFswXTtcbiAgICAgICAgZXhwID0gZXhwLnJlcGxhY2UobmVzdGVkWzBdLCBcImZmX3JlcGxhY2VfZmZcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXRjaGFibGVzLnB1c2gobmVzdGVkWzFdLnJlcGxhY2UoL2ZmX3JlcGxhY2VfZmYvZywgcmVwbGFjZVN0cikpO1xuICAgICAgICByZXBsYWNlU3RyID0gXCJcIjtcbiAgICAgICAgZXhwID0gZXhwLnJlcGxhY2UobmVzdGVkWzBdLCBcIlwiKTtcbiAgICAgIH1cbiAgICAgIG5lc3RlZCA9IG1hdGNoTmVzdGVkRXhwcmVzc2lvbihleHApO1xuICAgIH1cblxuICAgIHJldHVybiBbLi4ud2F0Y2hhYmxlcywgZXhwLnJlcGxhY2UoL2ZmX3JlcGxhY2VfZmYvZywgcmVwbGFjZVN0cildO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc1Jlc29sdmUoZmllbGQpIHtcbiAgICBjb25zdCBzZXJ2aWNlID0gdGhpcztcbiAgICBjb25zdCBrZXkgPSBzZXJ2aWNlLmdldEtleShmaWVsZC5rZXkpO1xuXG4gICAgXy5lYWNoKGZpZWxkLnJlc29sdmUsIGZ1bmN0aW9uIChkYXRhUHJvcCwgZmllbGRQcm9wKSB7XG4gICAgICBkYXRhUHJvcCA9IHJlcGxhY2VBcnJheUluZGV4KGRhdGFQcm9wLCBrZXkgfHwgZmllbGQuYXJyYXlJbmRleCk7XG4gICAgICBpZiAoZGF0YVByb3AuaW5jbHVkZXMoXCJbYXJyYXlJbmRleF1cIikpIHJldHVybjtcblxuICAgICAgc2VydmljZS5oYW5kbGVSZXNvbHZlKGZpZWxkLCBmaWVsZFByb3AsIGRhdGFQcm9wLCB0cnVlKTtcblxuICAgICAgZ2V0V2F0Y2hhYmxlcyhkYXRhUHJvcCkuZm9yRWFjaCgod2F0Y2hhYmxlKSA9PiB7XG4gICAgICAgIGNvbnN0IFssIGJhc2UsIGV4cF0gPVxuICAgICAgICAgIHdhdGNoYWJsZS5tYXRjaCgvKHNjaGVtYVxcLmRhdGFcXC58bW9kZWxcXC4pKFxcUyspLykgfHwgW107XG5cbiAgICAgICAgaWYgKGJhc2UpIHtcbiAgICAgICAgICBpZiAoYmFzZSA9PT0gXCJzY2hlbWEuZGF0YS5cIikge1xuICAgICAgICAgICAgc2VydmljZS5yZWdpc3RlclJlc29sdmUoZmllbGQsIGZpZWxkUHJvcCwgZXhwLCBkYXRhUHJvcCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChiYXNlID09PSBcIm1vZGVsLlwiKSB7XG4gICAgICAgICAgICBzZXJ2aWNlLnJlZ2lzdGVySGFuZGxlcihleHAsICgpID0+IHtcbiAgICAgICAgICAgICAgc2VydmljZS5oYW5kbGVSZXNvbHZlKGZpZWxkLCBmaWVsZFByb3AsIGRhdGFQcm9wKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZmllbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUFueShleHAsIGJhc2UpIHtcbiAgICBjb25zdCBzZXJ2aWNlID0gdGhpcztcbiAgICBsZXQgcmVzdWx0O1xuICAgIGNvbnN0IGVpdGhlcnMgPSBleHAuc3BsaXQoXCIgfHwgXCIpO1xuICAgIGNvbnN0IG1hdGNoID0gXy5maW5kKGVpdGhlcnMsICh4KSA9PiB7XG4gICAgICBjb25zdCB2ID0gc2VydmljZS5wYXJzZUV4cHJlc3Npb24oeCwgYmFzZSkuZ2V0KCk7XG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQodikpIHtcbiAgICAgICAgcmVzdWx0ID0gdjtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlQWxsKGV4cCwgYmFzZSkge1xuICAgIGNvbnN0IHNlcnZpY2UgPSB0aGlzO1xuICAgIGNvbnN0IGFsbCA9IGV4cC5zcGxpdChcIiAmJiBcIik7XG4gICAgY29uc3QgbWF0Y2ggPSBfLnJlZHVjZShcbiAgICAgIGFsbCxcbiAgICAgIChhY2MsIHgpID0+IHtcbiAgICAgICAgY29uc3QgdiA9IHNlcnZpY2UucGFyc2VFeHByZXNzaW9uKHgsIGJhc2UpLmdldCgpO1xuICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQodikpIHtcbiAgICAgICAgICBhY2MucHVzaCh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSxcbiAgICAgIFtdXG4gICAgKTtcbiAgICByZXR1cm4gYWxsLmxlbmd0aCA9PT0gbWF0Y2gubGVuZ3RoID8gXy5sYXN0KG1hdGNoKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVJlc29sdmUoZmllbGQsIGZpZWxkUHJvcCwgZXhwLCBza2lwUHJvcEhhbmRsZXJzKSB7XG4gICAgY29uc3Qgc2VydmljZSA9IHRoaXM7XG4gICAgY29uc3QgZGF0YSA9IGV4cC5pbmNsdWRlcyhcIiB8fCBcIilcbiAgICAgID8gc2VydmljZS5wYXJzZUFueShleHApXG4gICAgICA6IGV4cC5pbmNsdWRlcyhcIiAmJiBcIilcbiAgICAgID8gc2VydmljZS5wYXJzZUFsbChleHApXG4gICAgICA6IHNlcnZpY2UucGFyc2VFeHByZXNzaW9uKGV4cCkuZ2V0KCk7XG5cbiAgICBpZiAoZGF0YSAmJiBkYXRhLmN1cnNvcikge1xuICAgICAgZmllbGQubG9hZE1vcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGRhdGFQcm9wID0gZXhwLm1hdGNoKC9zY2hlbWFcXC5kYXRhXFwuKC4rKS8pWzFdO1xuICAgICAgICBzZXJ2aWNlLnJlZnJlc2hTY2hlbWEoYGRhdGE6JHtkYXRhUHJvcH06JHtkYXRhLmN1cnNvcn1gKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBmaWVsZC5sb2FkTW9yZTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWwgPSBkYXRhICYmIGRhdGEuZGF0YSA/IGRhdGEuZGF0YSA6IGRhdGE7XG4gICAgY29uc3QgdmFsMSA9IGZpZWxkUHJvcCA9PT0gXCJjb25kaXRpb25cIiA/IHZhbCArIFwiXCIgOiB2YWw7XG4gICAgc2VydmljZS5wYXJzZUV4cHJlc3Npb24oZmllbGRQcm9wLCBmaWVsZCkuc2V0KHZhbDEpO1xuXG4gICAgaWYgKCFza2lwUHJvcEhhbmRsZXJzKSB7XG4gICAgICBmaWVsZFByb3BIYW5kbGVycy5mb3JFYWNoKFxuICAgICAgICAoeyBwcm9wLCBoYW5kbGVyIH0pID0+IHByb3AgPT09IGZpZWxkUHJvcCAmJiBoYW5kbGVyKGZpZWxkLCBzZXJ2aWNlKVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWdpc3RlclJlc29sdmUoZmllbGQsIGZpZWxkUHJvcCwgZGF0YVByb3AsIGV4cCkge1xuICAgIHZhciBzZXJ2aWNlID0gdGhpcztcblxuICAgIGxldCBmaWVsZEtleSA9IHNlcnZpY2UuZ2V0S2V5KGZpZWxkLmtleSk7XG4gICAgc2VydmljZS5yZXNvbHZlUmVnaXN0ZXJbZGF0YVByb3BdID0gc2VydmljZS5yZXNvbHZlUmVnaXN0ZXJbZGF0YVByb3BdIHx8IHt9O1xuXG4gICAgbGV0IHJlZ2lzdGVyID0gc2VydmljZS5yZXNvbHZlUmVnaXN0ZXJbZGF0YVByb3BdO1xuICAgIHJlZ2lzdGVyW2ZpZWxkS2V5XSA9IHJlZ2lzdGVyW2ZpZWxkS2V5XSB8fCBbXTtcbiAgICByZWdpc3RlcltmaWVsZEtleV0ucHVzaCh7IGZpZWxkLCBwcm9wOiBmaWVsZFByb3AsIGV4cCB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NDb25kaXRpb25hbChmaWVsZCkge1xuICAgIGNvbnN0IHNlcnZpY2UgPSB0aGlzO1xuICAgIF8uZWFjaChmaWVsZC5jb25kaXRpb25hbHMsIChjb25kaXRpb24sIGtleSkgPT4ge1xuICAgICAgY29uc3QgaGFuZGxlciA9ICh2YWwsIHByZXYpID0+IHtcbiAgICAgICAgZmllbGRba2V5XSA9IHNlcnZpY2UucGFyc2VDb25kaXRpb24oY29uZGl0aW9uKTtcbiAgICAgICAgY29uc3Qgc2NvcGUgPSBzZXJ2aWNlLmdldEZyb21TY29wZUNhY2hlKHNlcnZpY2UuZ2V0S2V5KGZpZWxkLmtleSkpO1xuICAgICAgICBpZiAoa2V5ID09PSBcInJlcXVpcmVkXCIgJiYgc2NvcGUpIHtcbiAgICAgICAgICBzZXJ2aWNlLnNjb3BlLiRicm9hZGNhc3QoXCJzY2hlbWFGb3JtVmFsaWRhdGVcIik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmaWVsZC5jb25kaXRpb25hbHNba2V5XVxuICAgICAgICAubWF0Y2goL21vZGVsXFwuKFteXFxzXSspL2cpXG4gICAgICAgIC5tYXAoKHBhdGgpID0+IHBhdGgubWF0Y2goL21vZGVsXFwuKFteXFxzXSspLylbMV0pXG4gICAgICAgIC5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICBzZXJ2aWNlLnJlZ2lzdGVySGFuZGxlcihrZXksIGhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICAgIGhhbmRsZXIoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NGaWVsZFdhdGNoKGZpZWxkKSB7XG4gICAgY29uc3Qgc2VydmljZSA9IHRoaXM7XG4gICAgaWYgKCFmaWVsZC53YXRjaCkgcmV0dXJuO1xuXG4gICAgbGV0IHNjaGVtYSA9IGZpZWxkLnNjaGVtYTtcbiAgICBmaWVsZC53YXRjaCA9IF8uaXNBcnJheShmaWVsZC53YXRjaCkgPyBmaWVsZC53YXRjaCA6IFtmaWVsZC53YXRjaF07XG5cbiAgICBfLmVhY2goZmllbGQud2F0Y2gsIGZ1bmN0aW9uICh3YXRjaCkge1xuICAgICAgaWYgKHdhdGNoLnJlc29sdXRpb24pIHtcbiAgICAgICAgbGV0IGNvbmRpdGlvbjtcbiAgICAgICAgaWYgKF8uaXNTdHJpbmcoZmllbGQuY29uZGl0aW9uKSkge1xuICAgICAgICAgIC8vIGlmIHRoZSBjb25kaXRpb24gaXNuJ3QgYWxyZWFkeSB3cmFwcGVkIGluIHBhcmVucywgd3JhcCBpdFxuICAgICAgICAgIGNvbmRpdGlvbiA9IC9eXFwoLipcXCkkLy50ZXN0KGZpZWxkLmNvbmRpdGlvbilcbiAgICAgICAgICAgID8gZmllbGQuY29uZGl0aW9uXG4gICAgICAgICAgICA6IGAoJHtmaWVsZC5jb25kaXRpb259KWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF8uaXNTdHJpbmcod2F0Y2guY29uZGl0aW9uKSkge1xuICAgICAgICAgIGNvbmRpdGlvbiA9IGNvbmRpdGlvblxuICAgICAgICAgICAgPyBgJHtjb25kaXRpb259ICYmICR7d2F0Y2guY29uZGl0aW9ufWBcbiAgICAgICAgICAgIDogd2F0Y2guY29uZGl0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNvbHV0aW9uID0gd2F0Y2gucmVzb2x1dGlvbjtcbiAgICAgICAgbGV0IGhhbmRsZXI7XG5cbiAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihyZXNvbHV0aW9uKSkge1xuICAgICAgICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoY3VyLCBwcmV2KSB7XG4gICAgICAgICAgICBpZiAoIWNvbmRpdGlvbiB8fCBzZXJ2aWNlLnBhcnNlQ29uZGl0aW9uKGNvbmRpdGlvbikpIHtcbiAgICAgICAgICAgICAgcmVzb2x1dGlvbihjdXIsIHByZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGFkanVzdG1lbnQgPSB7fTtcblxuICAgICAgICAgIGFkanVzdG1lbnQuZGF0ZSA9IHJlc29sdXRpb24ubWF0Y2goL1xcKyA/KFxcZCspIChkYXlzfGhvdXJzKS8pO1xuXG4gICAgICAgICAgaWYgKGFkanVzdG1lbnQuZGF0ZSkge1xuICAgICAgICAgICAgYWRqdXN0bWVudC5kYXRlID0ge1xuICAgICAgICAgICAgICB2YWw6IGFkanVzdG1lbnQuZGF0ZVsxXSxcbiAgICAgICAgICAgICAgdW5pdHM6IGFkanVzdG1lbnQuZGF0ZVsyXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXNvbHV0aW9uID0gcmVzb2x1dGlvbi5yZXBsYWNlKGFkanVzdG1lbnQuZGF0ZS52YWwsIFwiXCIpLnRyaW0oKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRqdXN0bWVudC5tYXRoID0gcmVzb2x1dGlvbi5tYXRjaCgvKFxcK3xcXC18XFwvfFxcKikgPyhcXFMrKS8pO1xuXG4gICAgICAgICAgICBpZiAoYWRqdXN0bWVudC5tYXRoKSB7XG4gICAgICAgICAgICAgIGFkanVzdG1lbnQub3BlcmF0b3IgPSB7XG4gICAgICAgICAgICAgICAgXCIrXCI6IFwiYWRkXCIsXG4gICAgICAgICAgICAgICAgXCItXCI6IFwic3VidHJhY3RcIixcbiAgICAgICAgICAgICAgICBcIipcIjogXCJtdWx0aXBseVwiLFxuICAgICAgICAgICAgICAgIFwiL1wiOiBcImRpdmlkZVwiLFxuICAgICAgICAgICAgICB9W2FkanVzdG1lbnQubWF0aFsxXV07XG5cbiAgICAgICAgICAgICAgYWRqdXN0bWVudC5hZGp1c3RlciA9IHNlcnZpY2UucGFyc2VFeHByZXNzaW9uKGFkanVzdG1lbnQubWF0aFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzb2x1dGlvbiA9IHJlc29sdXRpb24ubWF0Y2goLyhcXFMrKSA/PSA/KFxcUyspLyk7XG5cbiAgICAgICAgICBoYW5kbGVyID0gKHZhbCwgcHJldiwga2V5LCB0cmlnZ2VyKSA9PiB7XG4gICAgICAgICAgICBsZXQgY3VyQ29uZGl0aW9uID0gY29uZGl0aW9uICYmIHJlcGxhY2VBcnJheUluZGV4KGNvbmRpdGlvbiwga2V5KTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgXy5pc1N0cmluZyhjdXJDb25kaXRpb24pICYmXG4gICAgICAgICAgICAgIGN1ckNvbmRpdGlvbi5pbmNsdWRlcyhcIlthcnJheUluZGV4XVwiKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIGBhcnJheUluZGV4IGNvdWxkIG5vdCBiZSByZXBhbGNlZCBmcm9tIGV4cHJlc3Npb24gJyR7Y3VyQ29uZGl0aW9ufSdgXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdXBkYXRlUGF0aCA9IHJlcGxhY2VBcnJheUluZGV4KHJlc29sdXRpb25bMV0sIGtleSk7XG4gICAgICAgICAgICBsZXQgZnJvbVBhdGggPSByZXBsYWNlQXJyYXlJbmRleChyZXNvbHV0aW9uWzJdLCBrZXkpO1xuXG4gICAgICAgICAgICBsZXQgdXBkYXRlID0gc2VydmljZS5wYXJzZUV4cHJlc3Npb24odXBkYXRlUGF0aCk7XG5cbiAgICAgICAgICAgIC8vIGF2b2lkIGxvb3Agd2hlcmUgdHdvIHdhdGNoZXMga2VlcCB0cmlnZ2VyaW5nIGVhY2ggb3RoZXJcbiAgICAgICAgICAgIGlmICh0cmlnZ2VyID09PSB1cGRhdGUucGF0aCgpLmtleSkgcmV0dXJuO1xuICAgICAgICAgICAgdHJpZ2dlciA9IHVwZGF0ZS5wYXRoKCkua2V5O1xuXG4gICAgICAgICAgICBsZXQgZnJvbSA9IHNlcnZpY2UucGFyc2VFeHByZXNzaW9uKGZyb21QYXRoKTtcblxuICAgICAgICAgICAgaWYgKCFjb25kaXRpb24gfHwgc2VydmljZS5wYXJzZUNvbmRpdGlvbihjdXJDb25kaXRpb24pKSB7XG4gICAgICAgICAgICAgIGlmIChhZGp1c3RtZW50LmRhdGUpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUuc2V0KFxuICAgICAgICAgICAgICAgICAgbW9tZW50KGZyb20uZ2V0KCkpXG4gICAgICAgICAgICAgICAgICAgIC5hZGQoYWRqdXN0bWVudC5kYXRlLnZhbCwgYWRqdXN0bWVudC5kYXRlLnVuaXRzKVxuICAgICAgICAgICAgICAgICAgICAudG9EYXRlKClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFkanVzdG1lbnQubWF0aCkge1xuICAgICAgICAgICAgICAgIC8vdmFyIHJlc3VsdCA9IF9bYWRqdXN0bWVudC5vcGVyYXRvcl0oZnJvbS5nZXQoKSwgYWRqdXN0bWVudC5hZGp1c3Rlci5nZXQoKSk7XG4gICAgICAgICAgICAgICAgLy9sZXQgcmVzdWx0ID0gZXZhbChmcm9tLmdldCgpICsgYWRqdXN0bWVudC5tYXRoWzFdICsgYWRqdXN0bWVudC5hZGp1c3Rlci5nZXQoKSk7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9ICRwYXJzZShcbiAgICAgICAgICAgICAgICAgIGZyb20uZ2V0KCkgKyBhZGp1c3RtZW50Lm1hdGhbMV0gKyBhZGp1c3RtZW50LmFkanVzdGVyLmdldCgpXG4gICAgICAgICAgICAgICAgKSgpO1xuICAgICAgICAgICAgICAgIHNjaGVtYSA9XG4gICAgICAgICAgICAgICAgICBzY2hlbWEgfHxcbiAgICAgICAgICAgICAgICAgIChmaWVsZC5pdGVtcyAmJlxuICAgICAgICAgICAgICAgICAgICAoZmllbGQuaXRlbXNbMF0uc2NoZW1hIHx8XG4gICAgICAgICAgICAgICAgICAgICAgKGZpZWxkLml0ZW1zWzBdLml0ZW1zICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC5pdGVtc1swXS5pdGVtc1swXS5zY2hlbWEpKSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLnR5cGUgPT09IFwiY24tY3VycmVuY3lcIikge1xuICAgICAgICAgICAgICAgICAgbGV0IHAgPVxuICAgICAgICAgICAgICAgICAgICBzY2hlbWEgJiYgc2NoZW1hLmZvcm1hdCA9PT0gXCJjdXJyZW5jeS1kb2xsYXJzXCIgPyAyIDogMDtcblxuICAgICAgICAgICAgICAgICAgaWYgKGFkanVzdG1lbnQubWF0aFsxXSA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXy5mbG9vcihyZXN1bHQsIHApO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhZGp1c3RtZW50Lm1hdGhbMV0gPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF8uY2VpbChyZXN1bHQsIHApO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXy5yb3VuZChyZXN1bHQsIHApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL3NlcnZpY2UubGlzdGVuZXJzW3VwZGF0ZS5wYXRoKCkua2V5XS5wcmV2ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXJ2aWNlLmxpc3RlbmVyc1t0cmlnZ2VyXSkge1xuICAgICAgICAgICAgICAgICAgc2VydmljZS5saXN0ZW5lcnNbdHJpZ2dlcl0udHJpZ2dlciA9IGtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXBkYXRlLnNldChyZXN1bHQgfHwgMCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlLnNldChmcm9tLmdldCgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBzZXJ2aWNlLnJlZ2lzdGVySGFuZGxlcihcbiAgICAgICAgICBmaWVsZCxcbiAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgIGZpZWxkLnVwZGF0ZVNjaGVtYSxcbiAgICAgICAgICB3YXRjaC5pbml0aWFsaXplXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUNvbmRpdGlvbihjb25kaXRpb24pIHtcbiAgICBjb25zdCBzZXJ2aWNlID0gdGhpcztcbiAgICBpZiAoY29uZGl0aW9uLnN0YXJ0c1dpdGgoXCJfXCIpKSB7XG4gICAgICBsZXQgZXhwID1cbiAgICAgICAgL15fXFwuKC4qPylcXCgoLio/KSxbXFxzKF0qKC4qPylcXCk/XFxzKj0+W3tcXHNdKig/OnJldHVybik/KC4qPylcXH0/XFwpJC87XG4gICAgICBsZXQgWywgZm4sIGxpc3QsIHByZWRpY2F0ZVBhcmFtcywgcHJlZGljYXRlQm9keV0gPSBjb25kaXRpb24ubWF0Y2goZXhwKTtcbiAgICAgIHJldHVybiBfW2ZuXShcbiAgICAgICAgJHBhcnNlKGxpc3QpKHNlcnZpY2UpLFxuICAgICAgICBnZW5lcmF0ZVByZWRpY2F0ZShwcmVkaWNhdGVQYXJhbXMsIHByZWRpY2F0ZUJvZHkpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJHBhcnNlKGNvbmRpdGlvbikoc2VydmljZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVQcmVkaWNhdGUocGFyYW1zLCBib2R5KSB7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PlxuICAgICAgJHBhcnNlKGJvZHkpKFxuICAgICAgICBwYXJhbXNcbiAgICAgICAgICAucmVwbGFjZSgvXFxzL2csIFwiXCIpXG4gICAgICAgICAgLnNwbGl0KFwiLFwiKVxuICAgICAgICAgIC5yZWR1Y2UoKGFjYywgY3VyLCBpKSA9PiB7XG4gICAgICAgICAgICBhY2NbY3VyXSA9IGFyZ3NbaV07XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgIH0sIHt9KVxuICAgICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NGaWVsZFVwZGF0ZWRTY2hlbWEoZmllbGQpIHtcbiAgICBjb25zdCBzZXJ2aWNlID0gdGhpcztcbiAgICBjb25zdCBrZXkgPSBzZXJ2aWNlLmdldEtleShmaWVsZC5rZXkpO1xuICAgIGlmICghc2VydmljZS51cGRhdGVzICYmIGZpZWxkLnVwZGF0ZVNjaGVtYSAmJiAhc2VydmljZS5zY2hlbWEucGFyYW1zW2tleV0pIHtcbiAgICAgIC8vIGJ5IHRoaXMgcG9pbnQgZGVmYXVsdHMgc2hvdWxkIGJlIHByb2Nlc3NlZCBzbyB3ZSBjYW4gZ2V0IHZhbHVlIGRpcmVjdGx5IGZyb20gbW9kZWxcbiAgICAgIGNvbnN0IGN1clZhbCA9IHNlcnZpY2UucGFyc2VFeHByZXNzaW9uKGtleSwgc2VydmljZS5tb2RlbCkuZ2V0KCk7XG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQoY3VyVmFsKSkgc2VydmljZS5zY2hlbWEucGFyYW1zW2tleV0gPSBjdXJWYWw7XG4gICAgfVxuICAgIHNlcnZpY2UucmVnaXN0ZXJIYW5kbGVyKGZpZWxkLCBudWxsLCBmaWVsZC51cGRhdGVTY2hlbWEpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJIYW5kbGVyKGtleSwgaGFuZGxlciwgdXBkYXRlU2NoZW1hLCBydW5IYW5kbGVyKSB7XG4gICAgdmFyIHNlcnZpY2UgPSB0aGlzO1xuXG4gICAgLy8gaWYgZmllbGQgaXMgcGFzc2VkIGluc3RlYWQgb2Yga2V5XG4gICAgaWYgKF8uaXNPYmplY3Qoa2V5KSAmJiAhXy5pc0FycmF5KGtleSkpIHtcbiAgICAgIGlmICgha2V5LmtleSAmJiBrZXkuaXRlbXMpIHtcbiAgICAgICAgXy5lYWNoKGtleS5pdGVtcywgZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgc2VydmljZS5yZWdpc3RlckhhbmRsZXIoZmllbGQsIGhhbmRsZXIsIGZpZWxkLnVwZGF0ZVNjaGVtYSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgfVxuICAgIH1cblxuICAgIGtleSA9IHNlcnZpY2UuZ2V0S2V5KGtleSk7XG4gICAgdmFyIGFyck1hdGNoID0ga2V5Lm1hdGNoKC8oLiopXFxbXVxcLj8oLiopLyk7XG5cbiAgICBpZiAoYXJyTWF0Y2gpIHtcbiAgICAgIHNlcnZpY2UucmVnaXN0ZXJBcnJheUhhbmRsZXJzKFxuICAgICAgICBhcnJNYXRjaFsxXSxcbiAgICAgICAgYXJyTWF0Y2hbMl0sXG4gICAgICAgIGhhbmRsZXIsXG4gICAgICAgIHVwZGF0ZVNjaGVtYSxcbiAgICAgICAgcnVuSGFuZGxlclxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3VyID0gc2VydmljZS5wYXJzZUV4cHJlc3Npb24oa2V5LCBzZXJ2aWNlLm1vZGVsKS5nZXQoKTtcbiAgICBsZXQgZGVmYXVsdFZhbHVlID0gXy5nZXQoc2VydmljZS5nZXRTY2hlbWEoa2V5KSwgXCJkZWZhdWx0XCIpO1xuXG4gICAgaWYgKCFzZXJ2aWNlLmxpc3RlbmVyc1trZXldKSB7XG4gICAgICB2YXIgcHJldiA9IGFuZ3VsYXIuY29weShjdXIpO1xuICAgICAgc2VydmljZS5saXN0ZW5lcnNba2V5XSA9IHtcbiAgICAgICAgaGFuZGxlcnM6IFtdLFxuICAgICAgICB1cGRhdGVTY2hlbWE6IHVwZGF0ZVNjaGVtYSxcbiAgICAgICAgcHJldjogcHJldixcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgIHNlcnZpY2UubGlzdGVuZXJzW2tleV0uaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICAgIGlmIChydW5IYW5kbGVyKSBoYW5kbGVyKGN1ciwgbnVsbCwga2V5KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWdpc3RlckFycmF5SGFuZGxlcnMoXG4gICAgYXJyS2V5LFxuICAgIGZpZWxkS2V5LFxuICAgIGhhbmRsZXIsXG4gICAgdXBkYXRlU2NoZW1hLFxuICAgIHJ1bkhhbmRsZXJcbiAgKSB7XG4gICAgY29uc3Qgc2VydmljZSA9IHRoaXM7XG4gICAgY29uc3Qgb25BcnJheSA9IChjdXIsIHByZXYsIHJlb3JkZXIpID0+IHtcbiAgICAgIGlmICghcHJldiAmJiBwcmV2ICE9PSAwICYmIChjdXIgfCAwKSA8IDEpIHJldHVybjtcbiAgICAgIHZhciBpLCBsLCBrZXk7XG5cbiAgICAgIGlmIChwcmV2ID4gY3VyIHx8IHJlb3JkZXIpIHtcbiAgICAgICAgY29uc3QgbGFzdEtleSA9IGZpZWxkS2V5XG4gICAgICAgICAgPyBgJHthcnJLZXl9WyR7cHJldiAtIDF9XS4ke2ZpZWxkS2V5fWBcbiAgICAgICAgICA6IGAke2FycktleX1bJHtwcmV2IC0gMX1dYDtcblxuICAgICAgICAvLyBvbmx5IGRlcmVnaXN0ZXIgaGFuZGxlcnMgb25jZSBlYWNoIHRpbWUgYW4gZWxlbWVudCBpcyByZW1vdmVkXG4gICAgICAgIGlmIChzZXJ2aWNlLmxpc3RlbmVyc1tsYXN0S2V5XSkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBwcmV2OyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBrZXkgPSBmaWVsZEtleSA/IGAke2FycktleX1bJHtpfV0uJHtmaWVsZEtleX1gIDogYCR7YXJyS2V5fVske2l9XWA7XG5cbiAgICAgICAgICAgIHNlcnZpY2UuZGVyZWdpc3RlckhhbmRsZXJzKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBjdXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBrZXkgPSBmaWVsZEtleSA/IGAke2FycktleX1bJHtpfV0uJHtmaWVsZEtleX1gIDogYCR7YXJyS2V5fVske2l9XWA7XG5cbiAgICAgICAgICBzZXJ2aWNlLnJlZ2lzdGVySGFuZGxlcihrZXksIGhhbmRsZXIsIHVwZGF0ZVNjaGVtYSk7XG4gICAgICAgICAgLy9ubyBuZWVkIHRvIGNhbGwgaWYganVzdCByZXJlZ2lzZXJpbmcgaGFuZGxlcnNcbiAgICAgICAgICAvL2lmKHJ1bkhhbmRsZXIpIGhhbmRsZXIobnVsbCwgbnVsbCwga2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjdXIgPiAocHJldiB8fCAwKSkge1xuICAgICAgICBmb3IgKGkgPSBwcmV2IHwgMCwgbCA9IGN1cjsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGtleSA9IGZpZWxkS2V5ID8gYCR7YXJyS2V5fVske2l9XS4ke2ZpZWxkS2V5fWAgOiBgJHthcnJLZXl9WyR7aX1dYDtcblxuICAgICAgICAgIHNlcnZpY2UucmVnaXN0ZXJIYW5kbGVyKGtleSwgaGFuZGxlciwgdXBkYXRlU2NoZW1hLCBydW5IYW5kbGVyKTtcbiAgICAgICAgICAvL2lmKHJ1bkhhbmRsZXIpIGhhbmRsZXIobnVsbCwgbnVsbCwga2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBhcnJWYWwgPSBzZXJ2aWNlLnBhcnNlRXhwcmVzc2lvbihhcnJLZXksIHNlcnZpY2UubW9kZWwpLmdldCgpO1xuICAgIF8uZWFjaChhcnJWYWwsIChmaWVsZCwgaSkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gZmllbGRLZXkgPyBgJHthcnJLZXl9WyR7aX1dLiR7ZmllbGRLZXl9YCA6IGAke2FycktleX1bJHtpfV1gO1xuXG4gICAgICBzZXJ2aWNlLnJlZ2lzdGVySGFuZGxlcihrZXksIGhhbmRsZXIsIHVwZGF0ZVNjaGVtYSk7XG4gICAgICBpZiAocnVuSGFuZGxlcikgaGFuZGxlcihudWxsLCBudWxsLCBrZXkpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgbGlzdGVuZXJLZXkgPSBgJHthcnJLZXl9Lmxlbmd0aGA7XG4gICAgaWYgKHNlcnZpY2UuYXJyYXlMaXN0ZW5lcnNbbGlzdGVuZXJLZXldKSB7XG4gICAgICBzZXJ2aWNlLmFycmF5TGlzdGVuZXJzW2xpc3RlbmVyS2V5XS5oYW5kbGVycy5wdXNoKG9uQXJyYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXJ2aWNlLmFycmF5TGlzdGVuZXJzW2xpc3RlbmVyS2V5XSA9IHtcbiAgICAgICAgaGFuZGxlcnM6IFtvbkFycmF5XSxcbiAgICAgICAgcHJldjogYXJyVmFsID8gYXJyVmFsLmxlbmd0aCA6IDAsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlcmVnaXN0ZXJIYW5kbGVycyhrZXkpIHtcbiAgICB2YXIgc2VydmljZSA9IHRoaXM7XG5cbiAgICBrZXkgPSBzZXJ2aWNlLmdldEtleShrZXkpO1xuXG4gICAgdmFyIGFyck1hdGNoID0ga2V5Lm1hdGNoKC8oW15bXFxdXSopXFxbXVxcLj8oLiopLyk7XG5cbiAgICBpZiAoYXJyTWF0Y2gpIHtcbiAgICAgIHNlcnZpY2UuZGVyZWdpc3RlckFycmF5SGFuZGxlcnMoYXJyTWF0Y2hbMV0sIGFyck1hdGNoWzJdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2VydmljZS5saXN0ZW5lcnNba2V5XSkgc2VydmljZS5saXN0ZW5lcnNba2V5XS5oYW5kbGVycyA9IFtdO1xuICAgIC8vaWYoc2VydmljZS5saXN0ZW5lcnNba2V5XSkgZGVsZXRlIHNlcnZpY2UubGlzdGVuZXJzW2tleV07XG4gIH1cblxuICBmdW5jdGlvbiBkZXJlZ2lzdGVyQXJyYXlIYW5kbGVycyhhcnJLZXksIGZpZWxkS2V5KSB7XG4gICAgdmFyIHNlcnZpY2UgPSB0aGlzO1xuXG4gICAgc2VydmljZVxuICAgICAgLnBhcnNlRXhwcmVzc2lvbihhcnJLZXksIHNlcnZpY2UubW9kZWwpXG4gICAgICAuZ2V0KClcbiAgICAgIC5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgIGZpZWxkS2V5XG4gICAgICAgICAgPyBzZXJ2aWNlLmRlcmVnaXN0ZXJIYW5kbGVycyhgJHthcnJLZXl9WyR7aX1dLiR7ZmllbGRLZXl9YClcbiAgICAgICAgICA6IHNlcnZpY2UuZGVyZWdpc3RlckhhbmRsZXJzKGAke2FycktleX1bJHtpfV1gKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdE1vZGVsV2F0Y2goKSB7XG4gICAgdmFyIHNlcnZpY2UgPSB0aGlzO1xuICAgIGlmIChzZXJ2aWNlLndhdGNoaW5nKSByZXR1cm47XG4gICAgaWYgKHNlcnZpY2UubW9kZWxXYXRjaCkgc2VydmljZS5tb2RlbFdhdGNoKCk7XG5cbiAgICBzZXJ2aWNlLm1vZGVsV2F0Y2ggPSBzZXJ2aWNlLnNjb3BlLiR3YXRjaChcbiAgICAgICgpID0+IHNlcnZpY2UubW9kZWwsXG4gICAgICBzZXJ2aWNlLm9uTW9kZWxXYXRjaC5iaW5kKHNlcnZpY2UpLFxuICAgICAgdHJ1ZVxuICAgICk7XG5cbiAgICBzZXJ2aWNlLmluaXRTY2hlbWFQYXJhbXMoKTtcbiAgICBzZXJ2aWNlLndhdGNoaW5nID0gdHJ1ZTtcbiAgICBzZXJ2aWNlLmZpcnN0VXBkYXRlID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uTW9kZWxXYXRjaChjdXIsIHByZXYpIHtcbiAgICB2YXIgc2VydmljZSA9IHRoaXM7XG4gICAgLy8gd2UgYWx3YXlzIHJ1biB0aHJvdWdoIHRoZSBsaXN0ZW5lcnMgb24gdGhlIGZpcnN0IHVwZGF0ZSBiZWNhdXNlIGFuZ3VsYXIgc2VlbXMgdG8gbWVzcyB1cFxuICAgIC8vIHdoZW4gdGhlIGRlZmF1bHRzIGFyZSBhcHBsaWVkIGFuZCB1c2VzIHRoZSBzYW1lIG9iamVjdCBmb3IgYm90aCBjdXIgYW5kIHByZXZcbiAgICBpZiAoc2VydmljZS5maXJzdFVwZGF0ZSB8fCAhYW5ndWxhci5lcXVhbHMoY3VyLCBwcmV2KSkge1xuICAgICAgc2VydmljZS5maXJzdFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgY25VdGlsLmNsZWFuTW9kZWwoc2VydmljZS5tb2RlbCk7XG5cbiAgICAgIHNlcnZpY2UucHJldlBhcmFtcyA9IGFuZ3VsYXIuY29weShzZXJ2aWNlLnBhcmFtcyk7XG5cbiAgICAgIF8uZWFjaChzZXJ2aWNlLmFycmF5TGlzdGVuZXJzLCAobGlzdGVuZXIsIGtleSkgPT4ge1xuICAgICAgICBsZXQgdmFsID0gc2VydmljZS5wYXJzZUV4cHJlc3Npb24oa2V5LCBzZXJ2aWNlLm1vZGVsKS5nZXQoKTtcbiAgICAgICAgaWYgKCFhbmd1bGFyLmVxdWFscyh2YWwsIGxpc3RlbmVyLnByZXYpKSB7XG4gICAgICAgICAgbGlzdGVuZXIuaGFuZGxlcnMuZm9yRWFjaCgoaGFuZGxlcikgPT4gaGFuZGxlcih2YWwsIGxpc3RlbmVyLnByZXYpKTtcbiAgICAgICAgICBsaXN0ZW5lci5wcmV2ID0gYW5ndWxhci5jb3B5KHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBfLmVhY2goc2VydmljZS5saXN0ZW5lcnMsIChsaXN0ZW5lciwga2V5KSA9PiB7XG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgIGxldCB2YWwgPSBzZXJ2aWNlLnBhcnNlRXhwcmVzc2lvbihrZXksIHNlcnZpY2UubW9kZWwpLmdldCgpO1xuICAgICAgICAgIGNvbnN0IGlzSW5pdEFycmF5ID0gYW5ndWxhci5lcXVhbHModmFsLCBbXSkgJiYgIWxpc3RlbmVyLnByZXY7XG4gICAgICAgICAgaWYgKCFhbmd1bGFyLmVxdWFscyh2YWwsIGxpc3RlbmVyLnByZXYpICYmICFpc0luaXRBcnJheSkge1xuICAgICAgICAgICAgbGlzdGVuZXIuaGFuZGxlcnMuZm9yRWFjaCgoaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgICBoYW5kbGVyKHZhbCwgbGlzdGVuZXIucHJldiwga2V5LCBsaXN0ZW5lci50cmlnZ2VyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGlzdGVuZXIudHJpZ2dlciA9IG51bGw7XG4gICAgICAgICAgICBsaXN0ZW5lci5wcmV2ID0gYW5ndWxhci5jb3B5KHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGxpc3RlbmVyLnVwZGF0ZVNjaGVtYSAmJlxuICAgICAgICAgICAgIWFuZ3VsYXIuaXNVbmRlZmluZWQodmFsKSAmJlxuICAgICAgICAgICAgIWlzSW5pdEFycmF5ICYmXG4gICAgICAgICAgICB2YWwgIT09IG51bGwgLyogJiZcbiAgICAgICAgICAgICFhbmd1bGFyLmVxdWFscyh2YWwsIHNlcnZpY2UuZ2V0RGVmYXVsdChrZXkpKSovXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBzZXJ2aWNlLnBhcmFtc1trZXldID0gdmFsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgc2VydmljZS5wYXJhbXNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWFuZ3VsYXIuZXF1YWxzKHNlcnZpY2UucGFyYW1zLCBzZXJ2aWNlLnByZXZQYXJhbXMpKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBzZXJ2aWNlLm1vZGVsLmlkICYmXG4gICAgICAgICAgIXNlcnZpY2UudXBkYXRlcyAmJlxuICAgICAgICAgIF8uaXNFbXB0eShzZXJ2aWNlLnByZXZQYXJhbXMpXG4gICAgICAgICkge1xuICAgICAgICAgIHNlcnZpY2UuaW5jcmVtZW50VXBkYXRlcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24oc2VydmljZS5yZWZyZXNoU2NoZW1hKSkge1xuICAgICAgICAgICAgc2VydmljZS5yZWZyZXNoU2NoZW1hKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdFNjaGVtYVBhcmFtcygpIHtcbiAgICB2YXIgc2VydmljZSA9IHRoaXM7XG4gICAgXy5lYWNoKHNlcnZpY2UubGlzdGVuZXJzLCBmdW5jdGlvbiAobGlzdGVuZXIsIGtleSkge1xuICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBzZXJ2aWNlLnBhcnNlRXhwcmVzc2lvbihrZXksIHNlcnZpY2UubW9kZWwpLmdldCgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbGlzdGVuZXIudXBkYXRlU2NoZW1hICYmXG4gICAgICAgICAgIWFuZ3VsYXIuaXNVbmRlZmluZWQodmFsKSAmJlxuICAgICAgICAgIHZhbCAhPT0gbnVsbFxuICAgICAgICApIHtcbiAgICAgICAgICBzZXJ2aWNlLnBhcmFtc1trZXldID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpcEluZGV4ZXMoa2V5KSB7XG4gICAgcmV0dXJuIGtleS5yZXBsYWNlKC9cXFtcXGQrXS9nLCBcIltdXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdEFycmF5Q29weVdhdGNoKCkge1xuICAgIGNvbnN0IHNlcnZpY2UgPSB0aGlzO1xuXG4gICAgc2VydmljZS5ldmVudHMucHVzaChcbiAgICAgIHNlcnZpY2Uuc2NvcGUuJG9uKFwic2NoZW1hRm9ybVByb3BhZ2F0ZUZvcm1Db250cm9sbGVyXCIsIChldmVudCwgc2NvcGUpID0+IHtcbiAgICAgICAgY29uc3QgeyBmb3JtIH0gPSBzY29wZTtcbiAgICAgICAgaWYgKCFmb3JtLmtleSkge1xuICAgICAgICAgIGZvcm0uY2FjaGVLZXkgPSBgJHtmb3JtLnR5cGV9LSR7Xy51bmlxdWVJZCgpfWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5ID0gZm9ybS5jYWNoZUtleSB8fCBzZXJ2aWNlLmdldEtleShmb3JtLmtleSk7XG5cbiAgICAgICAgaWYgKF8uaXNOdW1iZXIoc2NvcGUuYXJyYXlJbmRleCkpIHtcbiAgICAgICAgICBjb25zdCBnZW5lcmljS2V5ID0gc3RyaXBJbmRleGVzKGtleSk7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBzY29wZS5hcnJheUluZGV4O1xuICAgICAgICAgIGZvcm0uYXJyYXlJbmRleCA9IGluZGV4O1xuXG4gICAgICAgICAgaWYgKCFzZXJ2aWNlLmdldEFycmF5Q29weShnZW5lcmljS2V5LCBpbmRleCkpIHtcbiAgICAgICAgICAgIHNlcnZpY2UucHJvY2Vzc0ZpZWxkUHJvcHMoZm9ybSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFmb3JtLmNvbmRpdGlvbikgZm9ybS5jb25kaXRpb24gPSBcInRydWVcIjtcbiAgICAgICAgICAvLyBlbHNlIGlmIChmb3JtLmNvbmRpdGlvbi5pbmNsdWRlcyhcImFycmF5SW5kZXhcIikpIHtcbiAgICAgICAgICAvLyAgIGZvcm0uY29uZGl0aW9uID0gc2VydmljZS5yZXBsYWNlQXJyYXlJbmRleChmb3JtLmNvbmRpdGlvbiwga2V5KTtcbiAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICBzZXJ2aWNlLmFkZEFycmF5Q29weShzY29wZSwgZ2VuZXJpY0tleSwgaW5kZXgpO1xuICAgICAgICAgIHNjb3BlLiRlbWl0KFwiZmxleEZvcm1BcnJheUNvcHlBZGRlZFwiLCBnZW5lcmljS2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXJ2aWNlLmFkZFRvU2NvcGVDYWNoZShzY29wZSwga2V5KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuXG4gICAgc2VydmljZS5ldmVudHMucHVzaChcbiAgICAgIHNlcnZpY2Uuc2NvcGUuJG9uKFwic2NoZW1hRm9ybURlbGV0ZVNjb3BlXCIsIChldmVudCwgc2NvcGUsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGtleSA9IHNlcnZpY2UuZ2V0S2V5KHNjb3BlLmZvcm0ua2V5KTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBzZXJ2aWNlLmxpc3RlbmVyc1trZXldO1xuICAgICAgICBpZiAobGlzdGVuZXIpIGxpc3RlbmVyLmhhbmRsZXJzID0gW107XG5cbiAgICAgICAgc2VydmljZS5kZWxldGVBcnJheUNvcGllc0ZvcihrZXksIGluZGV4KTtcblxuICAgICAgICBpZiAoc2NvcGUuZm9ybS5saW5rKSB7XG4gICAgICAgICAgY29uc3QgbGlzdCA9IHNlcnZpY2VcbiAgICAgICAgICAgIC5wYXJzZUV4cHJlc3Npb24oc2NvcGUuZm9ybS5saW5rLCBzZXJ2aWNlLm1vZGVsKVxuICAgICAgICAgICAgLmdldCgpO1xuICAgICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICBzZXJ2aWNlLmRlbGV0ZUFycmF5Q29waWVzRm9yKHNjb3BlLmZvcm0ubGluaywgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRBcnJheUNvcHkoZm9ybSwga2V5LCBpbmRleCkge1xuICAgIGNvbnN0IHNlcnZpY2UgPSB0aGlzO1xuICAgIGlmICghaW5kZXggfHwgaW5kZXggPCAwKSBpbmRleCA9IDA7XG4gICAgaWYgKCFzZXJ2aWNlLmFycmF5Q29waWVzW2tleV0pIHNlcnZpY2UuYXJyYXlDb3BpZXNba2V5XSA9IFtdO1xuICAgIHNlcnZpY2UuYXJyYXlDb3BpZXNba2V5XVtpbmRleF0gPSBmb3JtO1xuICAgIC8vc2VydmljZS5hcnJheUNvcGllc1trZXldLnB1c2goZm9ybSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRBcnJheUNvcHkoa2V5LCBpbmRleCkge1xuICAgIGNvbnN0IHNlcnZpY2UgPSB0aGlzO1xuICAgIGNvbnN0IGNvcGllcyA9IHNlcnZpY2UuYXJyYXlDb3BpZXNba2V5XTtcbiAgICByZXR1cm4gY29waWVzICYmIGNvcGllc1tpbmRleF07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRBcnJheUNvcGllcyhrZXkpIHtcbiAgICBjb25zdCBzZXJ2aWNlID0gdGhpcztcbiAgICByZXR1cm4gXy5wbHVjayhzZXJ2aWNlLmdldEFycmF5U2NvcGVzKGtleSksIFwiZm9ybVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEFycmF5Q29waWVzRm9yKGtleVN0YXJ0KSB7XG4gICAgY29uc3Qgc2VydmljZSA9IHRoaXM7XG4gICAga2V5U3RhcnQgKz0gXCJbXVwiO1xuXG4gICAgcmV0dXJuIF8uZmlsdGVyKHNlcnZpY2UuYXJyYXlDb3BpZXMsIChjb3B5LCBrZXkpID0+IGtleS5pbmNsdWRlcyhrZXlTdGFydCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlQXJyYXlDb3BpZXNGb3Ioa2V5LCBpbmRleCkge1xuICAgIGNvbnN0IHNlcnZpY2UgPSB0aGlzO1xuICAgIGNvbnN0IGNvcGllcyA9IHNlcnZpY2UuZ2V0QXJyYXlDb3BpZXNGb3Ioa2V5KTtcbiAgICBfLmVhY2goY29waWVzLCAobGlzdCkgPT4gbGlzdCAmJiBsaXN0LnNwbGljZShpbmRleCwgMSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QXJyYXlTY29wZXMoa2V5KSB7XG4gICAgdmFyIHNlcnZpY2UgPSB0aGlzO1xuICAgIHJldHVybiBzZXJ2aWNlLmFycmF5Q29waWVzW2tleV07XG4gIH1cblxuICBmdW5jdGlvbiBhZGRUb1Njb3BlQ2FjaGUoc2NvcGUsIGtleSkge1xuICAgIGNvbnN0IHNlcnZpY2UgPSB0aGlzO1xuICAgIGlmIChzZXJ2aWNlLnNjb3BlQ2FjaGVba2V5XSkge1xuICAgICAgY29uc29sZS53YXJuKFwiY2FjaGluZyBkdXBsaWNhdGUgc2NvcGUgZm9yXCIsIGtleSk7XG4gICAgfVxuICAgIHJldHVybiAoc2VydmljZS5zY29wZUNhY2hlW2tleV0gPSBzY29wZSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRGcm9tU2NvcGVDYWNoZShrZXkpIHtcbiAgICBjb25zdCBzZXJ2aWNlID0gdGhpcztcbiAgICByZXR1cm4gc2VydmljZS5zY29wZUNhY2hlW2tleV07XG4gIH1cblxuICBmdW5jdGlvbiBhZGRUb0Zvcm1DYWNoZShmaWVsZCwga2V5KSB7XG4gICAgdmFyIHNlcnZpY2UgPSB0aGlzO1xuICAgIGtleSA9IGtleSB8fCBzZXJ2aWNlLmdldEtleShmaWVsZC5rZXkpO1xuICAgIGlmICghc2VydmljZS5nZXRGcm9tRm9ybUNhY2hlKGtleSkpIHNlcnZpY2UuZm9ybUNhY2hlW2tleV0gPSBmaWVsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZyb21Gb3JtQ2FjaGUoa2V5KSB7XG4gICAgdmFyIHNlcnZpY2UgPSB0aGlzO1xuICAgIHJldHVybiBzZXJ2aWNlLmZvcm1DYWNoZVtrZXldO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkVG9EYXRhQ2FjaGUoa2V5LCBtb2RlbFZhbHVlKSB7XG4gICAgdmFyIHNlcnZpY2UgPSB0aGlzO1xuXG4gICAgaWYgKGtleSkge1xuICAgICAgc2VydmljZS5kYXRhQ2FjaGVba2V5XSA9IG1vZGVsVmFsdWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RnJvbURhdGFDYWNoZShrZXkpIHtcbiAgICB2YXIgc2VydmljZSA9IHRoaXM7XG5cbiAgICByZXR1cm4gc2VydmljZS5kYXRhQ2FjaGVba2V5XTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGNoSW50U3RySW5kZXgoZXhwKSB7XG4gICAgcmV0dXJuIGV4cC5tYXRjaCgvXFxbKC0/XFxkK3xcIi4qXCJ8Jy4qJyldLyk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaE5lc3RlZEV4cHJlc3Npb24oZXhwKSB7XG4gICAgbGV0IFt0b1JlcGxhY2VdID0gbWF0Y2hJbnRTdHJJbmRleChleHApIHx8IFtdO1xuICAgIGNvbnN0IHJlcGxhY2VkID0gW107XG5cbiAgICB3aGlsZSAodG9SZXBsYWNlKSB7XG4gICAgICByZXBsYWNlZC5wdXNoKHRvUmVwbGFjZSk7XG4gICAgICBleHAgPSBleHAucmVwbGFjZSh0b1JlcGxhY2UsIGBmZl9yJHtyZXBsYWNlZC5sZW5ndGggLSAxfV9mZmApO1xuICAgICAgW3RvUmVwbGFjZV0gPSBtYXRjaEludFN0ckluZGV4KGV4cCkgfHwgW107XG4gICAgfVxuXG4gICAgY29uc3QgbWF0Y2ggPSBleHAubWF0Y2goL1xcWyhbXltcXF1dKyldKFteW1xcXV0qKS8pO1xuXG4gICAgcmV0dXJuIG1hdGNoICYmIHJlcGxhY2VkLmxlbmd0aFxuICAgICAgPyBtYXRjaC5tYXAoKGV4cCkgPT4ge1xuICAgICAgICAgIGxldCBbdG9SZXBsYWNlLCBpbmRleF0gPSBleHAubWF0Y2goL2ZmX3IoXFxkKylfZmYvKSB8fCBbXTtcbiAgICAgICAgICB3aGlsZSAodG9SZXBsYWNlKSB7XG4gICAgICAgICAgICBleHAgPSBleHAucmVwbGFjZSh0b1JlcGxhY2UsIHJlcGxhY2VkW2luZGV4XSk7XG4gICAgICAgICAgICBbdG9SZXBsYWNlLCBpbmRleF0gPSBleHAubWF0Y2goL2ZmX3IoXFxkKylfZmYvKSB8fCBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGV4cDtcbiAgICAgICAgfSlcbiAgICAgIDogbWF0Y2g7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlTmVzdGVkRXhwcmVzc2lvbnMoZXhwLCBkZXB0aCkge1xuICAgIGNvbnN0IHNlcnZpY2UgPSB0aGlzO1xuICAgIGxldCBbLCBuZXN0ZWRdID0gbWF0Y2hOZXN0ZWRFeHByZXNzaW9uKGV4cCkgfHwgW107XG5cbiAgICB3aGlsZSAobmVzdGVkKSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSBzZXJ2aWNlLnBhcnNlRXhwcmVzc2lvbihuZXN0ZWQsIGRlcHRoKS5nZXQoKTtcbiAgICAgIGNvbnN0IGtleVZhbCA9IF8uaXNVbmRlZmluZWQocGFyc2VkKVxuICAgICAgICA/IFwiXCJcbiAgICAgICAgOiBfLmlzU3RyaW5nKHBhcnNlZClcbiAgICAgICAgPyBgXCIke3BhcnNlZH1cImBcbiAgICAgICAgOiBwYXJzZWQ7XG4gICAgICBleHAgPSBleHAucmVwbGFjZShgWyR7bmVzdGVkfV1gLCBgWyR7a2V5VmFsfV1gKTtcbiAgICAgIFssIG5lc3RlZF0gPSBtYXRjaE5lc3RlZEV4cHJlc3Npb24oZXhwKSB8fCBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKGV4cCwgZGVwdGgpIHtcbiAgICBjb25zdCBzZXJ2aWNlID0gdGhpcztcblxuICAgIGlmICghXy5pc1N0cmluZyhleHApICYmICFfLmlzQXJyYXkoZXhwKSkge1xuICAgICAgcmV0dXJuIHsgZ2V0OiAoKSA9PiBleHAgfTtcbiAgICB9XG5cbiAgICAvLyBpZiBleHByZXNzaW9uIGlzIHNwZWNpZmljIHZhbHVlXG4gICAgaWYgKFxuICAgICAgL14obnVsbHxmYWxzZXx0cnVlfHVuZGVmaW5lZHwnW15cXCddKid8XCJbXlxcXCJdKlwifC0/WzAtOS5dK3xcXFtdfFxce30pJC8udGVzdChcbiAgICAgICAgZXhwXG4gICAgICApXG4gICAgKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWV4cCkgcmV0dXJuIGV4cDtcbiAgICAgICAgICBjb25zdCBpc1N0ciA9IGV4cC5tYXRjaCgvXCIoW15cXFwiXSopXCIvKSB8fCBleHAubWF0Y2goLycoW15cXCddKiknLyk7XG4gICAgICAgICAgaWYgKGlzU3RyKSByZXR1cm4gaXNTdHJbMV07XG4gICAgICAgICAgc3dpdGNoIChleHApIHtcbiAgICAgICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY2FzZSBcImZhbHNlXCI6XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgXCJ0cnVlXCI6XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiW11cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgY2FzZSBcInt9XCI6XG4gICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGV4cCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBleHAgPSBzZXJ2aWNlLmdldEtleShleHApO1xuXG4gICAgY29uc3QgbWF0Y2ggPSBleHAubWF0Y2goL14obW9kZWxcXC4pPyhcXFMrKSQvKTtcblxuICAgIGNvbnN0IG1vZGVsVmFsdWUgPSB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIGxldCByZXNvbHZlZCA9IHNlcnZpY2UucmVzb2x2ZU5lc3RlZEV4cHJlc3Npb25zKGV4cCwgZGVwdGgpO1xuICAgICAgICBsZXQgcGF0aCA9IE9iamVjdFBhdGgucGFyc2UocmVzb2x2ZWQpO1xuICAgICAgICBsZXQgc3RhcnQgPSBkZXB0aCB8fCBzZXJ2aWNlO1xuXG4gICAgICAgIHdoaWxlIChzdGFydCAmJiBwYXRoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBzdGFydCA9IHN0YXJ0W3BhdGguc2hpZnQoKV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RhcnQgJiYgc3RhcnRbcGF0aFswXV07XG4gICAgICB9LFxuXG4gICAgICBnZXRBc3NpZ25hYmxlKHsgbm9Db25zdHJ1Y3Rpb24gfSA9IHt9KSB7XG4gICAgICAgIGxldCByZXNvbHZlZCA9IHNlcnZpY2UucmVzb2x2ZU5lc3RlZEV4cHJlc3Npb25zKGV4cCwgZGVwdGgpO1xuICAgICAgICBsZXQgcGF0aCA9IE9iamVjdFBhdGgucGFyc2UocmVzb2x2ZWQpO1xuICAgICAgICBsZXQgcHJvZ3Jlc3MgPSBbXTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gZGVwdGggfHwgc2VydmljZTtcblxuICAgICAgICB3aGlsZSAoc3RhcnQgJiYgcGF0aC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgbGV0IGtleSA9IHBhdGguc2hpZnQoKTtcbiAgICAgICAgICBwcm9ncmVzcy5wdXNoKGtleSk7XG4gICAgICAgICAgaWYgKCFzdGFydFtrZXldKSB7XG4gICAgICAgICAgICBpZiAobm9Db25zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoL15cXGQ/JC8udGVzdChwYXRoWzBdKSkge1xuICAgICAgICAgICAgICBzdGFydFtrZXldID0gW107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdGFydFtrZXldID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXJ0ID0gc3RhcnRba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgb2JqOiBzdGFydCxcbiAgICAgICAgICBrZXk6IHBhdGhbMF0sXG4gICAgICAgICAgcGF0aDogc2VydmljZS5nZXRLZXkocHJvZ3Jlc3MpLFxuICAgICAgICAgIGZ1bGxQYXRoOiBzZXJ2aWNlLmdldEtleShwcm9ncmVzcy5jb25jYXQocGF0aC5zbGljZSgwLCAxKSkpLFxuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgc2V0KHZhbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNvbHZlZCA9IHNlcnZpY2UucmVzb2x2ZU5lc3RlZEV4cHJlc3Npb25zKGV4cCwgZGVwdGgpO1xuICAgICAgICBsZXQgcGF0aCA9IE9iamVjdFBhdGgucGFyc2UocmVzb2x2ZWQpO1xuICAgICAgICBpZiAodmFsID09PSBcInJlbW92ZVwiKSB7XG4gICAgICAgICAgbGV0IHsgb2JqLCBrZXkgfSA9IHRoaXMuZ2V0QXNzaWduYWJsZSh7IG5vQ29uc3RydWN0aW9uOiB0cnVlIH0pIHx8IHt9O1xuICAgICAgICAgIGRlbGV0ZSBzZXJ2aWNlLmRlZmF1bHRzW3Jlc29sdmVkLnJlcGxhY2UoXCJtb2RlbC5cIiwgXCJcIildO1xuICAgICAgICAgIGlmIChvYmopIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IHsgb2JqLCBrZXkgfSA9IHRoaXMuZ2V0QXNzaWduYWJsZSgpO1xuICAgICAgICAgIG9ialtrZXldID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgIHNlcnZpY2Uuc2lsZW5jZUxpc3RlbmVycyhyZXNvbHZlZCwgZGVwdGgpO1xuICAgICAgICAgIHNlcnZpY2Uuc2tpcERlZmF1bHRzKHJlc29sdmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfSxcblxuICAgICAgcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBleHA6IGV4cCxcbiAgICAgICAgICBkZXB0aDogZGVwdGgsXG4gICAgICAgICAga2V5OiBtYXRjaFsyXSxcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIHJldHVybiBtb2RlbFZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2lsZW5jZUxpc3RlbmVycyhrZXlTdGFydCwgZGVwdGgpIHtcbiAgICBjb25zdCBzZXJ2aWNlID0gdGhpcztcbiAgICBfLmVhY2goc2VydmljZS5saXN0ZW5lcnMsIChsaXN0ZW5lciwga2V5KSA9PiB7XG4gICAgICBpZiAoa2V5LmluZGV4T2Yoa2V5U3RhcnQpID09PSAwKSB7XG4gICAgICAgIGxpc3RlbmVyLnByZXYgPSBhbmd1bGFyLmNvcHkoc2VydmljZS5wYXJzZUV4cHJlc3Npb24oa2V5LCBkZXB0aCkuZ2V0KCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2tpcERlZmF1bHRzKGtleVN0YXJ0KSB7XG4gICAgY29uc3Qgc2VydmljZSA9IHRoaXM7XG4gICAgY29uc3QgaW5kZXggPSBrZXlTdGFydC5tYXRjaCgvXFxbXFxkKlxcXS8pID8gZ2V0QXJyYXlJbmRleChrZXlTdGFydCkgOiBudWxsO1xuICAgIGNvbnN0IGtzID0gc3RyaXBJbmRleGVzKGtleVN0YXJ0KTtcbiAgICBjb25zdCBrZXlzID0gXy5maWx0ZXIoXy5rZXlzKHNlcnZpY2UuZm9ybUNhY2hlKSwgKGspID0+IGsuc3RhcnRzV2l0aChrcykpO1xuICAgIGxldCBza2lwS2V5cyA9IFtdO1xuICAgIF8uZWFjaChrZXlzLCAoa2V5KSA9PiB7XG4gICAgICBjb25zdCBpbmRleGVkS2V5ID0gc2VydmljZS5zZXRBcnJheUluZGV4KGtleSwgaW5kZXgpO1xuICAgICAgY29uc3QgbW9kZWwgPSBzZXJ2aWNlLnBhcnNlRXhwcmVzc2lvbihpbmRleGVkS2V5LCBzZXJ2aWNlLm1vZGVsKS5nZXQoKTtcbiAgICAgIGlmIChfLmlzQXJyYXkobW9kZWwpKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkS2V5cyA9IF8uZmlsdGVyKF8ua2V5cyhzZXJ2aWNlLmZvcm1DYWNoZSksIChrKSA9PlxuICAgICAgICAgIGsuc3RhcnRzV2l0aChrZXkpXG4gICAgICAgICk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kZWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBfLmVhY2goY2hpbGRLZXlzLCAoaykgPT4ge1xuICAgICAgICAgICAgc2tpcEtleXMucHVzaChrKTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ZWRDaGlsZEtleSA9IHNlcnZpY2Uuc2V0QXJyYXlJbmRleChrLCBbaW5kZXgsIGldKTtcbiAgICAgICAgICAgIHNlcnZpY2Uuc2tpcERlZmF1bHRbaW5kZXhlZENoaWxkS2V5XSA9IHRydWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXNraXBLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgc2VydmljZS5za2lwRGVmYXVsdFtpbmRleGVkS2V5XSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzQXJyYXkoYXJyYXkpIHtcbiAgICB2YXIgc2VydmljZSA9IHRoaXM7XG4gICAgdmFyIGtleSA9IHNlcnZpY2UuZ2V0S2V5KGFycmF5LmtleSk7XG5cbiAgICBhcnJheS5zb3J0T3B0aW9ucyA9IHtcbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKGUsIHVpKSB7XG4gICAgICAgIGxldCBsaXN0ZW5lciA9IHNlcnZpY2UuYXJyYXlMaXN0ZW5lcnNbYCR7a2V5fS5sZW5ndGhgXTtcbiAgICAgICAgbGlzdGVuZXIuaGFuZGxlcnMuZm9yRWFjaCgoaGFuZGxlcikgPT4ge1xuICAgICAgICAgIGhhbmRsZXIobGlzdGVuZXIucHJldiwgbGlzdGVuZXIucHJldiwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICB9O1xuXG4gICAgc2VydmljZS5wcm9jZXNzU2VjdGlvbihhcnJheSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzU2VjdGlvbihzZWN0aW9uLCBzZWNvbmRQYXNzKSB7XG4gICAgdmFyIHNlcnZpY2UgPSB0aGlzO1xuICAgIC8vIGlmIHdlJ3JlIGhlcmUgYmVjYXVzZSBhIHBhcmVudCdzIHNjb3BlIHdhcyBlbWl0dGVkLFxuICAgIC8vIHNjb3BlIGZvciB0aGlzIHNlY3Rpb24gd2lsbCBzb29uIGJlIGVtaXR0ZWQsIHNvIGNhbiBza2lwXG4gICAgaWYgKHNlY29uZFBhc3MpIHJldHVybjtcbiAgICBfLmVhY2goc2VjdGlvbi5pdGVtcywgc2VydmljZS5wcm9jZXNzRmllbGQuYmluZChzZXJ2aWNlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgIHZhciBzZXJ2aWNlID0gdGhpcztcblxuICAgIGNvbXBvbmVudC50eXBlID0gXCJzZWN0aW9uXCI7XG4gICAgY29tcG9uZW50Lmh0bWxDbGFzcyA9IFwicm93XCI7XG5cbiAgICB2YXIgY29scyA9IDEyIC8gXy5yZWplY3QoY29tcG9uZW50Lml0ZW1zLCBcImhpZGRlblwiKS5sZW5ndGg7XG5cbiAgICBfLmVhY2goY29tcG9uZW50Lml0ZW1zLCBmdW5jdGlvbiAoZmllbGQsIGkpIHtcbiAgICAgIHNlcnZpY2UucHJvY2Vzc0ZpZWxkKGZpZWxkKTtcbiAgICAgIGNvbXBvbmVudC5pdGVtc1tpXSA9IHtcbiAgICAgICAgdHlwZTogXCJzZWN0aW9uXCIsXG4gICAgICAgIGh0bWxDbGFzczogXCJjb2wtc20tXCIgKyBjb2xzLFxuICAgICAgICBpdGVtczogW2ZpZWxkXSxcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzQ3VycmVuY3koZmllbGQpIHtcbiAgICBmaWVsZC5jdXJyZW5jeUZvcm1hdCA9IHtcbiAgICAgIFwiY3VycmVuY3ktZG9sbGFyc1wiOiBcImRvbGxhcnNcIixcbiAgICAgIFwiY3VycmVuY3ktbWljcm9jZW50c1wiOiBcIm1pY3JvY2VudHNcIixcbiAgICAgIGN1cnJlbmN5OiBcImNlbnRzXCIsXG4gICAgfVtmaWVsZC5zY2hlbWEuZm9ybWF0XTtcblxuICAgIGZpZWxkLnR5cGUgPSBcImNuLWN1cnJlbmN5XCI7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzTnVtYmVyKGZpZWxkKSB7XG4gICAgZmllbGQudHlwZSA9IFwiY24tbnVtYmVyXCI7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzUGVyY2VudGFnZShmaWVsZCkge1xuICAgIGZpZWxkLnR5cGUgPSBcImNuLXBlcmNlbnRhZ2VcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NVcmwoZmllbGQpIHtcbiAgICBmaWVsZC50eXBlID0gXCJjbi11cmxcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NSZXVzYWJsZShmaWVsZCkge1xuICAgIHZhciBzZXJ2aWNlID0gdGhpcztcbiAgICBmaWVsZC50eXBlID0gXCJjbi1yZXVzYWJsZVwiO1xuICAgIGZpZWxkLnZpZXcgPSBmaWVsZC52aWV3IHx8IFwibmV3XCI7XG4gICAgZmllbGQuaXRlbXMuZm9yRWFjaChzZXJ2aWNlLnByb2Nlc3NGaWVsZC5iaW5kKHNlcnZpY2UpKTtcbiAgICBmaWVsZC5pdGVtcyA9IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJzZWN0aW9uXCIsXG4gICAgICAgIGl0ZW1zOiBmaWVsZC5pdGVtcyxcbiAgICAgICAgY29uZGl0aW9uOiBcIiFtb2RlbC5cIiArIHNlcnZpY2UuZ2V0S2V5KGZpZWxkLmtleSkgKyBcIi5pZFwiLFxuICAgICAgfSxcbiAgICBdO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0ZhY2Vib29rVmlkZW8oZmllbGQpIHtcbiAgICB2YXIgc2VydmljZSA9IHRoaXM7XG4gICAgZmllbGQudHlwZSA9IFwiY24tZmFjZWJvb2t2aWRlb1wiO1xuICAgIGlmICghZmllbGQucmVzb2x2ZSkge1xuICAgICAgZmllbGQucmVzb2x2ZSA9IHt9O1xuICAgICAgXy5lYWNoKGZpZWxkLmRhdGEsIChleHAsIHByb3ApID0+IChmaWVsZC5yZXNvbHZlW2BkYXRhLiR7cHJvcH1gXSA9IGV4cCkpO1xuICAgIH1cbiAgICBzZXJ2aWNlLnByb2Nlc3NSZXNvbHZlKGZpZWxkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NDcmVhdGl2ZUltYWdlKGZpZWxkKSB7XG4gICAgdmFyIHNlcnZpY2UgPSB0aGlzO1xuICAgIGZpZWxkLnR5cGUgPSBcImNuLWNyZWF0aXZlaW1hZ2VcIjtcbiAgICBpZiAoIWZpZWxkLnJlc29sdmUpIHtcbiAgICAgIGZpZWxkLnJlc29sdmUgPSB7fTtcbiAgICAgIF8uZWFjaChmaWVsZC5kYXRhLCAoZXhwLCBwcm9wKSA9PiAoZmllbGQucmVzb2x2ZVtgZGF0YS4ke3Byb3B9YF0gPSBleHApKTtcbiAgICB9XG4gICAgc2VydmljZS5wcm9jZXNzUmVzb2x2ZShmaWVsZCk7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzTWVkaWFVcGxvYWQoZmllbGQpIHtcbiAgICB2YXIgc2VydmljZSA9IHRoaXM7XG4gICAgZmllbGQudHlwZSA9IFwiY24tbWVkaWF1cGxvYWRcIjtcbiAgICBpZiAoIWZpZWxkLnJlc29sdmUpIHtcbiAgICAgIGZpZWxkLnJlc29sdmUgPSB7fTtcbiAgICAgIF8uZWFjaChmaWVsZC5kYXRhLCAoZXhwLCBwcm9wKSA9PiAoZmllbGQucmVzb2x2ZVtgZGF0YS4ke3Byb3B9YF0gPSBleHApKTtcbiAgICB9XG4gICAgc2VydmljZS5wcm9jZXNzUmVzb2x2ZShmaWVsZCk7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzQ3N2VXBsb2FkKGZpZWxkKSB7XG4gICAgdmFyIHNlcnZpY2UgPSB0aGlzO1xuICAgIGZpZWxkLnR5cGUgPSBcImNuLWNzdnVwbG9hZFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc1JhZGlvcyhmaWVsZCkge1xuICAgIGZpZWxkLnR5cGUgPSBcImNuLXJhZGlvc1wiO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc1JhZGlvYnV0dG9ucyhyYWRpb3MpIHtcbiAgICB2YXIgc2VydmljZSA9IHRoaXM7XG4gICAgcmFkaW9zLnR5cGUgPSBcImNuLXJhZGlvYnV0dG9uc1wiO1xuICAgIGlmIChyYWRpb3MuZnVsbFdpZHRoKSB7XG4gICAgICByYWRpb3MuYnRuQ2xhc3MgPSBcImNvbC1zbS1cIiArIF8uZGl2aWRlKDEyLCByYWRpb3MudGl0bGVNYXAubGVuZ3RoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzRGF0ZShkYXRlKSB7XG4gICAgdmFyIHNlcnZpY2UgPSB0aGlzO1xuICAgIGRhdGUudHlwZSA9IFwiY24tZGF0ZXRpbWVwaWNrZXJcIjtcblxuICAgIGlmIChkYXRlLnNjaGVtYS5mb3JtYXQgPT09IFwidGltZS1taW51dGVzXCIpIHtcbiAgICAgIGRhdGUubWF4VmlldyA9IFwiaG91clwiO1xuICAgICAgZGF0ZS5pY29uQ2xhc3MgPSBcImZhIGZhLWNsb2NrLW9cIjtcblxuICAgICAgZGF0ZS5tb2RlbEZvcm1hdHRlciA9ICh2YWwpID0+IHtcbiAgICAgICAgaWYgKCF2YWwpIHJldHVybjtcblxuICAgICAgICBsZXQgbSA9IG1vbWVudCh2YWwpO1xuXG4gICAgICAgIHJldHVybiBfLmFkZChfLm11bHRpcGx5KG0uaG91cnMoKSwgNjApLCBtLm1pbnV0ZXMoKSk7XG4gICAgICB9O1xuXG4gICAgICBkYXRlLm1vZGVsUGFyc2VyID0gKHZhbCkgPT4ge1xuICAgICAgICBpZiAoIXZhbCkgcmV0dXJuO1xuXG4gICAgICAgIGxldCBkID0gcGFyc2VJbnQodmFsKTtcbiAgICAgICAgbGV0IGhvdXJzID0gXy5mbG9vcihkIC8gNjApO1xuICAgICAgICBsZXQgbWludXRlcyA9IGQgJSA2MDtcblxuICAgICAgICByZXR1cm4gbW9tZW50KClcbiAgICAgICAgICAuc3RhcnRPZihcImRheVwiKVxuICAgICAgICAgIC5hZGQoXCJob3Vyc1wiLCBob3VycylcbiAgICAgICAgICAuYWRkKFwibWludXRlc1wiLCBtaW51dGVzKTtcbiAgICAgIH07XG5cbiAgICAgIGRhdGUudmlld0Zvcm1hdHRlciA9ICh2YWwpID0+IHtcbiAgICAgICAgaWYgKCF2YWwpIHJldHVybjtcblxuICAgICAgICByZXR1cm4gZGF0ZS5tb2RlbFBhcnNlcih2YWwpLmZvcm1hdChkYXRlLmRhdGVGb3JtYXQpO1xuICAgICAgfTtcblxuICAgICAgZGF0ZS52aWV3UGFyc2VyID0gKHZhbCkgPT4ge1xuICAgICAgICBpZiAoIXZhbCkgcmV0dXJuO1xuXG4gICAgICAgIGxldCBtYXRjaCA9IHZhbC5tYXRjaCgvXihcXGR7MSwyfSk6PyhcXGR7MSwyfSk/IChhfHApLyk7XG4gICAgICAgIGlmICghbWF0Y2gpIHJldHVybjtcblxuICAgICAgICBsZXQgaG91cnMgPSBfLmFkZChcbiAgICAgICAgICBtYXRjaFsxXSA9PT0gXCIxMlwiID8gMCA6IG1hdGNoWzFdLFxuICAgICAgICAgIG1hdGNoWzNdID09PSBcImFcIiA/IDAgOiAxMlxuICAgICAgICApO1xuICAgICAgICBsZXQgbWludXRlcyA9IG1hdGNoWzJdIHx8IFwiMDBcIjtcblxuICAgICAgICBpZiAobWludXRlcy5sZW5ndGggPT09IDEpIG1pbnV0ZXMgKz0gXCIwXCI7XG5cbiAgICAgICAgcmV0dXJuIF8uYWRkKF8ubXVsdGlwbHkoaG91cnMsIDYwKSwgbWludXRlcyk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNlbGVjdFZhbFByb3Aoc2VsZWN0KSB7XG4gICAgbGV0IGlzQXJyYXkgPSBzZWxlY3QuZ2V0U2NoZW1hVHlwZSgpID09PSBcImFycmF5XCI7XG4gICAgcmV0dXJuIChcbiAgICAgIHNlbGVjdC52YWx1ZVByb3BlcnR5IHx8XG4gICAgICAoKGlzQXJyYXkgPyBzZWxlY3Quc2NoZW1hLml0ZW1zLnR5cGUgOiBzZWxlY3Quc2NoZW1hLnR5cGUpICE9PSBcIm9iamVjdFwiICYmXG4gICAgICAgIFwidmFsdWVcIilcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QWxsb3dlZFNlbGVjdFZhbHVlKHNlbGVjdCwgdmFsLCB0aXRsZU1hcCkge1xuICAgIHRpdGxlTWFwID0gdGl0bGVNYXAgfHwgc2VsZWN0LmdldFRpdGxlTWFwKCk7XG4gICAgbGV0IHZhbFByb3AgPSBnZXRTZWxlY3RWYWxQcm9wKHNlbGVjdCk7XG4gICAgbGV0IG9taXRIYXNoS2V5ID0gdmFsUHJvcFxuICAgICAgPyBfLmlkZW50aXR5XG4gICAgICA6IF8ucGFydGlhbFJpZ2h0KF8ub21pdCwgXCIkJGhhc2hLZXlcIik7XG4gICAgbGV0IGZpbmRGbiA9IHZhbFByb3BcbiAgICAgID8gXy5jb21wb3NlKFxuICAgICAgICAgIF8ucGFydGlhbChfLmZpbmQsIHRpdGxlTWFwKSxcbiAgICAgICAgICBfLnBhcnRpYWwoXy5zZXQsIHt9LCB2YWxQcm9wKSxcbiAgICAgICAgICBvbWl0SGFzaEtleVxuICAgICAgICApXG4gICAgICA6IF8uY29tcG9zZShfLnBhcnRpYWwoXy5maW5kLCB0aXRsZU1hcCksIG9taXRIYXNoS2V5KTtcbiAgICBpZiAoc2VsZWN0LmdldFNjaGVtYVR5cGUoKSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICBpZiAoIXZhbCB8fCAhXy5pc0FycmF5KHZhbCkpIHJldHVybjtcbiAgICAgIHJldHVybiB2YWwubWFwKGZpbmRGbikuZmlsdGVyKCh4KSA9PiB4ICE9PSB1bmRlZmluZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmluZEZuKHZhbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc1NjaGVkdWxlKGZpZWxkKSB7XG4gICAgZmllbGQuc3RhcnRFbXB0eSA9IHRydWU7XG4gICAgZmllbGQudHlwZSA9IFwiY24tc2NoZWR1bGVcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NTZWxlY3Qoc2VsZWN0KSB7XG4gICAgY29uc3Qgc2VydmljZSA9IHRoaXM7XG4gICAgY29uc3Qgc2NoZW1hID0gc2VsZWN0LnNjaGVtYTtcblxuICAgIGlmIChzZWxlY3QudGl0bGVNYXBSZXNvbHZlIHx8IHNlbGVjdC50aXRsZU1hcCkge1xuICAgICAgc2VsZWN0LmdldFRpdGxlTWFwID0gKCkgPT5cbiAgICAgICAgc2VsZWN0LnRpdGxlTWFwIHx8IHNlcnZpY2Uuc2NoZW1hLmRhdGFbc2VsZWN0LnRpdGxlTWFwUmVzb2x2ZV07XG5cbiAgICAgIHNlbGVjdC5vbkluaXQgPSBmdW5jdGlvbiAodmFsLCBmb3JtLCBldmVudCwgc2V0dGVyKSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSB1c2UgY29ycmVjdCB2YWx1ZVxuICAgICAgICB2YXIgbW9kZWxWYWx1ZSA9IHNlcnZpY2UucGFyc2VFeHByZXNzaW9uKGZvcm0ua2V5LCBzZXJ2aWNlLm1vZGVsKTtcbiAgICAgICAgaWYgKGV2ZW50ID09PSBcInRhZy1pbml0XCIpIHtcbiAgICAgICAgICBsZXQgbmV3VmFsID0gZ2V0QWxsb3dlZFNlbGVjdFZhbHVlKHNlbGVjdCwgbW9kZWxWYWx1ZS5nZXQoKSk7XG4gICAgICAgICAgaWYgKG5ld1ZhbCAhPT0gdW5kZWZpbmVkKSBzZXR0ZXIobmV3VmFsKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0LnRpdGxlTWFwUXVlcnkpIHtcbiAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gc2VsZWN0LnRpdGxlTWFwUXVlcnkucGFyYW1zO1xuICAgICAgY29uc3QgcGFyYW1zS2V5cyA9IF8ua2V5cyhxdWVyeVBhcmFtcyk7XG4gICAgICBzZWxlY3Quc2hvd0NsZWFyQWxsID0gdHJ1ZTtcbiAgICAgIHNlbGVjdC5zaG93Q2xlYXJDYWNoZSA9ICEhc2VsZWN0LnRpdGxlTWFwUXVlcnkucGFyYW1zLnJlZnJlc2hEYXRhO1xuICAgICAgc2VsZWN0LnNpbmdsZVF1ZXJ5ID0gc2VsZWN0Lm1pbkxvb2t1cCA9PT0gMDtcbiAgICAgIHNlbGVjdC50aXRsZVF1ZXJ5ID0gKHEsIHsgcmVmcmVzaERhdGEgfSkgPT4ge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBfKHBhcmFtc0tleXMpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgICBpZiAoa2V5ID09PSBcInFcIikge1xuICAgICAgICAgICAgYWNjW3F1ZXJ5UGFyYW1zW2tleV1dID0gcTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJyZWZyZXNoRGF0YVwiKSB7XG4gICAgICAgICAgICBpZiAocmVmcmVzaERhdGEpIGFjY1txdWVyeVBhcmFtc1trZXldXSA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cCA9IHNlcnZpY2UucmVwbGFjZUFycmF5SW5kZXgoXG4gICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zW2tleV0sXG4gICAgICAgICAgICAgIHNlbGVjdC5hcnJheUluZGV4XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGV0IHZhbCA9IG51bGwsXG4gICAgICAgICAgICAgIHZhcmlhYmxlcyA9IGV4cC5zcGxpdChcInx8XCIpO1xuICAgICAgICAgICAgZm9yIChsZXQgZXhwIG9mIHZhcmlhYmxlcykge1xuICAgICAgICAgICAgICB2YWwgPSBzZXJ2aWNlLnBhcnNlRXhwcmVzc2lvbihleHAudHJpbSgpKS5nZXQoKTtcbiAgICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2Nba2V5XSA9IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICByZXR1cm4gQXBpLmdldCh7XG4gICAgICAgICAgdXJsOiBzZWxlY3QudGl0bGVNYXBRdWVyeS51cmwsXG4gICAgICAgICAgcGFyYW1zLFxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGlmICghXy5pc051bWJlcihzZWxlY3QubWluTG9va3VwKSlcbiAgICAgICAgc2VsZWN0Lm1pbkxvb2t1cCA9IHBhcmFtc0tleXMubGVuZ3RoID8gMyA6IDA7XG4gICAgICBpZiAoIV8uaGFzKHNlbGVjdCwgXCJza2lwRmlsdGVyaW5nXCIpKVxuICAgICAgICBzZWxlY3Quc2tpcEZpbHRlcmluZyA9ICEhc2VsZWN0Lm1pbkxvb2t1cDtcblxuICAgICAgc2VsZWN0Lm9uSW5pdCA9IGZ1bmN0aW9uICh2YWwsIGZvcm0sIGV2ZW50LCBzZXR0ZXIpIHtcbiAgICAgICAgaWYgKGV2ZW50ID09PSBcInRhZy1pbml0XCIpIHtcbiAgICAgICAgICBzZXR0ZXIodmFsKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNOdW1iZXIoc2VsZWN0Lm1pbkxvb2t1cCkpIHNlbGVjdC5taW5Mb29rdXAgPSAwO1xuXG4gICAgaWYgKHNjaGVtYS5pdGVtcykge1xuICAgICAgdmFyIGRlZmF1bHRzID0gW107XG4gICAgICBfLmVhY2goc2NoZW1hLml0ZW1zLnByb3BlcnRpZXMsIGZ1bmN0aW9uIChzY2hlbWEsIGtleSkge1xuICAgICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoc2NoZW1hLmRlZmF1bHQpKSB7XG4gICAgICAgICAgZGVmYXVsdHMucHVzaCh7XG4gICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IHNjaGVtYS5kZWZhdWx0LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChkZWZhdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgc2VsZWN0Lm9uQWRkID0gZnVuY3Rpb24gKHZhbCwgZm9ybSwgZXZlbnQpIHtcbiAgICAgICAgICBpZiAodmFsLnZhbHVlICYmIGV2ZW50ID09PSBcInRhZy1hZGRlZFwiKSB7XG4gICAgICAgICAgICBfLmVhY2goZGVmYXVsdHMsIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgIGlmICghdmFsLnZhbHVlW3Byb3Aua2V5XSkgdmFsLnZhbHVlW3Byb3Aua2V5XSA9IHByb3AuZGVmYXVsdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0LmRpc3BsYXlGb3JtYXQpIHtcbiAgICAgIHNlbGVjdC5pdGVtRm9ybWF0dGVyID0gc2VydmljZS5wcm9jZXNzVGVtcGxhdGUoc2VsZWN0LmRpc3BsYXlGb3JtYXQpO1xuICAgIH1cblxuICAgIGlmICghc2VsZWN0LnR5cGUuaW5jbHVkZXMoXCJjbi1hdXRvY29tcGxldGVcIikpIHtcbiAgICAgIGlmIChzZWxlY3QuaXRlbXMpIHtcbiAgICAgICAgc2VsZWN0LmRldGFpbGVkTGlzdCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHNlbGVjdC5pdGVtc1swXS50eXBlICE9PSBcImNvbXBvbmVudFwiKSB7XG4gICAgICAgICAgaWYgKHNlbGVjdC5pdGVtcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBfLmVhY2goc2VsZWN0Lml0ZW1zLCAoaSkgPT4gKGkuZGVzdHJveVN0cmF0ZWd5ID0gXCJyZXRhaW5cIikpO1xuICAgICAgICAgICAgc2VsZWN0Lml0ZW1zID0gW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21wb25lbnRcIixcbiAgICAgICAgICAgICAgICBpdGVtczogc2VsZWN0Lml0ZW1zLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXJ2aWNlLnByb2Nlc3NGaWVsZHNldChzZWxlY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZWN0LnR5cGUgPSBcImNuLWF1dG9jb21wbGV0ZS1kZXRhaWxlZFwiO1xuICAgICAgICBzZWxlY3QuZGVzdHJveVN0cmF0ZWd5ID0gXCJyZXRhaW5cIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghc2VsZWN0LnNlbGVjdGlvblN0eWxlKSB7XG4gICAgICAgICAgc2VsZWN0LnNlbGVjdGlvblN0eWxlID1cbiAgICAgICAgICAgIHNlbGVjdC5rZXkgPT09IFwidGFnc1wiXG4gICAgICAgICAgICAgID8gXCJ0YWdzXCJcbiAgICAgICAgICAgICAgOiBzZWxlY3QuZ2V0U2NoZW1hVHlwZSgpID09PSBcImFycmF5XCIgJiZcbiAgICAgICAgICAgICAgICBzZWxlY3Quc2NoZW1hLm1heEl0ZW1zICE9PSAxXG4gICAgICAgICAgICAgID8gXCJsaXN0XCJcbiAgICAgICAgICAgICAgOiBcInNlbGVjdFwiO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdC50eXBlID0gXCJjbi1hdXRvY29tcGxldGVcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdC50aXRsZU1hcFJlc29sdmUpIHtcbiAgICAgICAgc2VydmljZS5zY29wZS4kb24oXCJjbkZsZXhGb3JtRGlmZjpkYXRhXCIsIChlLCBkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKGRhdGFbc2VsZWN0LnRpdGxlTWFwUmVzb2x2ZV0pIHtcbiAgICAgICAgICAgIGxldCBtb2RlbFZhbHVlID0gc2VydmljZS5wYXJzZUV4cHJlc3Npb24oc2VsZWN0LmtleSwgc2VydmljZS5tb2RlbCk7XG4gICAgICAgICAgICBsZXQgdmFsID0gbW9kZWxWYWx1ZS5nZXQoKTtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBsZXQgdmFsaWQgPSBnZXRBbGxvd2VkU2VsZWN0VmFsdWUoXG4gICAgICAgICAgICAgICAgc2VsZWN0LFxuICAgICAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgICAgICBkYXRhW3NlbGVjdC50aXRsZU1hcFJlc29sdmVdXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmICh2YWxpZCA9PT0gdW5kZWZpbmVkIHx8IChfLmlzQXJyYXkodmFsaWQpICYmIF8uaXNFbXB0eSh2YWxpZCkpKVxuICAgICAgICAgICAgICAgIG1vZGVsVmFsdWUuc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgc2VydmljZS5yZWdpc3RlckhhbmRsZXIoXG4gICAgICAgIHNlbGVjdC5rZXksXG4gICAgICAgIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICB2YXIgZm9ybSA9XG4gICAgICAgICAgICBzZXJ2aWNlLmZvcm1DdHJsICYmIHNlcnZpY2UuZm9ybUN0cmxbc2VydmljZS5nZXRLZXkoc2VsZWN0LmtleSldO1xuICAgICAgICAgIGlmIChmb3JtICYmIGZvcm0uJHNldERpcnR5KSBmb3JtLiRzZXREaXJ0eSgpO1xuICAgICAgICB9LFxuICAgICAgICBzZWxlY3QudXBkYXRlU2NoZW1hXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NUb2dnbGUodG9nZ2xlKSB7XG4gICAgdG9nZ2xlLnR5cGUgPSBcImNuLXRvZ2dsZVwiO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0hlbHAoaGVscCkge1xuICAgIGhlbHAuaHRtbENsYXNzID0gXCJoZWxwLWJsb2NrXCI7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzRGlzcGxheShkaXNwbGF5KSB7XG4gICAgdmFyIHNlcnZpY2UgPSB0aGlzO1xuICAgIGRpc3BsYXkudHlwZSA9IFwiY24tZGlzcGxheVwiO1xuICAgIGRpc3BsYXkuZ2V0RGlzcGxheSA9IHNlcnZpY2UucHJvY2Vzc1RlbXBsYXRlKGRpc3BsYXkuZGlzcGxheUZvcm1hdCwgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzVGVtcGxhdGUodHBsLCBwYXJzZVNjb3BlKSB7XG4gICAgdmFyIHNlcnZpY2UgPSB0aGlzO1xuICAgIC8vdmFyIHByb2Nlc3NvciA9IC88KFxcUyspW14+XSo+Lio8XFwvXFwxPi8udGVzdCh0cGwpID8gJGNvbXBpbGUgOiAkaW50ZXJwb2xhdGU7XG4gICAgdmFyIHByb2Nlc3NvciA9ICRpbnRlcnBvbGF0ZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNjb3BlLCBhcnJheUluZGV4KSB7XG4gICAgICBpZiAocGFyc2VTY29wZSkge1xuICAgICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoYXJyYXlJbmRleCkpIHtcbiAgICAgICAgICBzY29wZSA9IF8ubWFwKHNjb3BlLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5ID09PSBcImFycmF5SW5kZXhcIiA/IGFycmF5SW5kZXggOiBrZXk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2NvcGUgPSBzZXJ2aWNlLnBhcnNlRXhwcmVzc2lvbihzY29wZSwgc2VydmljZS5tb2RlbCkuZ2V0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvY2Vzc29yKHRwbCkoc2NvcGUpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzVGFibGUodGFibGUpIHtcbiAgICB2YXIgc2VydmljZSA9IHRoaXM7XG4gICAgdGFibGUudHlwZSA9IFwiY24tdGFibGVcIjtcbiAgICB0YWJsZS5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFibGUuY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBfLmV4dGVuZChyb3cuaXRlbXNbaV0sIHRhYmxlLmNvbHVtbnNbaV0pO1xuICAgICAgICBzZXJ2aWNlLnByb2Nlc3NGaWVsZChyb3cuaXRlbXNbaV0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc1NlbGVjdERpc3BsYXkoc2VsZWN0RGlzcGxheSkge1xuICAgIGNvbnN0IHNlcnZpY2UgPSB0aGlzO1xuICAgIC8vIE5lZWRlZCBmb3IgYmF0Y2hmb3JtIHRvIGNoZWNrIHJlY3Vyc2l2ZWx5XG4gICAgbGV0IHNlbGVjdEZpZWxkID0gbnVsbDtcbiAgICBmb3IgKGxldCBpdGVtIG9mIHNlbGVjdERpc3BsYXkuaXRlbXMpIHtcbiAgICAgIGlmIChpdGVtLnNlbGVjdEZpZWxkKSB7XG4gICAgICAgIHNlbGVjdEZpZWxkID0gaXRlbTtcbiAgICAgIH0gZWxzZSBpZiAoaXRlbS5pdGVtcykge1xuICAgICAgICBzZWxlY3RGaWVsZCA9IF8uZmluZChpdGVtLml0ZW1zLCBcInNlbGVjdEZpZWxkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdEZpZWxkKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGJhbmQtYWlkIGJlY2F1c2UgdGhpcyBpcyBiZWluZyBzZXQgYXMgYW4gb2JqZWN0IGluc3RlYWQgb2YgYXJyYXkgc29td2hlcmVcbiAgICAvLyBkZWVwIGluIHRoZSBhbmd1bGFyIG9yIGFuZ3VsYXItc2NoZW1hLWZvcm0gbmV0aGVyLXJlZ2lvbnNcbiAgICBjb25zdCBsaW5rTW9kZWwgPSBzZXJ2aWNlLnBhcnNlRXhwcmVzc2lvbihcbiAgICAgIHNlbGVjdERpc3BsYXkubGluayxcbiAgICAgIHNlcnZpY2UubW9kZWxcbiAgICApO1xuICAgIGlmICghbGlua01vZGVsLmdldCgpKSBsaW5rTW9kZWwuc2V0KFtdKTtcblxuICAgIF8uZWFjaChzZWxlY3REaXNwbGF5Lml0ZW1zLCAoaXRlbSkgPT4ge1xuICAgICAgaWYgKGl0ZW0uc2VsZWN0RmllbGQgPT09IHRydWUpIHJldHVybjtcblxuICAgICAgY29uc3Qga2V5ID0gXy5pc0FycmF5KGl0ZW0ua2V5KSA/IGl0ZW0ua2V5IDogT2JqZWN0UGF0aC5wYXJzZShpdGVtLmtleSk7XG4gICAgICBjb25zdCBmZWF0dXJlS2V5ID0gXy5sYXN0KGtleSk7XG5cbiAgICAgIGl0ZW0uc2hvd0ZlYXR1cmUgPSAoaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgZmVhdHVyZXMgPSBzZXJ2aWNlXG4gICAgICAgICAgLnBhcnNlRXhwcmVzc2lvbihgbW9kZWwuJHtzZWxlY3REaXNwbGF5Lmxpbmt9WyR7aW5kZXh9XS5mZWF0dXJlc2ApXG4gICAgICAgICAgLmdldCgpO1xuICAgICAgICBjb25zdCBzaG93ID0gZmVhdHVyZXMgJiYgZmVhdHVyZXMuaW5jbHVkZXMoZmVhdHVyZUtleSk7XG4gICAgICAgIHJldHVybiBzaG93O1xuICAgICAgfTtcblxuICAgICAgY29uc3QgY29uZGl0aW9uID0gYGZvcm0uc2hvd0ZlYXR1cmUoYXJyYXlJbmRleClgO1xuICAgICAgaXRlbS5jb25kaXRpb24gPSBpdGVtLmNvbmRpdGlvblxuICAgICAgICA/IGAoJHtpdGVtLmNvbmRpdGlvbn0pICYmICR7Y29uZGl0aW9ufWBcbiAgICAgICAgOiBjb25kaXRpb247XG4gICAgfSk7XG4gICAgLy8gaGFuZGxlIGxlZ2FjeSBvYmplY3RzIHRoYXQgZG9uJ3QgaGF2ZSB2YWx1ZXMgc2V0IGluIHRoZSBzZWxlY3RGaWVsZFxuICAgIHZhciBtb2RlbCA9IHNlcnZpY2VcbiAgICAgIC5wYXJzZUV4cHJlc3Npb24oc2VydmljZS5nZXRLZXkoc2VsZWN0RGlzcGxheS5rZXkpLCBzZXJ2aWNlLm1vZGVsKVxuICAgICAgLmdldCgpO1xuICAgIHZhciBzZWxlY3RLZXkgPSBzZXJ2aWNlLmdldEtleShzZWxlY3RGaWVsZC5rZXkpO1xuICAgIF8uZWFjaChtb2RlbCwgZnVuY3Rpb24gKGVsZW0sIGkpIHtcbiAgICAgIHZhciBpbmRleGVkU2VsZWN0S2V5ID0gc2VydmljZS5zZXRBcnJheUluZGV4KHNlbGVjdEtleSwgaSk7XG4gICAgICB2YXIgc2VsZWN0TW9kZWwgPSBzZXJ2aWNlLnBhcnNlRXhwcmVzc2lvbihcbiAgICAgICAgaW5kZXhlZFNlbGVjdEtleSxcbiAgICAgICAgc2VydmljZS5tb2RlbFxuICAgICAgKTtcbiAgICAgIGlmICghc2VsZWN0TW9kZWwuZ2V0KCkpIHNlbGVjdE1vZGVsLnNldChbXSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXR1cFNjaGVtYVJlZnJlc2gocmVmcmVzaCkge1xuICAgIGNvbnN0IHNlcnZpY2UgPSB0aGlzO1xuICAgIHNlcnZpY2UucmVmcmVzaFNjaGVtYSA9IF8uZGVib3VuY2UoKHVwZGF0ZVNjaGVtYSkgPT4ge1xuICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAuLi5jbkZsZXhGb3JtQ29uZmlnLmdldFN0YXRlUGFyYW1zKHNlcnZpY2UuZ2V0UGFyYW1PdmVycmlkZXMoKSksXG4gICAgICAgIC4uLnNlcnZpY2UucGFyYW1zLFxuICAgICAgfTtcbiAgICAgIGxldCBkaWZmID0gXy5vbWl0KFxuICAgICAgICBjblV0aWwuZGlmZihzZXJ2aWNlLnNjaGVtYS5wYXJhbXMsIHBhcmFtcywgdHJ1ZSksXG4gICAgICAgIFwidXBkYXRlc1wiXG4gICAgICApO1xuICAgICAgbGV0IGtleXM7XG5cbiAgICAgIGlmICghXy5pc0VtcHR5KGRpZmYpIHx8IHVwZGF0ZVNjaGVtYSkge1xuICAgICAgICBpZiAodXBkYXRlU2NoZW1hKSBwYXJhbXMudXBkYXRlU2NoZW1hID0gdXBkYXRlU2NoZW1hO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBrZXlzID0gXy5rZXlzKGRpZmYpO1xuXG4gICAgICAgICAgaWYgKGtleXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZGlmZiA9IF8ub21pdChkaWZmLCBfLmlzTnVsbCk7XG4gICAgICAgICAgICBrZXlzID0gXy5rZXlzKGRpZmYpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcmFtcy51cGRhdGVTY2hlbWEgPSBfLmZpcnN0KGtleXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwYXJhbXMudXBkYXRlU2NoZW1hKSB7XG4gICAgICAgICAgZGlmZiA9IGNuVXRpbC5kaWZmKFxuICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgXy5vbWl0KHNlcnZpY2Uuc2NoZW1hLnBhcmFtcywgW1widXBkYXRlU2NoZW1hXCIsIFwidXBkYXRlc1wiXSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGtleXMgPSBfLmtleXMoZGlmZik7XG5cbiAgICAgICAgICBwYXJhbXMudXBkYXRlU2NoZW1hID0gXy5maXJzdChrZXlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZnJlc2gocGFyYW1zKS50aGVuKGZ1bmN0aW9uIChzY2hlbWEpIHtcbiAgICAgICAgICBzZXJ2aWNlLnByb2Nlc3NVcGRhdGVkU2NoZW1hKHNjaGVtYSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIDEwMCk7XG5cbiAgICBzZXJ2aWNlLnJlZnJlc2hEYXRhID0gXy5kZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICByZWZyZXNoKFxuICAgICAgICBfLmV4dGVuZChzZXJ2aWNlLnNjaGVtYS5wYXJhbXMsIHsgdXBkYXRlU2NoZW1hOiBcInJlZnJlc2hEYXRhXCIgfSlcbiAgICAgICkudGhlbihmdW5jdGlvbiAoc2NoZW1hKSB7XG4gICAgICAgIHNlcnZpY2UucHJvY2Vzc1VwZGF0ZWRTY2hlbWEoc2NoZW1hKTtcbiAgICAgIH0pO1xuICAgIH0sIDEwMCk7XG5cbiAgICBzZXJ2aWNlLmV2ZW50cy5wdXNoKFxuICAgICAgc2VydmljZS5zY29wZS4kb24oXCJmZlJlZnJlc2hEYXRhXCIsIHNlcnZpY2UucmVmcmVzaERhdGEpXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVkU2NoZW1hKHNjaGVtYSkge1xuICAgIHZhciBzZXJ2aWNlID0gdGhpcztcbiAgICBpZiAoc2NoZW1hLmRpZmYpIHtcbiAgICAgIHNlcnZpY2UuaW5jcmVtZW50VXBkYXRlcygpO1xuICAgICAgc2VydmljZS5zY2hlbWEucGFyYW1zID0gc2NoZW1hLnBhcmFtcztcbiAgICAgIGlmIChjbkZsZXhGb3JtQ29uZmlnLm9uUHJvY2Vzc0RpZmYpIHtcbiAgICAgICAgY25GbGV4Rm9ybUNvbmZpZy5vblByb2Nlc3NEaWZmKHNjaGVtYSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChPYmplY3Qua2V5cyhzY2hlbWEuZGlmZi5kYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNlcnZpY2Uuc2NvcGUuJGJyb2FkY2FzdChcImNuRmxleEZvcm1EaWZmOmRhdGFcIiwgc2NoZW1hLmRpZmYuZGF0YSk7XG4gICAgICAgIF8uZWFjaChzY2hlbWEuZGlmZi5kYXRhLCAoZGF0YSwgcHJvcCkgPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGRhdGEgJiZcbiAgICAgICAgICAgIGRhdGEuZGF0YSAmJlxuICAgICAgICAgICAgIV8uaXNFbXB0eShzZXJ2aWNlLnNjaGVtYS5kYXRhW3Byb3BdLmRhdGEpICYmXG4gICAgICAgICAgICAhZGF0YS5yZXNldFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZGF0YS5kYXRhID0gc2VydmljZS5zY2hlbWEuZGF0YVtwcm9wXS5kYXRhLmNvbmNhdChkYXRhLmRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXJ2aWNlLnNjaGVtYS5kYXRhW3Byb3BdID0gZGF0YTtcbiAgICAgICAgICBpZiAoc2VydmljZS5yZXNvbHZlUmVnaXN0ZXJbcHJvcF0pIHtcbiAgICAgICAgICAgIF8uZWFjaChzZXJ2aWNlLnJlc29sdmVSZWdpc3Rlcltwcm9wXSwgKHJlZ2lzdGVycykgPT4ge1xuICAgICAgICAgICAgICByZWdpc3RlcnMuZm9yRWFjaCgocmVnaXN0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBzZXJ2aWNlLmhhbmRsZVJlc29sdmUoXG4gICAgICAgICAgICAgICAgICByZWdpc3Rlci5maWVsZCxcbiAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyLnByb3AsXG4gICAgICAgICAgICAgICAgICByZWdpc3Rlci5leHBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGtleXMgPSBbXTtcblxuICAgICAgaWYgKE9iamVjdC5rZXlzKHNjaGVtYS5kaWZmLnNjaGVtYSkubGVuZ3RoID4gMCkge1xuICAgICAgICBzZXJ2aWNlLnNjb3BlLiRicm9hZGNhc3QoXCJjbkZsZXhGb3JtRGlmZjpzY2hlbWFcIiwgc2NoZW1hLmRpZmYuc2NoZW1hKTtcbiAgICAgICAgXy5lYWNoKHNjaGVtYS5kaWZmLnNjaGVtYSwgZnVuY3Rpb24gKHNjaGVtYSwga2V5KSB7XG4gICAgICAgICAgcmVwcm9jZXNzU2NoZW1hKHNjaGVtYSwga2V5LCBrZXlzKTtcbiAgICAgICAgICBjb25zdCBjdXJLZXlzID0gXy5maWx0ZXIoa2V5cywgKGspID0+IF8uc3RhcnRzV2l0aChrLCBrZXkpKTtcbiAgICAgICAgICBfLmVhY2goY3VyS2V5cywgKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZm9ybXMgPSBfLmNvbXBhY3QoW1xuICAgICAgICAgICAgICBzZXJ2aWNlLmdldEZyb21Gb3JtQ2FjaGUoa2V5KSxcbiAgICAgICAgICAgICAgLi4uKHNlcnZpY2UuZ2V0QXJyYXlDb3BpZXMoa2V5KSB8fCBbXSksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIF8uZWFjaChmb3JtcywgKGZvcm0pID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgcHJldlNjaGVtYSA9IGZvcm0uc2NoZW1hO1xuICAgICAgICAgICAgICBjb25zdCBuZXdTY2hlbWEgPSBzZXJ2aWNlLmdldFNjaGVtYShrZXksIHtcbiAgICAgICAgICAgICAgICBbc2NoZW1hLmtleV06IHNjaGVtYSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChwcmV2U2NoZW1hLnJlYWRvbmx5ICYmICFuZXdTY2hlbWEucmVhZG9ubHkpXG4gICAgICAgICAgICAgICAgZm9ybS5yZWFkb25seSA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VydmljZS5zY2hlbWEuc2NoZW1hLnByb3BlcnRpZXNba2V5XSA9IHNjaGVtYTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChPYmplY3Qua2V5cyhzY2hlbWEuZGlmZi5mb3JtKSA+IDApIHtcbiAgICAgICAgc2VydmljZS5zY29wZS4kYnJvYWRjYXN0KFwiY25GbGV4Rm9ybURpZmY6Zm9ybVwiLCBzY2hlbWEuZGlmZi5mb3JtKTtcbiAgICAgICAgXy5lYWNoKHNjaGVtYS5kaWZmLmZvcm0sIChmb3JtLCBrZXkpID0+IHtcbiAgICAgICAgICBpZiAoIWtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZG9uJ3Qgd2FudCB0byBvdmVycmlkZSBrZXkgd2hlbiBleHRlbmRpbmcgY2FjaGVkIG9iamVjdHNcbiAgICAgICAgICAvL3ZhciBrZXkgPSBmb3JtLmtleTtcbiAgICAgICAgICAvL2RlbGV0ZSBmb3JtLmtleTtcblxuICAgICAgICAgIF8uZWFjaChzZXJ2aWNlLmdldEZvcm1zVG9Qcm9jZXNzKGtleSksIChjb3B5KSA9PiB7XG4gICAgICAgICAgICBjb3B5ICYmIHNlcnZpY2UucmVwcm9jZXNzRmllbGQoY29weSwgZm9ybSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImNuLWZvcm1cIilbMF07XG4gICAgICAgIGNvbnN0IG9sZFNjcm9sbCA9IGVsID8gZWwuc2Nyb2xsVG9wIDogMDtcblxuICAgICAgICBzZXJ2aWNlLnNjb3BlLiRicm9hZGNhc3QoXCJzY2hlbWFGb3JtUmVkcmF3XCIpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgZWwuc2Nyb2xsVG9wID0gb2xkU2Nyb2xsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMTAwMCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgICBfLmVhY2goa2V5cywgKGtleSkgPT4ge1xuICAgICAgICAgIF8uZWFjaChcbiAgICAgICAgICAgIHNlcnZpY2UuZ2V0Rm9ybXNUb1Byb2Nlc3Moa2V5KSxcbiAgICAgICAgICAgIChjb3B5KSA9PiBjb3B5ICYmIHNlcnZpY2UucHJvY2Vzc0ZpZWxkKGNvcHkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHNlcnZpY2UuYnJvYWRjYXN0RXJyb3JzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcnZpY2UucmVzZXRVcGRhdGVzKCk7XG4gICAgICBzZXJ2aWNlLnVwZGF0ZVNjaGVtYShzY2hlbWEpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZvcm1zVG9Qcm9jZXNzKGtleSkge1xuICAgIGNvbnN0IHNlcnZpY2UgPSB0aGlzO1xuICAgIGNvbnN0IFssIGFycmF5SW5kZXhdID0ga2V5Lm1hdGNoKC9cXFsoXFxkKStdLykgfHwgW107XG4gICAgY29uc3QgY29waWVzID0gc2VydmljZS5nZXRBcnJheUNvcGllcyhrZXkucmVwbGFjZSgvXFxbXFxkK10vZywgXCJbXVwiKSk7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQoYXJyYXlJbmRleCkpIHtcbiAgICAgIGNvbnN0IGNhY2hlZCA9IHNlcnZpY2UuZ2V0RnJvbUZvcm1DYWNoZShrZXkpO1xuICAgICAgcmV0dXJuIFtjYWNoZWQsIC4uLmNvcGllc107XG4gICAgfVxuICAgIHJldHVybiBbY29waWVzW2FycmF5SW5kZXhdXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcHJvY2Vzc0ZpZWxkKGN1cnJlbnQsIHVwZGF0ZSwgaXNDaGlsZCkge1xuICAgIGNvbnN0IHNlcnZpY2UgPSB0aGlzO1xuICAgIGNvbnN0IGtleSA9IHNlcnZpY2UuZ2V0S2V5KGN1cnJlbnQua2V5KTtcblxuICAgIC8vIG90aGVyIGxvZ2ljIGluIHRoZSBzZXJ2aWNlIHdpbGwgYWRkIGNvbml0aW9uID0gJ3RydWUnIHRvIGZvcmNlXG4gICAgLy8gY29uZGl0aW9uIHRvIGV2YWwgdHJ1ZSwgc28gd2Ugc2V0IHRoZSB1cGRhdGUgY29uZGl0aW9uIHRvICd0cnVlJ1xuICAgIC8vIGJlZm9yZSBjb21wYXJpbmdcbiAgICBpZiAoIXVwZGF0ZS5jb25kaXRpb24gJiYgY3VycmVudC5jb25kaXRpb24pIHVwZGF0ZS5jb25kaXRpb24gPSBcInRydWVcIjtcbiAgICBsZXQgcmVkcmF3ID0gIWlzQ2hpbGQgJiYgY3VycmVudC5jb25kaXRpb24gIT09IHVwZGF0ZS5jb25kaXRpb247XG5cbiAgICBfLmV4dGVuZChjdXJyZW50LCBfLm9taXQodXBkYXRlLCBcIml0ZW1zXCIsIFwia2V5XCIpKTtcblxuICAgIGN1cnJlbnQuX29nS2V5cy5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICBpZiAoIXVwZGF0ZVtwcm9wXSkge1xuICAgICAgICBkZWxldGUgY3VycmVudFtwcm9wXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjdXJyZW50Ll9vZ0tleXMgPSBnZXRPZ0tleXModXBkYXRlKTtcblxuICAgIC8vc2VydmljZS5kZXJlZ2lzdGVySGFuZGxlcnMoa2V5KTtcblxuICAgIHNlcnZpY2Uuc2NvcGUuJGJyb2FkY2FzdChcImNuRmxleEZvcm1SZXByb2Nlc3NGaWVsZFwiLCBrZXkpO1xuXG4gICAgLy8gd2h5IGRvIHdlIHJlZHJhdz8gSWYgd2UncmUgZG9pbmcgaXQgdG8gc2hvdyBlcnJvciBtZXNzYWdlXG4gICAgLy8gdGhhdCBoYXMgYmVlbiBhZGRyZXNzZWQgZnJvbSB0aGUgYW5ndWxhci1zY2hlbWEtZm9ybSBsaWJyYXJ5XG4gICAgLy8gaWYgdGhlcmUncyBhbm90aGVyIGlzc3VlLCB0cnkgdHJpZ2dlcmluZyB0aGUgc3BlY2lmaWMgYWN0aW9uIHJlcXVpcmVkXG4gICAgLy8gaW5zdGVhZCBvZiByZWRyYXdpbmcgdGhlIHdob2xlIGZvcm1cbiAgICBpZiAocmVkcmF3ICYmIGN1cnJlbnQucmVkcmF3KSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlRPRE86IHNlZSBpZiB0aGlzIGNhbiBiZSByZW1vdmVkXCIpO1xuICAgICAgY3VycmVudC5yZWRyYXcoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXByb2Nlc3NTY2hlbWEoc2NoZW1hLCBrZXksIGtleXMpIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgICBpZiAoc2NoZW1hLnByb3BlcnRpZXMpIHtcbiAgICAgIF8uZWFjaChzY2hlbWEucHJvcGVydGllcywgZnVuY3Rpb24gKHNjaGVtYSwgc3ViS2V5KSB7XG4gICAgICAgIHJlcHJvY2Vzc1NjaGVtYShzY2hlbWEsIGtleSArIFwiLlwiICsgc3ViS2V5LCBrZXlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hLml0ZW1zICYmIHNjaGVtYS5pdGVtcy5wcm9wZXJ0aWVzKSB7XG4gICAgICBfLmVhY2goc2NoZW1hLnByb3BlcnRpZXMsIGZ1bmN0aW9uIChzY2hlbWEsIHN1YktleSkge1xuICAgICAgICByZXByb2Nlc3NTY2hlbWEoc2NoZW1hLCBrZXkgKyBcIltdLlwiICsgc3ViS2V5LCBrZXlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERvdEtleShrZXkpIHtcbiAgICByZXR1cm4gKF8uaXNTdHJpbmcoa2V5KSA/IE9iamVjdFBhdGgucGFyc2Uoa2V5KSA6IGtleSkuam9pbihcIi5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZEVycm9yKGZpZWxkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleTogZ2V0RG90S2V5KGZpZWxkLmtleSksXG4gICAgICBtZXNzYWdlOiBmaWVsZC5lcnJvcixcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gYnJvYWRjYXN0RXJyb3JzKCkge1xuICAgIHZhciBzZXJ2aWNlID0gdGhpcztcbiAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoXy5nZXQoc2VydmljZSwgXCJlcnJvcnNcIikpIHtcbiAgICAgICAgc2VydmljZS5lcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICBzZXJ2aWNlLnNjb3BlLiRicm9hZGNhc3QoXG4gICAgICAgICAgICBcInNjaGVtYUZvcm0uZXJyb3IuXCIgKyBlcnJvci5rZXksXG4gICAgICAgICAgICBcInNlcnZlclZhbGlkYXRpb25cIixcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCAxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2VBcnJheUluZGV4KHJlc29sdmUsIGtleSkge1xuICAgIHdoaWxlIChyZXNvbHZlLmluY2x1ZGVzKFwiYXJyYXlJbmRleFwiKSkge1xuICAgICAgaWYgKF8uaXNOdW1iZXIoa2V5KSkgcmV0dXJuIHJlc29sdmUucmVwbGFjZSgvYXJyYXlJbmRleC9nLCBrZXkpO1xuICAgICAgY29uc3QgYXJyYXlJbmRleEtleSA9IC8oW14uW10qKVxcW2FycmF5SW5kZXhcXF0vLmV4ZWMocmVzb2x2ZSk7XG4gICAgICBjb25zdCByZSA9IG5ldyBSZWdFeHAoYXJyYXlJbmRleEtleVsxXSArIFwiXFxcXFsoLT9cXFxcZCspXFxcXF1cIik7XG4gICAgICBjb25zdCBpbmRleCA9IHJlLmV4ZWMoa2V5KTtcbiAgICAgIGlmICghaW5kZXgpIHJldHVybiByZXNvbHZlO1xuICAgICAgcmVzb2x2ZSA9IHJlc29sdmUucmVwbGFjZShcbiAgICAgICAgbmV3IFJlZ0V4cChhcnJheUluZGV4S2V5WzBdLnJlcGxhY2UoLyhcXFt8XFxdKS9nLCBcIlxcXFwkMVwiKSwgXCJnXCIpLFxuICAgICAgICBpbmRleFswXVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc29sdmU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRBcnJheUluZGV4KGtleSkge1xuICAgIGlmIChfLmlzT2JqZWN0KGtleSkpIHtcbiAgICAgIHJldHVybiBfLmZpbmQoa2V5LmtleSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gXy5pc051bWJlcihrZXkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAvXFxbKFxcZCopXFxdLy5leGVjKGtleSlbMV07XG4gIH1cblxuICBmdW5jdGlvbiBzZXRBcnJheUluZGV4KGtleSwgaW5kZXgsIGFzQXJyYXkpIHtcbiAgICBjb25zdCBzZXJ2aWNlID0gdGhpcztcbiAgICBsZXQga2V5Q29weTtcbiAgICBpZiAoIV8uaXNBcnJheShpbmRleCkpIHtcbiAgICAgIGluZGV4ID0gW2luZGV4XTtcbiAgICB9XG4gICAgaWYgKF8uaXNTdHJpbmcoa2V5KSkge1xuICAgICAga2V5Q29weSA9IE9iamVjdFBhdGgucGFyc2Uoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5Q29weSA9IF8uY2xvbmUoa2V5KTtcbiAgICB9XG4gICAgd2hpbGUgKGluZGV4Lmxlbmd0aCAmJiBrZXlDb3B5LmluZGV4T2YoXCJcIikgPiAtMSkge1xuICAgICAgbGV0IGluZGV4T2ZJbmRleCA9IGtleUNvcHkuaW5kZXhPZihcIlwiKTtcbiAgICAgIGtleUNvcHlbaW5kZXhPZkluZGV4XSA9IGluZGV4LnNoaWZ0KCk7XG4gICAgfVxuICAgIGlmIChhc0FycmF5KSB7XG4gICAgICByZXR1cm4ga2V5Q29weTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNlcnZpY2UuZ2V0S2V5KGtleUNvcHkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgdmFyIHNlcnZpY2UgPSB0aGlzO1xuICAgIF8uZWFjaChzZXJ2aWNlLmV2ZW50cywgZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRVcGRhdGVzKCkge1xuICAgIGNvbnN0IHNlcnZpY2UgPSB0aGlzO1xuICAgIHNlcnZpY2UudXBkYXRlcyA9IDA7XG4gICAgc2VydmljZS5wYXJhbXMudXBkYXRlcyA9IHNlcnZpY2UudXBkYXRlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGluY3JlbWVudFVwZGF0ZXMoKSB7XG4gICAgY29uc3Qgc2VydmljZSA9IHRoaXM7XG4gICAgKytzZXJ2aWNlLnVwZGF0ZXM7XG4gICAgc2VydmljZS5wYXJhbXMudXBkYXRlcyA9IHNlcnZpY2UudXBkYXRlcztcbiAgfVxufVxuXG4vL2FuZ3VsYXJcbi8vLm1vZHVsZSgnY24uZmxleC1mb3JtJylcbi8vLnByb3ZpZGVyKCdjbkZsZXhGb3JtU2VydmljZScsIGNuRmxleEZvcm1TZXJ2aWNlUHJvdmlkZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBjbkZsZXhGb3JtU2VydmljZVByb3ZpZGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NuLWZsZXgtZm9ybS5zZXJ2aWNlLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzZfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImxvZGFzaFwiXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV83X187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJvYmplY3RwYXRoXCJcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiY29uc3QgbW9kYWxNYXAgPSB7fTtcbmNvbnN0IHByb21pc2VNYXAgPSB7fTtcblxuZnVuY3Rpb24gZ2V0UHJvbWlzZXMoc3RhdGUpIHtcbiAgaWYocHJvbWlzZU1hcFtzdGF0ZV0pIHJldHVybiBwcm9taXNlTWFwW3N0YXRlXTtcblxuICBjb25zdCBwcm9taXNlID0ge307XG4gIHByb21pc2VNYXBbc3RhdGVdID0gcHJvbWlzZTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIGdldFByb21pc2Uoc3RhdGUsIGlkLCAkcSkge1xuICBjb25zdCBwcm9taXNlcyA9IGdldFByb21pc2VzKHN0YXRlKTtcbiAgaWYocHJvbWlzZXNbaWRdKSByZXR1cm4gcHJvbWlzZXNbaWRdO1xuXG4gIGNvbnN0IHByb21pc2UgPSAkcS5kZWZlcigpO1xuICBwcm9taXNlc1tpZF0gPSBwcm9taXNlO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gY25GbGV4Rm9ybU1vZGFsTG9hZGVyU2VydmljZVByb3ZpZGVyKCkge1xuXG4gIHJldHVybiB7XG4gICAgYWRkTWFwcGluZyxcbiAgICAkZ2V0OiBjbkZsZXhGb3JtTW9kYWxMb2FkZXJTZXJ2aWNlXG4gIH07XG5cbiAgLy8vLy8vLy8vLy8vXG5cbiAgZnVuY3Rpb24gYWRkTWFwcGluZyhzdGF0ZSwgZGVmKSB7XG4gICAgZGVmLnJlc29sdmUgPSB7IHBhcmVudCB9O1xuICAgIG1vZGFsTWFwW3N0YXRlXSA9IGRlZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcmVudCgkc3RhdGVQYXJhbXMsICRxKSB7XG4gICAgJ25nSW5qZWN0JztcblxuICAgIHJldHVybiAoXG4gICAgICBnZXRQcm9taXNlKCRzdGF0ZVBhcmFtcy5tb2RhbCwgJHN0YXRlUGFyYW1zLm1vZGFsSWQsICRxKVxuICAgICAgLnByb21pc2VcbiAgICAgIC50aGVuKCh7IHBhcmVudCB9KSA9PiBwYXJlbnQpXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbkZsZXhGb3JtTW9kYWxMb2FkZXJTZXJ2aWNlKCRzdGF0ZVBhcmFtcywgJHEpIHtcbiAgJ25nSW5qZWN0JztcblxuICByZXR1cm4ge1xuICAgIGdldE1hcHBpbmcsXG4gICAgcmVzb2x2ZU1hcHBpbmcsXG4gICAgcmVtb3ZlTWFwcGluZ1xuICB9O1xuXG4gIC8vLy8vLy8vLy8vLy9cblxuICBmdW5jdGlvbiByZXNvbHZlTWFwcGluZyhzdGF0ZSwgaWQsIHBhcmVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzY29wZSB9ID0gb3B0aW9ucztcbiAgICBpZihzY29wZSkge1xuICAgICAgc2NvcGUub3B0aW9ucyA9IHNjb3BlLm9wdGlvbnMgfHwge307XG4gICAgICBzY29wZS5vcHRpb25zLmRlc3Ryb3lTdHJhdGVneSA9ICdyZXRhaW4nO1xuICAgICAgbW9kYWxNYXBbc3RhdGVdLnNjb3BlID0gc2NvcGU7XG4gICAgfVxuICAgIGNvbnN0IGQgPSBnZXRQcm9taXNlKHN0YXRlLCBpZCwgJHEpO1xuICAgIGQucmVzb2x2ZSh7IHBhcmVudCwgb3B0aW9ucyB9KTtcbiAgICByZXR1cm4gZC5wcm9taXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWFwcGluZyhzdGF0ZSkge1xuICAgIGNvbnN0IGQgPSAkcS5kZWZlcigpO1xuICAgIGdldFByb21pc2UoJHN0YXRlUGFyYW1zLm1vZGFsLCAkc3RhdGVQYXJhbXMubW9kYWxJZCwgJHEpXG4gICAgICAucHJvbWlzZVxuICAgICAgLnRoZW4oKHsgcGFyZW50LCBvcHRpb25zIH0pID0+IHtcbiAgICAgICAgZC5yZXNvbHZlKHsgc3RhdGU6IG1vZGFsTWFwW3N0YXRlXSwgb3B0aW9ucyB9KTtcbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgIH0pO1xuICAgIHJldHVybiBkLnByb21pc2U7XG4gIH1cblxuICAvLyBIb2xkaW5nIG9uIHRvIHNjb3BlIHJlZmVyZW5jZXMgY3JlYXRlcyBtZW1vcnkgbGVha3NcbiAgZnVuY3Rpb24gcmVtb3ZlTWFwcGluZyhzdGF0ZSkge1xuICAgIG1vZGFsTWFwW3N0YXRlXSA9IG51bGw7XG4gICAgcHJvbWlzZU1hcFtzdGF0ZV0gPSBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNuRmxleEZvcm1Nb2RhbExvYWRlclNlcnZpY2VQcm92aWRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jbi1mbGV4LWZvcm0tbW9kYWwtbG9hZGVyLnNlcnZpY2UuanMiLCJmdW5jdGlvbiBGbGV4Rm9ybU1vZGFsTG9hZGVyKEZsZXhGb3JtTW9kYWwsICRzdGF0ZSwgJHJvb3RTY29wZSwgJHN0YXRlUGFyYW1zLCAkc2NvcGUpIHtcbiAgJ25nSW5qZWN0JztcblxuICBmdW5jdGlvbiBGRk1vZGFsTG9hZGVyVGFnKCkge31cbiAgJHNjb3BlLl9fdGFnID0gRkZNb2RhbExvYWRlclRhZygpO1xuXG4gIGNvbnN0IHZtID0gdGhpcztcblxuICBhY3RpdmF0ZSgpO1xuXG4gIC8vLy8vLy8vLy9cblxuICBmdW5jdGlvbiBhY3RpdmF0ZSgpIHtcbiAgICBGbGV4Rm9ybU1vZGFsXG4gICAgICAub3Blbih2bSlcbiAgICAgIC50aGVuKCh7IG1vZGFsLCBvcHRpb25zOiB7IG9uRGlzbWlzcywgb25BZnRlckRpc21pc3MgfSB9KSA9PiB7XG4gICAgICAgIHZtLm1vZGFsID0gbW9kYWw7XG4gICAgICAgIHZtLm1vZGFsLnJlc3VsdC5maW5hbGx5KGdvQmFjayk7XG5cbiAgICAgICAgaWYob25EaXNtaXNzKSB2bS5tb2RhbC5yZXN1bHQuY2F0Y2goKCkgPT4gb25EaXNtaXNzKCRzdGF0ZVBhcmFtcy5yZXN0UGFyYW1zKSk7XG4gICAgICAgIHZtLmRpc21pc3NFdmVudCA9ICRyb290U2NvcGUuJG9uKCckc3RhdGVDaGFuZ2VTdGFydCcsIGRpc21pc3NNb2RhbCk7XG4gICAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICBpZighJHN0YXRlLnRyYW5zaXRpb24pIHtcbiAgICAgICRzdGF0ZS5nbygnXicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc21pc3NNb2RhbCgpIHtcbiAgICAvLyB1bmJpbmQgZXZlbnRcbiAgICB2bS5kaXNtaXNzRXZlbnQoKTtcbiAgICB2bS5tb2RhbC5vcGVuZWQudGhlbigoKSA9PlxuICAgICAgICB2bS5tb2RhbC5kaXNtaXNzKClcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIEZsZXhGb3JtTW9kYWwoY25GbGV4Rm9ybU1vZGFsTG9hZGVyU2VydmljZSwgJHVpYk1vZGFsLCAkc3RhdGVQYXJhbXMpIHtcbiAgJ25nSW5qZWN0JztcblxuICByZXR1cm4geyBvcGVuIH07XG5cbiAgLy8vLy8vLy8vLy8vXG5cbiAgZnVuY3Rpb24gb3BlbigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgY25GbGV4Rm9ybU1vZGFsTG9hZGVyU2VydmljZVxuICAgICAgICAuZ2V0TWFwcGluZygkc3RhdGVQYXJhbXMubW9kYWwpXG4gICAgICAgIC50aGVuKCh7IHN0YXRlLCBvcHRpb25zIH0pID0+ICh7XG4gICAgICAgICAgbW9kYWw6ICR1aWJNb2RhbC5vcGVuKHN0YXRlKSxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgIH0pKVxuICAgICk7XG4gIH1cblxufVxuXG5leHBvcnQgeyBGbGV4Rm9ybU1vZGFsTG9hZGVyLCBGbGV4Rm9ybU1vZGFsIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY24tZmxleC1mb3JtLW1vZGFsLWxvYWRlci5qcyIsImZ1bmN0aW9uIGNuRmxleEZvcm0oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFJyxcbiAgICB0ZW1wbGF0ZTogYFxuICAgICAgPGRpdiBuZy1pZj1cInZtLnNob3dGb3JtKClcIj5cbiAgICAgICAgPCEtLSB3ZSBwcm9jZXNzIGRlZmF1bHRzIG91cnNlbHZlcywgaGVuY2Ugc2V0U2NoZW1hRGVmYXVsdHM6IGZhbHNlIC0tPlxuICAgICAgICA8bmctZm9ybVxuICAgICAgICAgIGNsYXNzPVwiY2xlYXJmaXhcIlxuICAgICAgICAgIG5hbWU9XCJ7e3ZtLmZvcm1OYW1lfX1cIlxuICAgICAgICAgIHNmLW9wdGlvbnM9XCJ7IHNldFNjaGVtYURlZmF1bHRzOiBmYWxzZSB9XCJcbiAgICAgICAgICBzZi1zY2hlbWE9XCJ2bS5jb25maWcuc2NoZW1hLnNjaGVtYVwiXG4gICAgICAgICAgc2YtZm9ybT1cInZtLmZvcm1cIlxuICAgICAgICAgIHNmLW1vZGVsPVwidm0ubW9kZWxcIj5cbiAgICAgICAgPC9uZy1mb3JtPlxuICAgICAgICA8IS0tIGRlYnVnIHBhbmVsIHRvIGRpc3BsYXkgbW9kZWwgLS0+XG4gICAgICAgIDxzZWN0aW9uIG5nLWlmPVwidm0uZGVidWdcIj5cbiAgICAgICAgICA8anNvbi1leHBsb3JlciBqc29uLWRhdGE9XCJ2bS5tb2RlbCB8fCAnLi4ubW9kZWwgbm90IGxvYWRlZCB5ZXQnXCIvPlxuICAgICAgICA8L3NlY3Rpb24+XG4gICAgICA8L2Rpdj5cbiAgICBgLFxuICAgIHNjb3BlOiB7XG4gICAgICBjb25maWc6ICc9ZmZDb25maWcnLFxuICAgICAgbW9kZWw6ICc9ZmZNb2RlbCcsXG4gICAgICBmb3JtSW5kZXg6ICc9ZmZGb3JtSW5kZXgnLFxuICAgICAgZm9ybU5hbWU6ICc9ZmZGb3JtTmFtZScsXG4gICAgICBkZWxheUZvcm06ICc9ZmZEZWxheUZvcm0nLFxuICAgICAgY2xlYW51cEV2ZW50OiAnPWZmQ2xlYW51cEV2ZW50J1xuICAgIH0sXG4gICAgY29udHJvbGxlcjogRmxleEZvcm0sXG4gICAgY29udHJvbGxlckFzOiAndm0nLFxuICAgIGJpbmRUb0NvbnRyb2xsZXI6IHRydWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gRmxleEZvcm0oY25GbGV4Rm9ybVNlcnZpY2UsICRzY29wZSwgJGxvY2F0aW9uKSB7XG4gICduZ0luamVjdCc7XG5cbiAgZnVuY3Rpb24gY25GbGV4Rm9ybVRhZygpIHt9XG4gICRzY29wZS5fX3RhZyA9IG5ldyBjbkZsZXhGb3JtVGFnKCk7XG5cbiAgdmFyIHZtID0gdGhpcztcbiAgdm0uc2VydmljZSA9IHVuZGVmaW5lZDtcbiAgdm0uZXZlbnRzID0gW107XG5cbiAgdm0uYWN0aXZhdGUgPSBhY3RpdmF0ZTtcbiAgdm0uY2xlYW51cCA9IGNsZWFudXA7XG4gIHZtLnByb2Nlc3MgPSBwcm9jZXNzO1xuICB2bS5zaG93Rm9ybSA9IHNob3dGb3JtO1xuXG4gIHZtLmV2ZW50cy5wdXNoKCRzY29wZS4kd2F0Y2goKCkgPT4gdm0uY29uZmlnLnNjaGVtYSwgdm0ucHJvY2VzcykpO1xuXG4gIHZtLmFjdGl2YXRlKCk7XG5cbiAgJHNjb3BlLiRvbih2bS5jbGVhbnVwRXZlbnQgfHwgJyRkZXN0cm95Jywgdm0uY2xlYW51cCk7XG5cbiAgLy8vLy8vLy8vL1xuXG4gIGZ1bmN0aW9uIGFjdGl2YXRlKCkge1xuICAgIGlmKGFuZ3VsYXIuaXNOdW1iZXIodm0uZm9ybUluZGV4KSkge1xuICAgICAgdm0uZm9ybSA9IHZtLmNvbmZpZy5zY2hlbWEuZm9ybXNbdm0uZm9ybUluZGV4XS5mb3JtO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZtLmZvcm0gPSB2bS5jb25maWcuc2NoZW1hLmZvcm07XG4gICAgfVxuXG4gICAgLy8gZGVidWdcbiAgICBpZigkbG9jYXRpb24uc2VhcmNoKCkuZGVidWcpIHtcbiAgICAgIHZtLmRlYnVnID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzKGN1ciwgcHJldikge1xuICAgIGlmKHZtLmZvcm0pIHtcbiAgICAgIGlmKCF2bS5zZXJ2aWNlKSB7XG4gICAgICAgIHZtLnNlcnZpY2UgPSBjbkZsZXhGb3JtU2VydmljZSh2bS5jb25maWcuc2NoZW1hLCB2bS5tb2RlbCwge1xuICAgICAgICAgIGdldFNjb3BlOiB2bS5jb25maWcuZ2V0U2NvcGUgfHwgKCgpID0+ICRzY29wZSksXG4gICAgICAgICAgZm9ybUN0cmw6IHZtLmNvbmZpZy5mb3JtQ3RybCxcbiAgICAgICAgICBnZXRTY2hlbWE6IHZtLmNvbmZpZy5nZXRTY2hlbWEsXG4gICAgICAgICAgdXBkYXRlU2NoZW1hOiB1cGRhdGVTY2hlbWFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdm0uc2VydmljZS5jb21waWxlKHZtLmNvbmZpZy5zY2hlbWEsIHZtLm1vZGVsLCB2bS5jb25maWcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3dGb3JtKCkge1xuICAgIHJldHVybiAhdm0uZGVsYXlGb3JtICYmIHZtLnNlcnZpY2UgJiYgdm0uc2VydmljZS5pc0NvbXBpbGVkKCk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVTY2hlbWEoc2NoZW1hKSB7XG4gICAgdm0uY29uZmlnLnNjaGVtYSA9IHNjaGVtYTtcbiAgICB2bS5hY3RpdmF0ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBfLmVhY2godm0uZXZlbnRzLCBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9KTtcblxuICAgIGNuRmxleEZvcm1TZXJ2aWNlLmRlc3Ryb3lTZXJ2aWNlKHZtLnNlcnZpY2UpO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgY25GbGV4Rm9ybTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jbi1mbGV4LWZvcm0uZGlyZWN0aXZlLmpzIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIGNuRmxleEZvcm1IZWFkZXIoKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFJyxcbiAgICBzY29wZToge1xuICAgICAgY29uZmlnOiAnPWZmSGVhZGVyQ29uZmlnJyxcbiAgICAgIHN1Ym1pdDogJyZmZlN1Ym1pdCcsXG4gICAgICBsb2FkT2Zmc2NyZWVuOiAnJmZmTG9hZE9mZnNjcmVlbidcbiAgICB9LFxuICAgIGNvbnRyb2xsZXI6IEZsZXhGb3JtSGVhZGVyLFxuICAgIGJpbmRUb0NvbnRyb2xsZXI6IHRydWUsXG4gICAgY29udHJvbGxlckFzOiAndm0nLFxuICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNlwiPlxuICAgICAgICAgIDxoNSBuZy1pZj1cInZtLnRpdGxlLmxlYWRcIj57ezo6dm0udGl0bGUubGVhZH19PC9oNT5cbiAgICAgICAgICA8aDE+XG4gICAgICAgICAgICA8aSBuZy1zaG93PVwidm0udGl0bGUuaWNvblwiIGNsYXNzPVwie3t2bS50aXRsZS5pY29ufX1cIi8+XG4gICAgICAgICAgICB7e3ZtLnRpdGxlLm1haW59fVxuICAgICAgICAgIDwvaDE+XG4gICAgICAgICAgPGg1IG5nLWlmPVwidm0udGl0bGUuc3ViXCI+e3s6OnZtLnRpdGxlLnN1Yn19PC9oNT5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ7e3ZtLmJ1dHRvbkNvbnRhaW5lckNsYXNzIHx8ICdwYWdlLWFjdGlvbi1idG5zJ319XCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1vcHRpb25zXCJcbiAgICAgICAgICAgICAgIG5nLW1vdXNlb3Zlcj1cInZtLmxvYWRPZmZzY3JlZW4oKVwiPlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJidG4gYnRuLXt7dm0ucmV0dXJuU3R5bGUgPyB2bS5yZXR1cm5TdHlsZSA6ICdkZWZhdWx0LWRhcmsnXCJcbiAgICAgICAgICAgICAgIG5nLWlmPVwidm0ucmV0dXJuU3RhdGVcIlxuICAgICAgICAgICAgICAgdWktc3JlZj1cInt7dm0ucmV0dXJuU3RhdGV9fVwiPlxuICAgICAgICAgICAgICB7e3ZtLnJldHVyblRleHQgfHwgJ0NhbmNlbCd9fVxuICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJidG4gYnRuLXt7dm0uY2xvc2VCdXR0b24uc3R5bGUgPyB2bS5jbG9zZUJ1dHRvbi5zdHlsZSA6ICdkZWZhdWx0LWRhcmsnfX1cIlxuICAgICAgICAgICAgICAgbmctaWY9XCJ2bS5jbG9zZUJ1dHRvblwiXG4gICAgICAgICAgICAgICBuZy1jbGljaz1cInZtLmNsb3NlQnV0dG9uLmhhbmRsZXIoKVwiPlxuICAgICAgICAgICAgICAgQ2FuY2VsXG4gICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICA8c3BhbiBuZy1yZXBlYXQ9XCJidXR0b24gaW4gdm0uYWN0aW9uc1wiPlxuICAgICAgICAgICAgICA8c3BhbiBuZy1jbGFzcz1cInsnYnRuLWdyb3VwJzogYnV0dG9uLm9wdGlvbnN9XCI+XG4gICAgICAgICAgICAgICAgPGEgY2xhc3M9XCJidG4ge3tidXR0b24uc3R5bGUgPyAnYnRuLScrYnV0dG9uLnN0eWxlIDogKCRpbmRleCA9PT0gdm0uYWN0aW9ucy5sZW5ndGggLSAxID8gJ2J0bi1wcmltYXJ5JyA6ICdidG4tZGVmYXVsdC1kYXJrJyl9fVwiXG4gICAgICAgICAgICAgICAgICAgbmctZGlzYWJsZWQ9XCJ2bS5pc0Rpc2FibGVkKGJ1dHRvbilcIlxuICAgICAgICAgICAgICAgICAgIG5nLWNsaWNrPVwidm0uaXNEaXNhYmxlZChidXR0b24pIHx8IHZtLnN1Ym1pdCh7aGFuZGxlcjogYnV0dG9uLmhhbmRsZXJ9KVwiXG4gICAgICAgICAgICAgICAgICAgdWliLXRvb2x0aXA9XCJ7e2J1dHRvbi5oZWxwdGV4dH19XCJcbiAgICAgICAgICAgICAgICAgICB1aWItdG9vbHRpcC1wbGFjZW1lbnQ9XCJib3R0b21cIlxuICAgICAgICAgICAgICAgICAgIG5nLWJpbmQtaHRtbD1cImJ1dHRvbi50ZXh0IHx8ICdTYXZlJ1wiPlxuICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICA8YSBjbGFzcz1cImJ0biB7e2J1dHRvbi5zdHlsZSA/ICdidG4tJytidXR0b24uc3R5bGUgOiAoJGluZGV4ID09PSB2bS5hY3Rpb25zLmxlbmd0aCAtIDEgPyAnYnRuLXByaW1hcnknIDogJ2J0bi1kZWZhdWx0LWRhcmsnKX19IGRyb3Bkb3duLXRvZ2dsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBuZy1kaXNhYmxlZD1cInZtLmlzRGlzYWJsZWQoYnV0dG9uKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBuZy1zaG93PVwiYnV0dG9uLm9wdGlvbnNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS10b2dnbGU9XCJkcm9wZG93blwiPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjYXJldFwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgPHVsIGNsYXNzPVwiZHJvcGRvd24tbWVudVwiIG5nLWlmPVwiYnV0dG9uLm9wdGlvbnNcIj5cbiAgICAgICAgICAgICAgICAgIDxsaSBuZy1yZXBlYXQ9XCJvcHRpb24gaW4gYnV0dG9uLm9wdGlvbnNcIlxuICAgICAgICAgICAgICAgICAgICAgIG5nLWRpc2FibGVkPVwidm0uaXNEaXNhYmxlZChvcHRpb24pXCI+XG4gICAgICAgICAgICAgICAgICAgIDxhIG5nLWNsaWNrPVwidm0uaXNEaXNhYmxlZChvcHRpb24pIHx8IHZtLnN1Ym1pdCh7aGFuZGxlcjogb3B0aW9uLmhhbmRsZXJ9KVwiXG4gICAgICAgICAgICAgICAgICAgICAgIG5nLWJpbmQtaHRtbD1cIm9wdGlvbi50ZXh0XCI+XG4gICAgICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxwIGNsYXNzPVwiZGF0YS11cGRhdGVkLWF0IHRleHQtcmlnaHRcIlxuICAgICAgICAgICAgIGlkPVwiZGF0YS11cGRhdGVkLWF0XCJcbiAgICAgICAgICAgICBuZy1oaWRlPVwidm0uY29uZmlnLm5vRGF0YVwiPlxuICAgICAgICAgICAgPGEgbmctY2xpY2s9XCJ2bS51cGRhdGVEYXRhKClcIj5VcGRhdGUgRGF0YTwvYT5cbiAgICAgICAgICA8L3A+XG4gICAgICAgIDwvZGl2PmBcbiAgfTtcbn1cblxuZnVuY3Rpb24gRmxleEZvcm1IZWFkZXIoJHNjb3BlKSB7XG4gICduZ0luamVjdCc7XG5cbiAgZnVuY3Rpb24gZmZIZWFkZXJUYWcoKSB7fVxuICAkc2NvcGUuX190YWcgPSBuZXcgZmZIZWFkZXJUYWcoKTtcblxuICBjb25zdCB2bSA9IHRoaXM7XG5cbiAgdm0udXBkYXRlRGF0YSA9IHVwZGF0ZURhdGE7XG4gIHZtLmlzRGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuXG4gIC8vYWN0aXZhdGUoKTtcbiAgLy8kc2NvcGUuJG9uKCckZGVzdHJveScsIGNsZWFudXApO1xuICAkc2NvcGUuJHdhdGNoKCd2bS5jb25maWcudGl0bGUnLCBpbml0VGl0bGUsIHRydWUpO1xuICAkc2NvcGUuJHdhdGNoKCd2bS5jb25maWcuYWN0aW9uQ29uZmlnJywgaW5pdEFjdGlvbkNvbmZpZywgdHJ1ZSk7XG5cbiAgLy8vLy8vLy8vLy9cblxuICBmdW5jdGlvbiBpbml0VGl0bGUoKSB7XG4gICAgKHsgdGl0bGU6IHZtLnRpdGxlIH0gPSB2bS5jb25maWcpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdEFjdGlvbkNvbmZpZygpIHtcbiAgICAoe1xuICAgICAgcmV0dXJuU3RhdGU6IHZtLnJldHVyblN0YXRlLFxuICAgICAgcmV0dXJuU3R5bGU6IHZtLnJldHVyblN0eWxlLFxuICAgICAgcmV0dXJuVGV4dDogdm0ucmV0dXJuVGV4dCxcbiAgICAgIGNsb3NlQnV0dG9uOiB2bS5jbG9zZUJ1dHRvbixcbiAgICAgIGFjdGlvbnM6IHZtLmFjdGlvbnNcbiAgICB9ID0gdm0uY29uZmlnLmFjdGlvbkNvbmZpZyB8fCB7fSk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVEYXRhKCkge1xuICAgIC8vICRzY29wZS4kZW1pdCgnZmZSZWZyZXNoRGF0YScpO1xuICAgIC8vIHRoaXMgY29tcG9uZW50IHdpbGwgb2Z0ZW4gYmUgc2libGluZ3MgdG8gdGhlIGZsZXggZm9ybXMgb25lLFxuICAgIC8vIHNvIG5lZWQgdG8gYnJvYWRjYXN0IGZyb20gc2hhcmVkIHBhcmVudC4uLnllcyBpdCdzIHVnbHlcbiAgICAkc2NvcGUuJHBhcmVudC4kcGFyZW50LiRicm9hZGNhc3QoJ2ZmUmVmcmVzaERhdGEnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRGlzYWJsZWQoYnRuQ29uZmlnKSB7XG4gICAgaWYodm0uY29uZmlnLmlzRGlzYWJsZWQpIHJldHVybiB2bS5jb25maWcuaXNEaXNhYmxlZChidG5Db25maWcpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbkZsZXhGb3JtSGVhZGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NuLWZsZXgtZm9ybS1oZWFkZXIuZGlyZWN0aXZlLmpzIiwiZnVuY3Rpb24gZmZWYWxpZGF0ZSgpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIHNjb3BlOiB7IGZvcm06ICc9ZmZWYWxpZGF0ZScgfSxcbiAgICByZXF1aXJlOiAnbmdNb2RlbCcsXG4gICAgbGluazogbGlua1xuICB9O1xufVxuXG5mdW5jdGlvbiBsaW5rKCRzY29wZSwgZWxlbSwgYXR0cnMsIG5nTW9kZWwpIHtcbiAgZnVuY3Rpb24gZmZWYWxpZGF0ZVRhZygpIHt9XG4gICRzY29wZS5fX3RhZyA9IG5ldyBmZlZhbGlkYXRlVGFnKCk7XG5cbiAgaWYoJHNjb3BlLmZvcm0gJiYgJHNjb3BlLmZvcm0ucmVxdWlyZWQpIHtcbiAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uKCkgeyByZXR1cm4gbmdNb2RlbC4kdmlld1ZhbHVlOyB9LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgLy8gb3ZlcnJpZGUgc2NoZW1hRm9ybSB2YWxpZGF0aW9uXG4gICAgICBuZ01vZGVsLiRzZXRWYWxpZGl0eSgnc2NoZW1hRm9ybScsIHRydWUpO1xuICAgICAgbmdNb2RlbC4kc2V0VmFsaWRpdHkoJ3R2NC0zMDInLCB2YWx1ZSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZmZWYWxpZGF0ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jbi1mbGV4LWZvcm0tdmFsaWRhdGUuZGlyZWN0aXZlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==